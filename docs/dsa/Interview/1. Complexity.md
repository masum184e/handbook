<!-- - C++ compiler can produce 10^8 number of operation in a second
- number of digit = logN + 1
- Hill Pattern
- harmonic divisor number
- Exponenttial time compelxity
    - overlapping subproblem
## O(n!) ‚Äî Factorial Time Complexity

‡¶è‡¶¨‡¶æ‡¶∞ ‡¶ö‡¶≤‡ßã ‡¶è‡¶Æ‡¶® ‡¶è‡¶ï‡¶ü‡¶æ problem ‡¶¶‡ßá‡¶ñ‡¶ø ‡¶Ø‡ßá‡¶ü‡¶æ ‡¶∂‡ßÅ‡¶®‡¶§‡ßá ‡¶∏‡ßã‡¶ú‡¶æ, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶ï‡¶∞‡¶§‡ßá ‡¶ó‡ßá‡¶≤‡ßá ‡¶≠‡¶Ø‡¶º‡¶Ç‡¶ï‡¶∞!

## Problem:

‡¶§‡ßã‡¶Æ‡¶æ‡¶ï‡ßá n ‡¶ü‡¶æ element ‡¶¶‡ßá‡¶ì‡¶Ø‡¶º‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶è‡¶¶‡ßá‡¶∞ ‡¶∏‡¶¨‡¶ó‡ßÅ‡¶≤‡ßã possible permutation (‡¶∏‡¶æ‡¶ú‡¶æ‡¶®‡ßã‡¶∞ ‡¶ï‡ßç‡¶∞‡¶Æ) ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡ßã‡•§

‡¶Ø‡ßá‡¶Æ‡¶®, `{1, 2, 3}` ‚Äî ‡¶è‡¶¶‡ßá‡¶∞ ‡¶ï‡¶§ ‡¶≠‡¶æ‡¶¨‡ßá ‡¶∏‡¶æ‡¶ú‡¶æ‡¶®‡ßã ‡¶Ø‡¶æ‡¶Ø‡¶º?

```
{1, 2, 3}
{1, 3, 2}
{2, 1, 3}
{2, 3, 1}
{3, 1, 2}
{3, 2, 1}
```

‡¶Æ‡ßã‡¶ü 6 ‡¶ü‡¶æ ‡¶∏‡¶æ‡¶ú‡¶æ‡¶®‡ßã‡¶∞ ‡¶â‡¶™‡¶æ‡¶Ø‡¶º‡•§ ‡¶ó‡¶£‡¶ø‡¶§‡ßá ‡¶è‡¶ü‡¶æ‡¶ï‡ßá ‡¶¨‡¶≤‡ßá  
**3! (3 factorial) = 3 √ó 2 √ó 1 = 6**

### ‡¶ï‡ßá‡¶® 3 √ó 2 √ó 1?

‡¶ö‡¶ø‡¶®‡ßç‡¶§‡¶æ ‡¶ï‡¶∞‡ßã ‚Äî

- ‡¶™‡ßç‡¶∞‡¶•‡¶Æ position ‡¶è 3 ‡¶ü‡¶æ element ‡¶è‡¶∞ ‡¶Ø‡ßá‡¶ï‡ßã‡¶®‡ßã ‡¶è‡¶ï‡¶ü‡¶æ ‡¶¨‡¶∏‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá
- ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡¶ü‡¶æ ‡¶¨‡¶∏‡¶æ‡¶®‡ßã‡¶∞ ‡¶™‡¶∞ ‡¶¶‡ßç‡¶¨‡¶ø‡¶§‡ßÄ‡¶Ø‡¶º position ‡¶è ‡¶¨‡¶æ‡¶ï‡¶ø 2 ‡¶ü‡¶æ‡¶∞ ‡¶Ø‡ßá‡¶ï‡ßã‡¶®‡ßã ‡¶è‡¶ï‡¶ü‡¶æ
- ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ ‡¶§‡ßÉ‡¶§‡ßÄ‡¶Ø‡¶º position ‡¶è ‡¶¨‡¶æ‡¶ï‡¶ø 1 ‡¶ü‡¶æ

‡¶§‡¶æ‡¶á total = **3 √ó 2 √ó 1 = 6**

---

## C++ ‡¶è permutation ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ (STL ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá)

C++ ‡¶è STL ‡¶è‡¶∞ `next_permutation` function ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶ñ‡ßÅ‡¶¨ ‡¶∏‡¶π‡¶ú‡ßá ‡¶∏‡¶¨ permutation ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º:

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> nums = {1, 2, 3};
    sort(nums.begin(), nums.end());  // ‡¶õ‡ßã‡¶ü ‡¶•‡ßá‡¶ï‡ßá ‡¶¨‡¶°‡¶º ‡¶∏‡¶æ‡¶ú‡¶æ‡¶ì (‡¶™‡ßç‡¶∞‡¶•‡¶Æ permutation)

    do {
        for (int x : nums)
            cout << x << " ";  // ‡¶è‡¶á permutation ‡¶ü‡¶æ print ‡¶ï‡¶∞‡ßã
        cout << endl;
    } while (next_permutation(nums.begin(), nums.end()));  // ‡¶™‡¶∞‡ßá‡¶∞ permutation ‡¶è ‡¶Ø‡¶æ‡¶ì

    return 0;
}
```

`next_permutation` ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶¨‡¶æ‡¶∞ call ‡¶ï‡¶∞‡¶≤‡ßá array ‡¶ï‡ßá ‡¶™‡¶∞‡ßá‡¶∞ permutation ‡¶è ‡¶∏‡¶æ‡¶ú‡¶ø‡¶Ø‡¶º‡ßá ‡¶¶‡ßá‡¶Ø‡¶º‡•§
‡¶è‡¶ü‡¶æ internally O(n) time ‡¶è ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá (element swap ‡¶ï‡¶∞‡ßá ‡¶™‡¶∞‡ßá‡¶∞ arrangement ‡¶¨‡¶æ‡¶®‡¶æ‡¶Ø‡¶º)‡•§

‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶Æ‡ßã‡¶ü ‡¶ï‡¶§‡¶ó‡ßÅ‡¶≤‡ßã permutation ‡¶Ü‡¶õ‡ßá? n! ‡¶ü‡¶æ‡•§

‡¶§‡¶æ‡¶á ‡¶∏‡¶¨‡¶ó‡ßÅ‡¶≤‡ßã permutation generate ‡¶ï‡¶∞‡¶§‡ßá total complexity:

n! √ó n = O(n √ó n!)

Big O ‡¶§‡ßá ‡¶∏‡¶¨‡¶ö‡ßá‡¶Ø‡¶º‡ßá ‡¶¨‡¶°‡¶º factor ‡¶ß‡¶∞‡¶ø, ‡¶§‡¶æ‡¶á ‡¶è‡¶ü‡¶æ‡¶ï‡ßá O(n!) ‡¶¨‡¶≤‡¶ø‡•§

n ‡¶¨‡¶æ‡¶°‡¶º‡¶≤‡ßá ‡¶ï‡ßÄ ‡¶π‡¶Ø‡¶º?

```
n = 3  ‚Üí 3!  = 6                     ‚Äî ‡¶ö‡ßã‡¶ñ‡ßá‡¶∞ ‡¶™‡¶≤‡¶ï‡ßá ‡¶∂‡ßá‡¶∑
n = 10 ‚Üí 10! = 36,28,800              ‚Äî 36 ‡¶≤‡¶æ‡¶ñ‡ßá‡¶∞ ‡¶¨‡ßá‡¶∂‡¶ø! ‡¶è‡¶ï‡¶ü‡ßÅ ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶ö‡¶≤‡¶¨‡ßá
n = 15 ‚Üí 15! = 1,30,76,74,36,800      ‚Äî 130 ‡¶¨‡¶ø‡¶≤‡¶ø‡¶Ø‡¶º‡¶®! ‡¶ò‡¶£‡ßç‡¶ü‡¶æ‡¶∞ ‡¶™‡¶∞ ‡¶ò‡¶£‡ßç‡¶ü‡¶æ ‡¶ö‡¶æ‡¶≤‡¶ø‡¶Ø‡¶º‡ßá ‡¶∞‡¶æ‡¶ñ‡¶≤‡ßá‡¶ì ‡¶∂‡ßá‡¶∑ ‡¶π‡¶¨‡ßá ‡¶®‡¶æ
n = 20 ‚Üí 20! = 2,43,29,02,00,81,76,64,000 ‚Äî ‡¶≠‡ßÅ‡¶≤‡ßá‡¶á ‡¶Ø‡¶æ‡¶ì!
```

O(n!) ‡¶π‡¶≤‡ßã ‡¶∏‡¶¨‡¶ö‡ßá‡¶Ø‡¶º‡ßá ‡¶ß‡ßÄ‡¶∞ complexity ‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶è‡¶ï‡¶ü‡¶æ‡•§
n = 20 ‡¶è‡¶∞ ‡¶¨‡ßá‡¶∂‡¶ø ‡¶π‡¶≤‡ßá practically impossible‡•§

```markdown
# O(2‚Åø) ‚Äî Exponential Time Complexity

‡¶è‡¶¨‡¶æ‡¶∞ ‡¶è‡¶ï‡¶ü‡ßÅ special topic‡•§ ‡¶è‡¶á complexity ‡¶ü‡¶æ interview ‡¶§‡ßá ‡¶∏‡¶¨‡¶ö‡ßá‡¶Ø‡¶º‡ßá ‡¶¨‡ßá‡¶∂‡¶ø ‡¶Ü‡¶∏‡ßá ‚Äî ‡¶ï‡¶æ‡¶∞‡¶£ ‡¶è‡¶ü‡¶æ ‡¶¨‡ßã‡¶ù‡¶æ‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá‡¶á ‡¶§‡ßÅ‡¶Æ‡¶ø Dynamic Programming (DP) ‡¶è‡¶∞ ‡¶¶‡ßÅ‡¶®‡¶ø‡¶Ø‡¶º‡¶æ‡¶Ø‡¶º ‡¶¢‡ßÅ‡¶ï‡¶¨‡ßá‡•§ DP ‡¶π‡¶≤‡ßã interview ‡¶è‡¶∞ ‡¶∏‡¶¨‡¶ö‡ßá‡¶Ø‡¶º‡ßá important ‡¶Ü‡¶∞ commonly asked topic ‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶è‡¶ï‡¶ü‡¶æ‡•§ ‡¶§‡¶æ‡¶á ‡¶è‡¶á section ‡¶ü‡¶æ ‡¶Æ‡¶® ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶™‡¶°‡¶º‡ßã‡•§

---

## Problem: Fibonacci Sequence ‡¶è‡¶∞ n-‡¶§‡¶Æ number ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡ßã

### Fibonacci ‡¶ï‡ßÄ?

‡¶è‡¶ü‡¶æ ‡¶è‡¶ï‡¶ü‡¶æ ‡¶¨‡¶ø‡¶ñ‡ßç‡¶Ø‡¶æ‡¶§ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶∞ ‡¶ß‡¶æ‡¶∞‡¶æ ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶æ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶§‡¶æ‡¶∞ ‡¶Ü‡¶ó‡ßá‡¶∞ ‡¶¶‡ßÅ‡¶á‡¶ü‡¶æ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶∞ ‡¶Ø‡ßã‡¶ó‡¶´‡¶≤:

```

index:  0  1  2  3  4  5  6  7   8   9
value:  0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...

```

‡¶¶‡ßá‡¶ñ‡ßã ‚Äî
- F(0) = 0  
- F(1) = 1  

‡¶§‡¶æ‡¶∞‡¶™‡¶∞ ‡¶•‡ßá‡¶ï‡ßá ‡¶Ü‡¶ó‡ßá‡¶∞ ‡¶¶‡ßÅ‡¶ü‡ßã ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßá ‡¶™‡¶∞‡ßá‡¶∞‡¶ü‡¶æ ‡¶™‡¶æ‡¶ö‡ßç‡¶õ‡¶ø:

- F(2) = 0 + 1 = 1  
- F(3) = 1 + 1 = 2  
- F(4) = 1 + 2 = 3  
- F(5) = 2 + 3 = 5  
- F(6) = 3 + 5 = 8  

---

## Mathematical Equation

```

F(0) = 0
F(1) = 1
F(n) = F(n-1) + F(n-2)    (n ‚â• 2 ‡¶π‡¶≤‡ßá)

````

‡¶Æ‡¶æ‡¶®‡ßá F(5) ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶≤‡ßá ‡¶Ü‡¶ó‡ßá F(4) ‡¶Ü‡¶∞ F(3) ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶¨‡ßá‡•§

- F(4) ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶≤‡ßá F(3) ‡¶Ü‡¶∞ F(2)
- F(3) ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶≤‡ßá F(2) ‡¶Ü‡¶∞ F(1)

‡¶¶‡ßá‡¶ñ‡ßã ‚Äî ‡¶¨‡¶°‡¶º problem ‡¶ï‡ßá ‡¶õ‡ßã‡¶ü ‡¶õ‡ßã‡¶ü problem (subproblem) ‡¶è ‡¶≠‡¶æ‡¶ô‡¶§‡ßá ‡¶π‡¶ö‡ßç‡¶õ‡ßá‡•§

---

## Divide and Conquer Pattern

‡¶è‡¶ü‡¶æ ‡¶Ü‡¶∏‡¶≤‡ßá ‡¶è‡¶ï‡¶ü‡¶æ Divide and Conquer style problem‡•§

‡¶ï‡¶æ‡¶∞‡¶£:
- ‡¶¨‡¶°‡¶º problem ‚Üí ‡¶õ‡ßã‡¶ü ‡¶¶‡ßÅ‡¶á‡¶ü‡¶æ subproblem
- ‡¶õ‡ßã‡¶ü problem ‚Üí ‡¶Ü‡¶∞‡¶ì ‡¶õ‡ßã‡¶ü subproblem
- ‡¶∂‡ßá‡¶∑‡ßá base case ‡¶è ‡¶ó‡¶ø‡¶Ø‡¶º‡ßá ‡¶•‡¶æ‡¶Æ‡ßá
- ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ ‡¶õ‡ßã‡¶ü answer ‡¶Æ‡¶ø‡¶≤‡¶ø‡¶Ø‡¶º‡ßá ‡¶¨‡¶°‡¶º answer ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡¶Ø‡¶º

‡¶è‡¶á pattern ‡¶ü‡¶æ programming ‡¶è ‡¶¨‡¶æ‡¶∞‡¶¨‡¶æ‡¶∞ ‡¶Ü‡¶∏‡¶¨‡ßá:
- Binary Tree traversal  
- Segment Tree  
- Merge Sort  

‡¶∏‡¶¨‡¶ñ‡¶æ‡¶®‡ßá‡¶á ‡¶è‡¶á ‚Äú‡¶¨‡¶°‡¶º problem ‡¶≠‡¶æ‡¶ô‡ßã ‚Üí ‡¶õ‡ßã‡¶ü solve ‡¶ï‡¶∞‡ßã ‚Üí ‡¶Æ‡¶ø‡¶≤‡¶æ‡¶ì‚Äù pattern‡•§

---

## Recursive Implementation (Naive)

```cpp
int fib(int n) {
    if (n <= 1) return n;            // base case: F(0)=0, F(1)=1
    return fib(n - 1) + fib(n - 2);  // ‡¶¨‡¶°‡¶º problem = ‡¶¶‡ßÅ‡¶á‡¶ü‡¶æ ‡¶õ‡ßã‡¶ü problem ‡¶è‡¶∞ ‡¶Ø‡ßã‡¶ó
}
````

‡¶¶‡ßá‡¶ñ‡¶§‡ßá ‡¶∏‡ßÅ‡¶®‡ßç‡¶¶‡¶∞, simple ‚Äî ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ 3 ‡¶≤‡¶æ‡¶á‡¶®!

‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶≠‡ßá‡¶§‡¶∞‡ßá ‡¶≠‡¶Ø‡¶º‡¶Ç‡¶ï‡¶∞ ‡¶ú‡¶ø‡¶®‡¶ø‡¶∏ ‡¶ò‡¶ü‡¶õ‡ßá‡•§

---

## Recursive Tree (fib(5))

```
                       fib(5)
                      /      \
                 fib(4)       fib(3)
                /     \       /     \
            fib(3)  fib(2)  fib(2)  fib(1)
            /   \   /   \   /   \
         fib(2) fib(1) fib(1) fib(0) fib(1) fib(0)
         /   \
      fib(1) fib(0)
```

‡¶¶‡ßá‡¶ñ‡ßã ‡¶ï‡ßÄ ‡¶ò‡¶ü‡¶õ‡ßá!

* ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶æ function call ‚Üí ‡ß®‡¶ü‡¶æ ‡¶®‡¶§‡ßÅ‡¶® call
* ‡¶è‡¶ï‡¶ü‡¶æ (n-1)
* ‡¶è‡¶ï‡¶ü‡¶æ (n-2)

‡¶Æ‡¶æ‡¶®‡ßá ‡¶è‡¶ï‡¶ü‡¶æ Binary Tree ‡¶è‡¶∞ ‡¶Æ‡¶§‡ßã structure ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡¶ö‡ßç‡¶õ‡ßá‡•§

---

## Call Explosion

* fib(5) ‚Üí 15 ‡¶ü‡¶æ function call
* fib(10) ‚Üí 177 ‡¶ü‡¶æ call
* fib(30) ‚Üí ‡ß®‡ß¨ ‡¶≤‡¶æ‡¶ñ‡ßá‡¶∞ ‡¶¨‡ßá‡¶∂‡¶ø call
* fib(50) ‚Üí ‡¶™‡ßç‡¶∞‡¶æ‡¶Ø‡¶º ‡ßß,‡ß®‡ß´‡ß¶ ‡¶ï‡ßã‡¶ü‡¶ø call

n ‡¶è‡¶ï‡¶ü‡ßÅ ‡¶¨‡¶æ‡¶°‡¶º‡¶≤‡ßá‡¶á operation ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶∞‡¶ï‡ßá‡¶ü‡ßá‡¶∞ ‡¶Æ‡¶§‡ßã ‡¶¨‡¶æ‡¶°‡¶º‡ßá‡•§

---

## ‡¶ï‡ßá‡¶® O(2‚Åø)?

‡¶è‡¶ï‡¶ü‡¶æ perfect binary tree ‡¶ï‡¶≤‡ßç‡¶™‡¶®‡¶æ ‡¶ï‡¶∞‡ßã:

```
Level 0:              O                 ‚Üí 2‚Å∞ = 1
                     / \
Level 1:            O   O               ‚Üí 2¬π = 2
                   / \ / \
Level 2:          O  O O  O             ‚Üí 2¬≤ = 4
                 /\/\/\/\/\
Level 3:        O O O O O O O O         ‚Üí 2¬≥ = 8
```

Pattern:

```
1 ‚Üí 2 ‚Üí 4 ‚Üí 8 ‚Üí ... ‚Üí 2‚Åø
```

Total nodes ‚âà

```
2‚Å∞ + 2¬π + 2¬≤ + ... + 2‚Åø
= 2‚Åø‚Å∫¬π - 1
‚âà 2‚Åø
```

‡¶¨‡¶æ‡¶∏‡ßç‡¶§‡¶¨‡ßá Fibonacci tree perfect binary tree ‡¶®‡¶æ, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ growth rate ‡¶è‡¶ï‡¶á‡•§

‡¶§‡¶æ‡¶á Time Complexity = **O(2‚Åø)**

‡¶è‡¶ü‡¶æ‡¶ï‡ßá ‡¶¨‡¶≤‡ßá **Exponential Time Complexity**‡•§

---

## ‡¶Ü‡¶∏‡¶≤ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: Overlapping Subproblems

Recursive tree ‡¶≠‡¶æ‡¶≤‡ßã ‡¶ï‡¶∞‡ßá ‡¶¶‡ßá‡¶ñ‡ßã‡•§

* fib(3) ‡¶¶‡ßÅ‡¶á‡¶¨‡¶æ‡¶∞ ‡¶π‡¶ö‡ßç‡¶õ‡ßá
* fib(2) ‡¶§‡¶ø‡¶®‡¶¨‡¶æ‡¶∞ ‡¶π‡¶ö‡ßç‡¶õ‡ßá
* fib(1) ‡¶™‡¶æ‡¶Å‡¶ö‡¶¨‡¶æ‡¶∞ ‡¶π‡¶ö‡ßç‡¶õ‡ßá

Same subproblem ‡¶¨‡¶æ‡¶∞‡¶¨‡¶æ‡¶∞ solve ‡¶π‡¶ö‡ßç‡¶õ‡ßá!

‡¶è‡¶ü‡¶æ‡¶ï‡ßá ‡¶¨‡¶≤‡ßá **Overlapping Subproblems**‡•§

---

## Optimization Idea

fib(3) ‡¶è‡¶∞ answer ‡¶∏‡¶¨‡¶∏‡¶Æ‡ßü 2‡•§

‡¶§‡¶æ‡¶π‡¶≤‡ßá:

* ‡¶è‡¶ï‡¶¨‡¶æ‡¶∞ calculate ‡¶ï‡¶∞‡¶ø
* ‡¶ï‡ßã‡¶•‡¶æ‡¶ì save ‡¶ï‡¶∞‡ßá ‡¶∞‡¶æ‡¶ñ‡¶ø
* ‡¶™‡¶∞‡ßá‡¶∞‡¶¨‡¶æ‡¶∞ calculate ‡¶®‡¶æ ‡¶ï‡¶∞‡ßá saved value ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶ø

‡¶è‡¶á technique ‡¶ü‡¶æ‡¶ï‡ßá ‡¶¨‡¶≤‡ßá **Memoization**‡•§

‡¶Ü‡¶∞ ‡¶™‡ßÅ‡¶∞‡ßã concept ‡¶ü‡¶æ ‡¶π‡¶≤‡ßã **Dynamic Programming (DP)**‡•§

---

## DP ‡¶è‡¶∞ ‡¶Æ‡ßÇ‡¶≤ ‡¶ï‡¶•‡¶æ

1. ‡¶¨‡¶°‡¶º problem ‡¶ï‡ßá ‡¶õ‡ßã‡¶ü subproblem ‡¶è ‡¶≠‡¶æ‡¶ô‡ßã
2. Overlapping subproblem ‡¶ö‡¶ø‡¶®‡ßã
3. ‡¶è‡¶ï‡¶¨‡¶æ‡¶∞ solve ‡¶ï‡¶∞‡ßá save ‡¶ï‡¶∞‡ßã
4. ‡¶™‡¶∞‡ßá‡¶∞‡¶¨‡¶æ‡¶∞ save ‡¶•‡ßá‡¶ï‡ßá ‡¶®‡¶æ‡¶ì

---

## Recursive + Memoization (DP Solution)

```cpp
int dp[1000];   // ‡¶∏‡¶¨ -1 ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá initialize ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶¨‡ßá

int fib(int n) {
    if (n <= 1) return n;             
    if (dp[n] != -1) return dp[n];    // ‡¶Ü‡¶ó‡ßá solve ‡¶ï‡¶∞‡ßá‡¶õ‡¶ø?

    dp[n] = fib(n - 1) + fib(n - 2);  // ‡¶®‡¶§‡ßÅ‡¶®? solve ‡¶ï‡¶∞‡ßá save ‡¶ï‡¶∞‡ßã
    return dp[n];
}
```

‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶ï‡ßÄ ‡¶π‡¶≤‡ßã?

* ‡¶Ü‡¶ó‡ßá check ‡¶ï‡¶∞‡¶ø answer ‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø ‡¶®‡¶æ
* ‡¶•‡¶æ‡¶ï‡¶≤‡ßá ‡¶∏‡¶∞‡¶æ‡¶∏‡¶∞‡¶ø return
* ‡¶®‡¶æ ‡¶•‡¶æ‡¶ï‡¶≤‡ßá calculate ‡¶ï‡¶∞‡ßá save

---

## Complexity Reduction

‡¶Ü‡¶ó‡ßá:

```
O(2‚Åø)
```

‡¶è‡¶ñ‡¶®:

```
O(n)
```

fib(50):

* ‡¶Ü‡¶ó‡ßá ‚Üí ~‡ßß,‡ß®‡ß´‡ß¶ ‡¶ï‡ßã‡¶ü‡¶ø call
* ‡¶è‡¶ñ‡¶® ‚Üí ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ ‡ß´‡ß¶‡¶ü‡¶æ unique subproblem

---

## Interview Insight

Interviewer ‡¶Ø‡¶ñ‡¶® Fibonacci ‡¶≤‡¶ø‡¶ñ‡¶§‡ßá ‡¶¨‡¶≤‡ßá, ‡¶∏‡ßá ‡¶Ü‡¶∏‡¶≤‡ßá ‡¶¶‡ßá‡¶ñ‡¶§‡ßá ‡¶ö‡¶æ‡¶Ø‡¶º:

* ‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶ï‡¶ø naive recursive solution (O(2‚Åø)) ‡¶≤‡¶ø‡¶ñ‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßã?
* ‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶ï‡¶ø overlapping subproblem ‡¶ö‡¶ø‡¶®‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßã?
* ‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶ï‡¶ø DP ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá optimize ‡¶ï‡¶∞‡ßá O(n) ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßã?

‡¶è‡¶á transformation ‡¶ü‡¶æ‡¶á ‡¶π‡¶≤‡ßã Dynamic Programming ‡¶è‡¶∞ magic‡•§

```
```

# ‡¶ï‡¶§‡¶ü‡¶æ Operation ‡¶Æ‡ßã‡¶ü‡¶æ‡¶Æ‡ßÅ‡¶ü‡¶ø Okay?

C++ ‡¶è ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£‡¶§ 1 ‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶°‡ßá ‡¶™‡ßç‡¶∞‡¶æ‡¶Ø‡¶º **10‚Å∏ (10 ‡¶ï‡ßã‡¶ü‡¶ø)** operation process ‡¶π‡¶Ø‡¶º‡•§ ‡¶§‡¶æ‡¶á problem solve ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º `n` ‡¶è‡¶∞ range ‡¶¶‡ßá‡¶ñ‡ßá ‡¶Ü‡¶ó‡ßá ‡¶•‡ßá‡¶ï‡ßá‡¶á ‡¶Ü‡¶®‡ßç‡¶¶‡¶æ‡¶ú ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º ‡¶ï‡ßã‡¶® time complexity ‡¶ö‡¶≤‡¶¨‡ßá‡•§

---

## n ‡¶è‡¶∞ Range vs Acceptable Complexity

| n ‡¶è‡¶∞ range            | ‡¶ï‡ßã‡¶® complexity ‡¶ö‡¶≤‡¶¨‡ßá        |
|-----------------------|-----------------------------|
| n ‚â§ 10‚Äì12             | O(n!) ‡¶ö‡¶≤‡¶¨‡ßá                 |
| n ‚â§ 20‚Äì25             | O(2‚Åø) ‡¶ö‡¶≤‡¶¨‡ßá                 |
| n ‚â§ 10,000            | O(n¬≤) ‡¶ö‡¶≤‡¶¨‡ßá                 |
| n ‚â§ 10,00,000         | O(n log n) ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞           |
| n ‚â§ 10,00,00,000      | O(n) ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞                 |
| n > 10,00,00,000      | O(log n) ‡¶¨‡¶æ O(1) ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞     |

---

 ‡¶è‡¶á table ‡¶ü‡¶æ interview ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶è‡¶ï‡¶¶‡¶Æ **gold** üíõ

Problem ‡¶è `n` ‡¶è‡¶∞ range ‡¶¶‡ßá‡¶ñ‡ßá‡¶á ‡¶¨‡ßÅ‡¶ù‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá ‚Äî  
‡¶§‡ßã‡¶Æ‡¶æ‡¶ï‡ßá ‡¶ï‡¶ø brute force ‡¶≤‡¶ø‡¶ñ‡¶§‡ßá ‡¶π‡¶¨‡ßá, ‡¶®‡¶æ efficient algorithm ‡¶ö‡¶ø‡¶®‡ßç‡¶§‡¶æ ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶¨‡ßá‡•§

# Common Mistakes ‚Äî Interview ‡¶§‡ßá ‡¶è‡¶ó‡ßÅ‡¶≤‡ßã ‡¶ï‡¶∞‡ßã ‡¶®‡¶æ!

---

## ‚ùå ‡¶≠‡ßÅ‡¶≤ 1: "O(2n) ‡¶Ü‡¶∞ O(n) ‡¶ï‡¶ø ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ?"

‡¶®‡¶æ!

Big O ‡¶§‡ßá **constant ‡¶¨‡¶æ‡¶¶ ‡¶¶‡¶ø‡¶á**‡•§

```
O(2n) = O(n)
```

‡¶ï‡¶æ‡¶∞‡¶£ Big O growth rate ‡¶®‡¶ø‡¶Ø‡¶º‡ßá ‡¶ï‡¶•‡¶æ ‡¶¨‡¶≤‡ßá, exact speed ‡¶®‡¶æ‡•§

‡¶§‡¶¨‡ßá practical ‡¶è:
- ‡¶¶‡ßÅ‡¶á‡¶ü‡¶æ loop ‡¶è‡¶ï‡¶ü‡¶æ‡¶∞ ‡¶ö‡ßá‡¶Ø‡¶º‡ßá ‡¶Ö‡¶¨‡¶∂‡ßç‡¶Ø‡¶á slow
- ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ asymptotic analysis ‡¶è constant matter ‡¶ï‡¶∞‡ßá ‡¶®‡¶æ
## ‚ùå ‡¶≠‡ßÅ‡¶≤ 2: "HashMap ‡¶∏‡¶¨‡¶∏‡¶Æ‡¶Ø‡¶º O(1)"

‡¶è‡¶ü‡¶æ ‡¶™‡ßÅ‡¶∞‡ßã‡¶™‡ßÅ‡¶∞‡¶ø ‡¶∏‡¶§‡ßç‡¶Ø ‡¶®‡¶æ‡•§

- **Average case:** O(1)  
- **Worst case:** O(n)

‡¶ï‡ßá‡¶®?

‡¶Ø‡¶¶‡¶ø ‡¶Ö‡¶®‡ßá‡¶ï‡¶ó‡ßÅ‡¶≤‡ßã key ‡¶è‡¶ï‡¶á bucket ‡¶è ‡¶ó‡¶ø‡¶Ø‡¶º‡ßá ‡¶™‡¶°‡¶º‡ßá (hash collision),  
‡¶§‡¶ñ‡¶® internally linked list (‡¶¨‡¶æ chain) traverse ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶Ø‡¶º ‚Üí O(n)

### Interview ‡¶è ‡¶ï‡ßÄ ‡¶¨‡¶≤‡¶¨‡ßá?

> "HashMap gives us O(1) average lookup. Worst case is O(n) due to collisions, but with a good hash function, that's rare."

‡¶è‡¶á ‡¶è‡¶ï ‡¶≤‡¶æ‡¶á‡¶® ‡¶¨‡¶≤‡¶≤‡ßá‡¶á interviewer ‡¶¨‡ßÅ‡¶ù‡¶¨‡ßá ‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶¨‡¶ø‡¶∑‡¶Ø‡¶º‡¶ü‡¶æ ‡¶ó‡¶≠‡ßÄ‡¶∞‡¶≠‡¶æ‡¶¨‡ßá ‡¶ú‡¶æ‡¶®‡ßã‡•§

---

## ‚ùå ‡¶≠‡ßÅ‡¶≤ 3: "Recursion ‡¶Æ‡¶æ‡¶®‡ßá‡¶á O(2‚Åø)"

‡¶è‡¶ï‡¶¶‡¶Æ ‡¶≠‡ßÅ‡¶≤!

Recursion ‡¶è‡¶∞ complexity ‡¶®‡¶ø‡¶∞‡ßç‡¶≠‡¶∞ ‡¶ï‡¶∞‡ßá:
- ‡¶ï‡¶§‡¶ó‡ßÅ‡¶≤‡ßã recursive call ‡¶π‡¶ö‡ßç‡¶õ‡ßá
- input ‡¶ï‡¶§‡¶ü‡¶æ ‡¶ï‡¶Æ‡¶õ‡ßá
- overlapping subproblem ‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø ‡¶®‡¶æ

### ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£:

- **Factorial recursion** ‚Üí O(n)  
  (‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶¨‡¶æ‡¶∞ ‡¶è‡¶ï‡¶ü‡¶æ‡¶á recursive call)

- **Fibonacci (naive)** ‚Üí O(2‚Åø)  
  (‡¶¶‡ßÅ‡¶á‡¶ü‡¶æ call + overlapping subproblem)

- **Fibonacci (memoized)** ‚Üí O(n)  
  (overlap ‡¶∏‡¶∞‡¶ø‡¶Ø‡¶º‡ßá ‡¶¶‡¶ø‡¶≤‡ßá linear)

- **Binary Search (recursive)** ‚Üí O(log n)  
  (‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶¨‡¶æ‡¶∞ ‡¶è‡¶ï‡¶ü‡¶æ‡¶á call + input ‡¶Ö‡¶∞‡ßç‡¶ß‡ßá‡¶ï)

---

## ‚ùå ‡¶≠‡ßÅ‡¶≤ 4: "Best case ‡¶¨‡¶≤‡¶≤‡ßá‡¶á ‡¶π‡¶¨‡ßá"

Interviewer ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£‡¶§ **worst case complexity** ‡¶∂‡ßÅ‡¶®‡¶§‡ßá ‡¶ö‡¶æ‡¶Ø‡¶º‡•§

‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶Ø‡¶¶‡¶ø ‡¶¨‡¶≤‡ßã:
```

"My algorithm is O(1) in the best case"

```

‡¶ì‡¶∞‡¶æ ‡¶≠‡¶æ‡¶¨‡¶¨‡ßá ‚Äî worst case ‡¶ï‡ßÄ?

‡¶∏‡¶¨‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶™‡¶∞‡¶ø‡¶∑‡ßç‡¶ï‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶¨‡¶≤‡ßã:
- Best case
- Average case
- Worst case (‡¶∏‡¶¨‡¶ö‡ßá‡¶Ø‡¶º‡ßá ‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£)

---

üéØ Interview rule:  
**Worst case ‡¶Ü‡¶ó‡ßá ‡¶¨‡¶≤‡ßã, ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ ‡¶ö‡¶æ‡¶á‡¶≤‡ßá average ‡¶¨‡¶æ best explain ‡¶ï‡¶∞‡ßã‡•§**

# Binary Search ‡¶è‡¶¨‡¶Ç Logarithmic Complexity

Binary Search ‡¶è ‡¶Ü‡¶Æ‡¶∞‡¶æ 10 ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶®‡¶æ, 2 ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶≠‡¶æ‡¶ó ‡¶ï‡¶∞‡¶õ‡¶ø‡•§  
‡¶§‡¶æ‡¶á decimal digit ‡¶®‡¶æ, **binary digit (bit)** ‡¶ó‡ßÅ‡¶®‡¶§‡ßá ‡¶π‡¶¨‡ßá‡•§

n ‡¶è‡¶∞ binary representation ‡¶è ‡¶ï‡¶Ø‡¶º‡¶ü‡¶æ digit ‡¶Ü‡¶õ‡ßá, ‡¶§‡¶æ‡¶∞ ‡¶â‡¶™‡¶∞ depend ‡¶ï‡¶∞‡ßá 2 ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶ï‡¶§‡¶¨‡¶æ‡¶∞ ‡¶≠‡¶æ‡¶ó ‡¶¶‡ßá‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá‡•§  
‡¶è‡¶ü‡¶æ‡¶ï‡ßá ‡¶≤‡ßá‡¶ñ‡ßá:

```

log‚ÇÇ(n)

```
---

## ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£

```

log‚ÇÇ(8)    = 3   ‡¶ï‡¶æ‡¶∞‡¶£ 2¬≥  = 8
‚Üí 8 ‡¶ï‡ßá 3 ‡¶¨‡¶æ‡¶∞ ‡¶≠‡¶æ‡¶ó: 8 ‚Üí 4 ‚Üí 2 ‚Üí 1
binary: 1000 (4 bit)

log‚ÇÇ(16)   = 4   ‡¶ï‡¶æ‡¶∞‡¶£ 2‚Å¥  = 16
‚Üí 16 ‡¶ï‡ßá 4 ‡¶¨‡¶æ‡¶∞ ‡¶≠‡¶æ‡¶ó: 16 ‚Üí 8 ‚Üí 4 ‚Üí 2 ‚Üí 1
binary: 10000 (5 bit)

```id="ex2bb"
```

log‚ÇÇ(64)   = 6   ‡¶ï‡¶æ‡¶∞‡¶£ 2‚Å∂  = 64
‚Üí 64 ‡¶ï‡ßá 6 ‡¶¨‡¶æ‡¶∞ ‡¶≠‡¶æ‡¶ó ‡¶ï‡¶∞‡¶≤‡ßá 1
binary: 1000000 (7 bit)

```id="ex3cc"
```

log‚ÇÇ(1024) = 10  ‡¶ï‡¶æ‡¶∞‡¶£ 2¬π‚Å∞ = 1024
‚Üí 1024 ‡¶ï‡ßá 10 ‡¶¨‡¶æ‡¶∞ ‡¶≠‡¶æ‡¶ó ‡¶ï‡¶∞‡¶≤‡ßá 1
binary: 10000000000 (11 bit)

```id="ex4dd"

---

## ‡¶Æ‡¶ú‡¶æ‡¶∞‡¶≠‡¶æ‡¶¨‡ßá ‡¶Æ‡¶®‡ßá ‡¶∞‡¶æ‡¶ñ‡¶æ‡¶∞ ‡¶â‡¶™‡¶æ‡¶Ø‡¶º

n ‡¶è‡¶∞ binary representation ‡¶è ‡¶Ø‡¶§‡¶ó‡ßÅ‡¶≤‡ßã digit ‡¶•‡¶æ‡¶ï‡ßá,  
‡¶Æ‡ßã‡¶ü‡¶æ‡¶Æ‡ßÅ‡¶ü‡¶ø:

```

digit ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ - 1 ‚âà log‚ÇÇ(n)

```id="rule22"

‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£:

```

8   = 1000      ‚Üí 4 digit  ‚Üí log‚ÇÇ(8) ‚âà 3
16  = 10000     ‚Üí 5 digit  ‚Üí log‚ÇÇ(16) = 4
64  = 1000000   ‚Üí 7 digit  ‚Üí log‚ÇÇ(64) = 6

```id="rule33"

(‡¶õ‡ßã‡¶ü‡¶ñ‡¶æ‡¶ü‡ßã ‡¶™‡¶æ‡¶∞‡ßç‡¶•‡¶ï‡ßç‡¶Ø ‡¶•‡¶æ‡¶ï‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶ß‡¶æ‡¶∞‡¶£‡¶æ ‡¶†‡¶ø‡¶ï ‡¶•‡¶æ‡¶ï‡¶¨‡ßá)

---

# ‡¶§‡¶æ‡¶π‡¶≤‡ßá complexity ‡¶ï‡ßá‡¶® O(log n)?

Binary Search ‡¶è‡¶∞ exact complexity ‡¶π‡¶≤‡ßã:

```

O(log‚ÇÇ n)

```id="exact11"

‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ Big O ‡¶§‡ßá ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶≤‡¶ø‡¶ñ‡¶ø:

```

O(log n)

```id="exact22"

base 2 ‡¶ï‡ßá‡¶® ‡¶≤‡¶ø‡¶ñ‡¶ø ‡¶®‡¶æ?

---

## Base ‡¶ï‡ßá‡¶® matter ‡¶ï‡¶∞‡ßá ‡¶®‡¶æ?

‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶≠‡¶æ‡¶¨‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßã:

```

log‚ÇÇ(1024)  = 10
log‚ÇÅ‚ÇÄ(1024) ‚âà 3

```

‡¶¶‡ßÅ‡¶ü‡ßã ‡¶§‡ßã ‡¶Ö‡¶®‡ßá‡¶ï ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ!

‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶ó‡¶£‡¶ø‡¶§‡ßá ‡¶è‡¶ï‡¶ü‡¶æ rule ‡¶Ü‡¶õ‡ßá ‚Äî ‡¶Ø‡ßá‡¶ï‡ßã‡¶®‡ßã base ‡¶è‡¶∞ log ‡¶Ö‡¶®‡ßç‡¶Ø base ‡¶è convert ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º:

```

log‚ÇÇ(n) = log‚ÇÅ‚ÇÄ(n) / log‚ÇÅ‚ÇÄ(2)
= log‚ÇÅ‚ÇÄ(n) √ó 3.32

```id="convert11"

‡¶è‡¶á 3.32 ‡¶π‡¶≤‡ßã ‡¶è‡¶ï‡¶ü‡¶æ **constant**‡•§

n ‡¶Ø‡¶§ ‡¶¨‡¶°‡¶º‡¶á ‡¶π‡ßã‡¶ï, ‡¶è‡¶ü‡¶æ ‡¶∏‡¶¨‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶è‡¶ï‡¶á ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‡•§

---

## Big O Rule ‡¶Æ‡¶®‡ßá ‡¶ï‡¶∞‡ßã

‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶Ü‡¶ó‡ßá‡¶á ‡¶∂‡¶ø‡¶ñ‡ßá‡¶õ‡¶ø:

> Big O ‡¶§‡ßá constant factor ‡¶¨‡¶æ‡¶¶ ‡¶¶‡¶ø‡¶á

‡¶§‡¶æ‡¶á:

```

O(3.32 √ó log‚ÇÅ‚ÇÄ(n))
= O(log‚ÇÅ‚ÇÄ(n))
= O(log‚ÇÇ(n))
= O(log n)

```id="final44"

Base ‡¶Ø‡¶æ-‡¶á ‡¶π‡ßã‡¶ï, Big O ‡¶§‡ßá ‡¶∏‡¶¨ ‡¶∏‡¶Æ‡¶æ‡¶®‡•§

---

# Final Answer

Binary Search ‡¶è‡¶∞ complexity:

```

O(log n)

```

‡¶è‡¶ü‡¶æ‡¶ï‡ßá ‡¶¨‡¶≤‡ßá **Logarithmic Time Complexity**‡•§
```



<details>
  <summary><strong>What is the time complexity of the best-known algorithm for multiplying two n√ón matrices?</strong></summary>

  <p><strong>Correct Answer:</strong></p>
  <p><strong>D) O(n<sup>2.373</sup>) (approximately, using Strassen-like and more advanced algorithms)</strong></p>

  <hr>

  <h3>Explanation</h3>

  <p>
    The standard (naive) matrix multiplication algorithm uses three nested loops:
  </p>

  <pre>
for i = 1 to n
  for j = 1 to n
    for k = 1 to n
      C[i][j] += A[i][k] * B[k][j]
  </pre>

  <p>
    This gives a time complexity of:
  </p>

  <p><strong>O(n¬≥)</strong></p>

  <hr>

  <h3>Strassen‚Äôs Algorithm</h3>

  <p>
    Strassen improved matrix multiplication by reducing the number of recursive multiplications.
  </p>

  <p>
    Time complexity:
  </p>

  <p><strong>O(n<sup>2.807</sup>)</strong></p>

  <hr>

  <h3>More Advanced Algorithms</h3>

  <p>
    Further research improved the exponent even more using advanced algebraic techniques.
  </p>

  <p>
    The best-known theoretical time complexity today is approximately:
  </p>

  <p><strong>O(n<sup>2.373</sup>)</strong></p>

  <hr>

  <h3>Important Notes</h3>

  <ul>
    <li>The naive algorithm is <strong>O(n¬≥)</strong></li>
    <li>Strassen reduces it to <strong>O(n<sup>2.807</sup>)</strong></li>
    <li>Advanced research reduces it further to about <strong>O(n<sup>2.373</sup>)</strong></li>
    <li>These advanced algorithms are mostly theoretical and not commonly used in practice</li>
  </ul>

</details>


<details>
  <summary> Which of the following is TRUE about amortized time complexity? <strong>Correct Answer: B</strong> ‚Äì It averages the cost over a sequence of operations, guaranteeing the average per operation</summary>

  <p><strong>Explanation:</strong></p>

  <p>
    Amortized time complexity analyzes the cost of a <em>sequence of operations</em> 
    and spreads the total cost over all operations. It guarantees the average cost 
    per operation even in the worst-case sequence.
  </p>

  <ul>
    <li>
      It is <strong>not</strong> the same as worst-case complexity (so A is incorrect).
    </li>
    <li>
      It is <strong>not</strong> the same as average-case complexity, because average-case 
      analysis depends on probability, while amortized analysis does not (so D is incorrect).
    </li>
    <li>
      It applies to many data structures (like dynamic arrays, stacks, etc.), 
      not only sorting algorithms (so C is incorrect).
    </li>
  </ul>

  <p><strong>Example:</strong></p>
  <p>
    In a dynamic array (like <code>ArrayList</code>), resizing occasionally takes 
    <code>O(n)</code> time, but most insertions take <code>O(1)</code> time. 
    When we distribute the resizing cost over many insertions, the 
    <strong>amortized time complexity of append becomes O(1)</strong>.
  </p>

  <p>
    üëâ Therefore, the correct answer is <strong>B</strong>.
  </p>
</details>



<details>
  <summary>What is the space complexity of a recursive function that makes n recursive calls in total, with no additional data structures, where each call adds one frame to the call stack? <strong>Correct Answer: C</strong> ‚Äì O(n)</summary>

  <p><strong>Explanation:</strong></p>

  <p>
    In a recursive function, each recursive call adds one new frame to the call stack.
  </p>

  <ul>
    <li>If the function makes <strong>n recursive calls</strong> before reaching the base case,</li>
    <li>The maximum depth of the call stack becomes <strong>n</strong>.</li>
    <li>Each stack frame takes <strong>O(1)</strong> space (since no extra data structures are used).</li>
  </ul>

  <p>
    Therefore, total space used by the call stack is:
  </p>

  <p><strong>O(1) √ó n = O(n)</strong></p>

  <p>
    So, the correct answer is <strong>C</strong>.
  </p>
</details>


<details>
  <summary><strong>Question:</strong> What is the time complexity?</summary>

  <pre><code>
for (int i = 1; i <= n; i = i * 3)
{
    for (int j = 1; j <= n; j++)
    {
        sum++;
    }
}
  </code></pre>

  <p><strong>Correct Answer: B ‚Äì O(n log n)</strong></p>

  <p><strong>Explanation:</strong></p>

  <ul>
    <li>
      The outer loop multiplies <code>i</code> by 3 each time:
      1, 3, 9, 27, ...
      So it runs <strong>log‚ÇÉ(n)</strong> times.
    </li>
    <li>
      The inner loop runs <strong>n</strong> times for each outer loop iteration.
    </li>
  </ul>

  <p>
    Therefore, total operations:
  </p>

  <p><strong>n √ó log‚ÇÉ(n)</strong></p>

  <p>
    In Big-O notation, logarithm base does not matter, so:
  </p>

  <p><strong>O(n log n)</strong></p>
</details>



<details>
  <summary><strong>Question:</strong> What is the space complexity?</summary>

  <pre><code>
HashMap&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap<>();

for (int i = 0; i &lt; n; i++)
{
    List&lt;Integer&gt; list = new ArrayList<>();

    for (int j = 0; j &lt; n; j++)
    {
        list.add(j);
    }

    map.put(i, list);
}
  </code></pre>

  <p><strong>Correct Answer: B ‚Äì O(n¬≤)</strong></p>

  <p><strong>Explanation:</strong></p>

  <ul>
    <li>The <code>HashMap</code> stores <strong>n keys</strong>.</li>
    <li>For each key, a <code>List</code> of size <strong>n</strong> is created.</li>
    <li>So total stored elements = <strong>n √ó n = n¬≤</strong>.</li>
  </ul>

  <p>
    Therefore, the overall space complexity is:
  </p>

  <p><strong>O(n¬≤)</strong></p>
</details>


<details>
  <summary><strong>Question:</strong> What is the time complexity?</summary>

  <pre><code>
void solve(int n)
{
    if (n <= 1)
        return;

    for (int i = 0; i < n; i++)
    {
        print(i);
    }

    solve(n / 3);
}
  </code></pre>

  <p><strong>Correct Answer: A ‚Äì O(n)</strong></p>

  <p><strong>Explanation:</strong></p>

  <p>
    The recurrence relation is:
  </p>

  <p><strong>T(n) = T(n/3) + O(n)</strong></p>

  <p>
    Expanding:
  </p>

  <p>
    n + n/3 + n/9 + n/27 + ...
  </p>

  <p>
    This is a geometric series.
  </p>

  <p>
    Sum ‚âà n √ó (1 + 1/3 + 1/9 + ...)  
    = n √ó (3/2)  
    = O(n)
  </p>

  <p>
    The first level dominates the total work, so the overall time complexity is:
  </p>

  <p><strong>O(n)</strong></p>
</details>



<details>
  <summary><strong>Question:</strong> What is the time complexity?</summary>

  <pre><code>
int power(int base, int exp)
{
    if (exp == 0)
        return 1;

    if (exp % 2 == 0)
        return power(base * base, exp / 2);
    else
        return base * power(base, exp - 1);
}
  </code></pre>

  <p><strong>Correct Answer: B ‚Äì O(log n) where n = exp</strong></p>

  <p><strong>Explanation:</strong></p>

  <ul>
    <li>If <code>exp</code> is even ‚Üí it is divided by 2.</li>
    <li>If <code>exp</code> is odd ‚Üí it is reduced by 1 (making it even), then divided by 2 in the next step.</li>
  </ul>

  <p>
    So in the worst case, each pair of operations reduces <code>exp</code> roughly by half.
  </p>

  <p>
    Maximum number of recursive calls ‚âà <strong>2 √ó log‚ÇÇ(exp)</strong>
  </p>

  <p>
    Ignoring constants in Big-O notation:
  </p>

  <p><strong>O(log n)</strong></p>

  <p>
    This method is known as <em>Exponentiation by Squaring</em>.
  </p>
</details>



<details>
  <summary><strong>Question:</strong> What is the time complexity?</summary>

  <pre><code>
for (int i = 0; i < n; i++)
{
    int x = i;

    while (x > 0)
    {
        x /= 10;
    }
}
  </code></pre>

  <p><strong>Correct Answer: B ‚Äì O(n log n)</strong></p>

  <p><strong>Explanation:</strong></p>

  <ul>
    <li>The outer loop runs <strong>n</strong> times.</li>
    <li>For each <code>i</code>, the <code>while</code> loop counts the number of digits in <code>i</code>.</li>
    <li>The number of digits in <code>i</code> is <strong>log‚ÇÅ‚ÇÄ(i)</strong>.</li>
  </ul>

  <p>
    So total work is approximately:
  </p>

  <p><strong>n √ó log‚ÇÅ‚ÇÄ(n)</strong></p>

  <p>
    In Big-O notation, logarithm base does not matter.
  </p>

  <p><strong>O(n log n)</strong></p>
</details>
<details>
  <summary><strong>Question:</strong> What is the time complexity?</summary>

  <pre><code>
void permute(int arr[], int l, int r)
{
    if (l == r)
    {
        print(arr);
        return;
    }

    for (int i = l; i <= r; i++)
    {
        swap(arr[l], arr[i]);
        permute(arr, l + 1, r);
        swap(arr[l], arr[i]);
    }
}
  </code></pre>

  <p><strong>Correct Answer: C ‚Äì O(n!)</strong></p>

  <p><strong>Explanation:</strong></p>

  <ul>
    <li>At the first level, there are <strong>n</strong> choices.</li>
    <li>At the second level, there are <strong>n ‚àí 1</strong> choices.</li>
    <li>Then <strong>n ‚àí 2</strong>, and so on...</li>
  </ul>

  <p>
    Total number of recursive calls:
  </p>

  <p><strong>n √ó (n ‚àí 1) √ó (n ‚àí 2) √ó ... √ó 1 = n!</strong></p>

  <p>
    Since all permutations are generated, the time complexity is:
  </p>

  <p><strong>O(n!)</strong></p>
</details>
<details>
  <summary><strong>Question:</strong> What is the space complexity?</summary>

  <pre><code>
void merge_sort(int arr[], int l, int r)
{
    if (l >= r)
        return;

    int mid = (l + r) / 2;

    merge_sort(arr, l, mid);
    merge_sort(arr, mid + 1, r);

    merge(arr, l, mid, r); 
    // uses O(n) temp array
}
  </code></pre>

  <p><strong>Correct Answer: C ‚Äì O(n)</strong></p>

  <p><strong>Explanation:</strong></p>

  <ul>
    <li>The recursion depth is <strong>O(log n)</strong>.</li>
    <li>The <code>merge()</code> function uses a temporary array of size <strong>O(n)</strong>.</li>
  </ul>

  <p>
    Even though recursion uses <strong>O(log n)</strong> stack space,  
    the temporary array of size <strong>O(n)</strong> dominates.
  </p>

  <p>
    Therefore, total space complexity:
  </p>

  <p><strong>O(n)</strong></p>
</details>


<details>
  <summary><strong>Question:</strong> What is the time complexity?</summary>

  <pre><code>
for (int i = 1; i <= n; i++)
{
    for (int j = 1; j <= n; j = j + i)
    {
        for (int k = 1; k <= n; k = k * 2)
        {
            sum++;
        }
    }
}
  </code></pre>

  <p><strong>Correct Answer: A ‚Äì O(n log¬≤ n)</strong></p>

  <p><strong>Explanation:</strong></p>

  <ul>
    <li>
      <strong>k-loop:</strong>  
      <code>k</code> doubles each time ‚Üí runs <strong>O(log n)</strong>.
    </li>

    <li>
      <strong>j-loop:</strong>  
      <code>j</code> increases by <code>i</code>, so it runs about <strong>n / i</strong> times.
    </li>

    <li>
      Total work over <code>i</code>:
      <br>
      Œ£ (n / i) from i = 1 to n = <strong>O(n log n)</strong>.
    </li>
  </ul>

  <p>
    Now multiply by the <strong>k-loop</strong>:
  </p>

  <p>
    <strong>O(n log n) √ó O(log n) = O(n log¬≤ n)</strong>
  </p>

</details>

<details>
  <summary><strong>Question:</strong> What is the time complexity?</summary>

  <pre><code>
void f(int n, int depth)
{
    if (depth == 0)
        return;

    for (int i = 0; i < n; i++)
    {
        print(i);
    }

    f(n, depth - 1);
    f(n, depth - 1);
}

// Called as: f(n, log2(n))
  </code></pre>

  <p><strong>Correct Answer: A ‚Äì O(n¬≤)</strong></p>

  <p><strong>Explanation:</strong></p>

  <ul>
    <li>Each call does <strong>n operations</strong> in the for-loop.</li>
    <li>Each call recursively calls itself <strong>2 times</strong> with depth ‚àí 1.</li>
    <li>Recursion depth = log‚ÇÇ(n).</li>
  </ul>

  <p>
    Total number of recursive calls at depth <code>d</code> = 2^d.  
    At the deepest level, d = log‚ÇÇ(n) ‚Üí 2^(log‚ÇÇ(n)) = n calls.
  </p>

  <p>
    Each call does O(n) work ‚Üí total work = n √ó n = <strong>O(n¬≤)</strong>.
  </p>

</details>


<details>
  <summary><strong>Question:</strong> What is the time complexity?</summary>

  <pre><code>
for (int i = 1; i <= n; i++)
{
    for (int j = i; j <= n; j += i)
    {
        for (int k = j; k <= n; k += j)
        {
            ans++;
        }
    }
}
  </code></pre>

  <p><strong>Correct Answer: B ‚Äì O(n log¬≤ n)</strong></p>

  <p><strong>Explanation:</strong></p>

  <ul>
    <li>Outer loop: <code>i</code> runs from 1 to n ‚Üí O(n)</li>
    <li>Middle loop: <code>j</code> runs from i to n in steps of i ‚Üí roughly O(n/i)</li>
    <li>Inner loop: <code>k</code> runs from j to n in steps of j ‚Üí roughly O(n/j)</li>
  </ul>

  <p>
    Total iterations ‚âà Œ£<sub>i=1 to n</sub> Œ£<sub>j=i, step i to n</sub> n/j  
    ‚âà n √ó Œ£<sub>i=1 to n</sub> (1/i) √ó log n  
    ‚âà n √ó (log n) √ó (log n) = O(n log¬≤ n)
  </p>

  <p>
    This is called a <strong>double-harmonic series</strong> pattern.
  </p>
</details>


<details>
  <summary><strong>Question:</strong> What is the time complexity?</summary>

  <pre><code>
for (int i = 0; i < n; i++)
{
    for (int j = 0; j < n; j++)
    {
        int x = n;

        while (x > 1)
        {
            x = x / 3;
        }

        sum++;
    }
}
  </code></pre>

  <p><strong>Correct Answer: A ‚Äì O(n¬≤ log n)</strong></p>

  <p><strong>Explanation:</strong></p>

  <ul>
    <li>The outer loop runs <strong>n</strong> times.</li>
    <li>The inner loop also runs <strong>n</strong> times.</li>
    <li>The <code>while</code> loop divides <code>x</code> by 3 each time ‚Üí runs <strong>log‚ÇÉ(n)</strong> times.</li>
  </ul>

  <p>
    Total operations:
  </p>

  <p><strong>n √ó n √ó log‚ÇÉ(n) = O(n¬≤ log n)</strong></p>

  <p>
    Note: The base of the logarithm does not affect Big-O notation.
  </p>
</details>


<details>
  <summary><strong>Question:</strong> What is the space complexity?</summary>

  <pre><code>
String[] dp = new String[n + 1];
dp[0] = "";

for (int i = 1; i <= n; i++)
{
    dp[i] = dp[i - 1] + "a";
}
  </code></pre>

  <p><strong>Correct Answer: B ‚Äì O(n¬≤)</strong></p>

  <p><strong>Explanation:</strong></p>

  <ul>
    <li>Each <code>dp[i]</code> stores a string of length <strong>i</strong>.</li>
    <li>Total characters stored:</li>
    <p>0 + 1 + 2 + ... + n = n(n + 1)/2 ‚âà O(n¬≤)</p>
    <li>String concatenation in most languages creates a new string each time, so extra space is used for each concatenation.</li>
  </ul>

  <p>
    Therefore, the overall space complexity is:
  </p>

  <p><strong>O(n¬≤)</strong></p>
</details>


<details>
  <summary><strong>Question:</strong> What is the time complexity?</summary>

  <pre><code>
for (int i = 1; i <= n; i++)
{
    for (int j = 1; j <= n; j++)
    {
        int a = i, b = j;

        while (b != 0)
        {
            int t = b;
            b = a % b;
            a = t;
        }

        sum += a;
    }
}
  </code></pre>

  <p><strong>Correct Answer: A ‚Äì O(n¬≤ log n)</strong></p>

  <p><strong>Explanation:</strong></p>

  <ul>
    <li>The outer loop runs <strong>n</strong> times.</li>
    <li>The inner loop also runs <strong>n</strong> times.</li>
    <li>The <code>while</code> loop computes <strong>GCD(i, j)</strong> using Euclid's algorithm ‚Üí O(log(min(i,j))) ‚âà O(log n).</li>
  </ul>

  <p>
    Total time complexity:
  </p>

  <p><strong>n √ó n √ó log n = O(n¬≤ log n)</strong></p>
</details>


## Function Call Stack
‡¶è‡¶ü‡¶æ ‡¶Ö‡¶®‡ßá‡¶ï‡ßá ‡¶≠‡ßÅ‡¶≤‡ßá ‡¶Ø‡¶æ‡¶Ø‡¶º! Recursion ‡¶ö‡¶≤‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º memory ‡¶§‡ßá extra ‡¶ú‡¶æ‡¶Ø‡¶º‡¶ó‡¶æ ‡¶≤‡¶æ‡¶ó‡ßá‡•§ ‡¶è‡¶ü‡¶æ ‡¶®‡¶ø‡¶Ø‡¶º‡ßá ‡¶™‡¶∞‡ßá ‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶¨‡¶≤‡¶¨‡ßã ‚Äî ‡¶Ü‡¶™‡¶æ‡¶§‡¶§ ‡¶Æ‡¶®‡ßá ‡¶∞‡¶æ‡¶ñ‡ßã variable ‡¶Ü‡¶∞ array ‡¶õ‡¶æ‡¶°‡¶º‡¶æ‡¶ì ‡¶Ü‡¶∞‡ßá‡¶ï ‡¶ú‡¶æ‡¶Ø‡¶º‡¶ó‡¶æ‡¶Ø‡¶º memory ‡¶ñ‡¶∞‡¶ö ‡¶π‡¶Ø‡¶º‡•§
 -->
