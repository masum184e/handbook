A crate is the smallest unit of compilation in Rust.

In simple terms:

- A crate = one compiled output
- It can produce:
  - an executable â†’ binary crate
  - a reusable package â†’ library crate

Modules organize code inside a crate  
Crates organize code at the compilation level

## Types of Crates

Rust has two main crate types:

| Crate Type    | Output             | Entry File |
| ------------- | ------------------ | ---------- |
| Binary crate  | Executable program | `main.rs`  |
| Library crate | Reusable code      | `lib.rs`   |

## Binary Crate (Executable)

A binary crate:

- produces a runnable executable
- must have a `main()` function
- starts execution from `main()`

### Example: Simple Binary Crate

```
my_app/
 â”œâ”€â”€ Cargo.toml
 â””â”€â”€ src/
      â””â”€â”€ main.rs
```

`main.rs`

```rust
fn main() {
    println!("Hello from binary crate!");
}
```

- `main.rs` is the crate root
- `main()` is the program entry point
- `cargo` run builds and executes this crate

## Binary Crate with Modules

```
src/
 â”œâ”€â”€ main.rs
 â””â”€â”€ utils.rs
```

`main.rs`

```rust
mod utils;

fn main() {
    utils::say_hi();
}
```

`utils.rs`

```rust
pub fn say_hi() {
    println!("Hi from utils module");
}
```

- `main.rs` is still the crate root
- `utils` is a module inside the crate
- `pub` allows access from `main`

## Multiple Binary Crates in One Project

Rust allows multiple binaries in one package.

Structure

```
src/
 â”œâ”€â”€ main.rs        // default binary
 â””â”€â”€ bin/
      â”œâ”€â”€ server.rs
      â””â”€â”€ client.rs
```

Running binaries

```
cargo run           # runs main.rs
cargo run --bin server
cargo run --bin client
```

- Each file in `src/bin/` is a separate binary crate
- All share the same `Cargo.toml`
- Useful for CLI tools, microservices, or test apps

## Library Crate (Reusable Code)

A library crate:

- does NOT have `main()`
- exposes reusable functionality
- is imported by other crates using `use`

### Example: Simple Library Crate

```
my_lib/
 â”œâ”€â”€ Cargo.toml
 â””â”€â”€ src/
      â””â”€â”€ lib.rs
```

`lib.rs`

```rust
pub fn greet() {
    println!("Hello from library crate");
}
```

- `lib.rs` is the crate root
- `pub` exposes the function to other crates
- Built with `cargo build`

## Using a Library Crate in a Binary Crate

Workspace-like usage (same project)

```
src/
 â”œâ”€â”€ main.rs
 â””â”€â”€ lib.rs
```

`lib.rs`

```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

`main.rs`

```rust
use my_project::add;

fn main() {
    println!("{}", add(2, 3));
}
```

- `my_project` = crate name from `Cargo.toml`
- Binary crate automatically depends on the library crate
- Common Rust pattern ğŸ‘

## Library Crate with Modules

```
src/
 â”œâ”€â”€ lib.rs
 â”œâ”€â”€ math/
 â”‚    â”œâ”€â”€ mod.rs
 â”‚    â””â”€â”€ add.rs
 â””â”€â”€ utils.rs
```

`lib.rs`

```rust
pub mod math;
pub mod utils;
```

`math/mod.rs`

```rust
pub mod add;
```

`math/add.rs`

```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

Usage in another crate

```rust
use my_lib::math::add::add;
```

## Binary + Library Together (Very Common)

This is idiomatic Rust.

Structure

```
src/
 â”œâ”€â”€ main.rs   // binary crate
 â””â”€â”€ lib.rs    // library crate
```

Why do this?

- Put logic in `lib.rs`
- Keep `main.rs` thin
- Improves testability and reuse

`lib.rs`

```rust
pub mod auth {
    pub fn login() {
        println!("User logged in");
    }
}
```

`main.rs`

```rust
use my_app::auth::login;

fn main() {
    login();
}
```

## Crate Root Explained

| Crate Type | Crate Root |
| ---------- | ---------- |
| Binary     | `main.rs`  |
| Library    | `lib.rs`   |

The crate root:

- defines the module tree
- controls what is public
- is where `crate::` paths start

## `crate::` vs External Crates

Inside the same crate

```rust
crate::math::add::add();
```

External crate

```rust
use serde::Serialize;
```

Rust clearly separates:

- internal modules â†’ `crate::`
- external crates â†’ crate name

## `Cargo.toml` and Crates

```toml
[package]
name = "my_app"
version = "0.1.0"
edition = "2021"
```

- `name` = crate name used in `use`
- Dependencies listed under `[dependencies]`
- Cargo builds each crate independently

## How Modules & Crates Fit Together

Think of it like this:

```
Workspace (optional)
 â””â”€â”€ Package (Cargo.toml)
      â”œâ”€â”€ Crate (binary or library)
      â”‚    â””â”€â”€ Modules
      â”‚         â””â”€â”€ Functions / structs
```

## Key Differences: Crate vs Module

| Feature             | Crate | Module |
| ------------------- | ----- | ------ |
| Compiled separately | âœ…    | âŒ     |
| Has crate root      | âœ…    | âŒ     |
| Controls visibility | âœ…    | âœ…     |
| Can be published    | âœ…    | âŒ     |
| File-based          | Yes   | Yes    |

## When to Use What

- Modules â†’ organize logic inside a crate
- Library crate â†’ reusable core logic
- Binary crate â†’ executable behavior

Rust strongly encourages:

> â€œWrite libraries, then write small binaries that use them.â€
