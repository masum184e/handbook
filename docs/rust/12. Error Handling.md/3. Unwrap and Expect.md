Extract the value from `Option<T>` or `Result<T, E>`.

- Panic if the value is not present (`None` or `Err`).
- Are meant for situations where failure is truly unexpected or impossible.

## `unwrap()`

- Returns the inner value if it exists.
- Panics with a generic error message if it doesn’t.

```rust
fn main() {
    let x = Some(5);
    let value = x.unwrap();
    println!("Value: {}", value);
}
```

If it fails:

```rust
let x: Option<i32> = None;
let value = x.unwrap(); // panic!
```

Panic message (simplified):

```rust
thread 'main' panicked at 'called `Option::unwrap()` on a `None` value'
```

Example with `Result`

```rust
fn main() {
    let result: Result<i32, &str> = Ok(10);
    let value = result.unwrap();
    println!("Value: {}", value);
}
```

If `Err`:

```rust
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value'
```

## `expect()`

- Same as `unwrap()`, but lets you provide a custom panic message.
- This makes debugging much easier.

Example with `Option`

```rust
fn main() {
    let x: Option<i32> = None;
    let value = x.expect("Expected a number, but got None");
}
```

Panic message:

```rust
thread 'main' panicked at 'Expected a number, but got None'
```

Example with `Result`

```rust
use std::fs::File;

fn main() {
    let file = File::open("config.txt")
        .expect("Failed to open config file");
}
```

If the file doesn’t exist:

```rust
thread 'main' panicked at 'Failed to open config file: ...'
```

## Key Differences

| Feature       | `unwrap()`              | `expect(msg)`                             |
| ------------- | ----------------------- | ----------------------------------------- |
| Panic message | Generic and fixed       | Custom, developer-defined                 |
| Debugging     | Less helpful            | More informative                          |
| Use case      | Quick tests, prototypes | Production code where panic is acceptable |
| Behavior      | Panic on failure        | Panic on failure                          |

## When should you use them?

Use `unwrap()` or `expect()` when:

- You are 100% sure the value exists.
- A failure indicates a bug, not a normal runtime error.
- Writing tests, examples, or quick scripts.

Avoid them when:

- Failure is possible due to user input, files, networks, etc.
- You want your program to recover gracefully.

### Example: unwrap vs expect in practice

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    // Using unwrap (bad message if missing)
    let filename1 = args.get(1).unwrap();

    // Using expect (good message)
    let filename2 = args.get(2).expect("Please provide a second filename");
}
```

If the user forgets to pass arguments:

- `unwrap()` → generic panic message.
- `expect()` → helpful, user-friendly message.

## Best Practice

- Prefer `expect()` over `unwrap()` when you must panic.
- Prefer returning `Result` over panicking whenever possible.
- Reserve `unwrap()` for:
  - Tests
  - Examples
  - One-off tools
  - Places where failure is truly impossible.
