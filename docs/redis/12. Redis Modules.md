

Redis Modules extend Redis beyond its core capabilities, allowing you to add new data types, commands, indexing engines, machine-learning components, and more—without modifying Redis itself.

Modules were introduced in Redis 4.0 to make Redis adaptable for specialized workloads such as search, graph processing, timeseries, and probabilistic data structures.

**Why Redis Modules?**

By default, Redis is fast and powerful but intentionally minimalistic:

- Only a limited set of data structures (strings, hashes, lists, sets…)
- No full-text search
- No built-in graph traversal
- No native time-series engine
- Limited analytics and query features

Redis Modules solve this by allowing plug-in extensions.

| Module              | Purpose                                      |
| ------------------- | -------------------------------------------- |
| **RediSearch**      | Full-text search & secondary indexing        |
| **RedisJSON**       | Store & query JSON documents                 |
| **RedisGraph**      | Graph database using Cypher                  |
| **RedisBloom**      | Bloom, Cuckoo, Count-Min filters             |
| **RedisTimeSeries** | Time-series ingestion, queries, downsampling |
| **RedisAI**         | Serving machine-learning models              |

## Advanced Redis Features

### 1. New Data Types

Modules can introduce entirely new structures:

- Bloom filters (RedisBloom)
- Time-series buckets (RedisTimeSeries)
- JSON documents (RedisJSON)
- Graph nodes/edges (RedisGraph)

### 2. New Commands

Modules add command namespaces:

- `FT.*` for RediSearch
- `JSON.*` for RedisJSON
- `TS.*` for RedisTimeSeries
- `GRAPH.*` for RedisGraph

### 3. Optimized Workloads

Modules can execute heavy computations inside Redis:

- Searching
- Aggregations
- ML inference (RedisAI)

### 4. Plug-and-Play

Modules can be loaded dynamically without altering Redis core.

## RedisJSON – Storing and Querying JSON

RedisJSON lets you store structured JSON documents with a JSON-native API.

```json
JSON.SET user:1 $ '{"name":"Alice","age":25,"skills":["redis","python"]}'
```

- `JSON.SET` → command from RedisJSON module
- `user:1` → key
- `$` → root path of JSON document
- JSON content stored in Redis in a tree structure

**Example: Retrieving a JSON field**

```
JSON.GET user:1 $.name
```

Output:

```
["Alice"]
```

- `$` refers to the root path
- `$.name` extracts only the “name” field

## RediSearch – Full-Text Search & Secondary Indexing

RediSearch enables fast indexing, search, filtering, and aggregations.

Create an Index:

```sh
FT.CREATE idx:users ON HASH PREFIX 1 user: SCHEMA name TEXT age NUMERIC
```

- Creates an index named `idx:users`
- Works on keys beginning with `user:`
- Indexes two fields:
  - `name (text)`
  - `age (numeric)`

**Example: Inserting User Data**

```sh
HSET user:1 name "Alice" age 25
HSET user:2 name "Bob" age 30
```

**Example: Search query**

```sh
FT.SEARCH idx:users "Alice"
```

Output:

```
1) 1) "user:1"
   2) "name"
   3) "Alice"
   4) "age"
   5) "25"
```

**Example: Filter query (Age between 20 and 28)**

```sh
FT.SEARCH idx:users "@age:[20 28]"
```

## RedisBloom – Probabilistic Filters

RedisBloom adds advanced filters for large-scale analytics.

**Example: Create a Bloom filter**

```sh
BF.RESERVE myFilter 0.01 1000
```

- false positive rate: 1%
- expected entries: 1,000

**Add an item**

```sh
BF.ADD myFilter "alice"
```

**Check existence**

```sh
BF.EXISTS myFilter "alice"
```

Output:

```sh
1 (means: probably present)
```

## RedisTimeSeries – Time Series Data Engine

**Example: Create a time-series key**

```sh
TS.CREATE temperature:room1 RETENTION 600000
```

- Time-series for "room1"
- Retains data for 600,000 ms (10 minutes)

**Add data points**

```sh
TS.ADD temperature:room1 1670000000 22.5
TS.ADD temperature:room1 1670000060 23.0
```

**Query with range**

```sh
TS.RANGE temperature:room1 1670000000 1670001000
```

Returns the list of data points in that time range.

## RedisGraph – Graph Database

RedisGraph enables graph modeling and Cypher queries.

**Example: Create nodes**

```sh
GRAPH.QUERY social "CREATE (:Person {name:'Alice'}), (:Person {name:'Bob'})"
```

**Example: Create relationship**

```sh
GRAPH.QUERY social "
MATCH (a:Person {name:'Alice'}), (b:Person {name:'Bob'})
CREATE (a)-[:FRIEND]->(b)
"
```

**Query relationships**

```sh
GRAPH.QUERY social "
MATCH (a)-[:FRIEND]->(b)
RETURN a.name, b.name
"
```
