

Replication in system design refers to the process of copying data or services across multiple machines (called replicas) to improve availability, fault tolerance, read scalability, and sometimes performance.

**Why Replication?**

- **High Availability:** If one server goes down, others can take over.
- **Fault Tolerance:** Protects against data loss due to hardware/software failure.
- **Scalability:** Allows horizontal scaling of read operations.
- **Low Latency:** Serve data from geographically closer replicas.

**How It Works**

- Client writes to the primary/master node.
- Primary node applies the change and sends it to the replicas.
- Replicas acknowledge the write or update once the data is received.
- Client reads from any replica.

**When to Use Replication?**

- You need high availability.
- You want to scale read operations.
- You require geo-redundancy.
- You want disaster recovery and backup redundancy.

**Notes**

- Always pair replication with consistency strategies like eventual consistency, quorum reads/writes, or consensus protocols (e.g., Paxos, Raft).
- Be aware of replication lag and how it might affect user experience.

## Types of Replication

| Type             | Description                                                               | Example Use Case                        |
| ---------------- | ------------------------------------------------------------------------- | --------------------------------------- |
| **Master-Slave** | One master (primary) node handles writes; slaves (replicas) handle reads. | Databases with high read-to-write ratio |
| **Multi-Master** | Multiple nodes can handle both reads and writes.                          | Distributed databases like Cassandra    |
| **Peer-to-Peer** | All nodes are equal; data is replicated among all.                        | P2P file systems like BitTorrent        |
| **Log Shipping** | Changes are sent via logs to replicas.                                    | PostgreSQL streaming replication        |

## Replication Strategies

| Strategy             | Description                                         |
| -------------------- | --------------------------------------------------- |
| **Synchronous**      | Master waits for acknowledgment from replicas.      |
| **Asynchronous**     | Master does not wait; replicas update later.        |
| **Semi-synchronous** | Waits for acknowledgment from at least one replica. |

## Example of Replication

### System: MySQL Master-Slave Replication

1. **Master Node**
   - Handles all write operations.
   - Maintains a binary log of changes.
2. **Slave Nodes**
   - Connect to the master and replicate data from the binary log.
   - Used primarily for read operations (queries, reports).

### Example Scenario

- User A writes a new blog post.
  - This write hits the Master MySQL node.
  - The post is stored and logged.
  - The Slaves read the binary log and update their copies.
- User B visits the blog.
  - Their read request is routed to a Slave.
  - They see the newly posted blog (with some delay if async).

### Diagram

```
             +--------+
             | Client |
             +--------+
                  |
        +---------+---------+
        |                   |
   +---------+         +---------+
   | Master  |  ---->   |  Slave  |
   | DB Node |   Log    | DB Node |
   +---------+  Replay  +---------+
                        (Read-Only)
```

## Data Replication vs Component Replication

| Feature                  | Data Replication                       | Component Replication                       |
| ------------------------ | -------------------------------------- | ------------------------------------------- |
| **Scope**                | Data layer (DB, file system)           | Application layer (services, APIs)          |
| **Purpose**              | Ensure data availability & consistency | Ensure service availability & scalability   |
| **Typical Technologies** | MongoDB, PostgreSQL, Cassandra, Redis  | Docker, Kubernetes, NGINX, ECS, EC2         |
| **Example**              | Read from multiple DB replicas         | Load balance between 5 backend API replicas |
| **Failure Handling**     | Another replica serves data            | Another service instance handles traffic    |
