---
sidebar_position: 12
---

Queue is a data structure or service that temporarily holds tasks, messages, or requests in a First-In-First-Out (FIFO) manner until they can be processed. It acts as a buffer between components that produce and consume data at different speeds.

## Why Use a Queue

1. **Decoupling**

   - Producers (e.g., web servers) and consumers (e.g., workers) operate independently.
   - A failure or slowdown in one does not directly impact the other.

2. **Scalability**

   - Multiple consumers can be added to process messages in parallel.

3. **Load Buffering**

   - Sudden spikes in traffic can be absorbed by the queue instead of overwhelming the system.

4. **Reliability and Persistence**

   - Messages can be persisted until processed, ensuring tasks aren’t lost on failure.

5. **Asynchronous Processing**
   - Time-consuming tasks (e.g., video rendering, email sending) can be deferred without blocking user requests.

## Types of Queue

| Queue Type         | Description                                 | Example Use Case                |
| ------------------ | ------------------------------------------- | ------------------------------- |
| **Message Queue**  | Carries messages between services.          | RabbitMQ, ActiveMQ, Amazon SQS  |
| **Task Queue**     | Holds jobs/tasks for background workers.    | Celery (Python), Sidekiq (Ruby) |
| **Priority Queue** | Tasks with higher priority go first.        | Support ticketing system        |
| **Delay Queue**    | Messages are held for a period before sent. | Scheduled notifications         |

## Where does a queue build up

| Layer / Component                                     | Where the Queue Builds            | Reason                                    |
| ----------------------------------------------------- | --------------------------------- | ----------------------------------------- |
| **Web Server / Load Balancer**                        | Incoming request queue            | Too many simultaneous user requests       |
| **Message Queue System** (e.g., Kafka, RabbitMQ, SQS) | Task queue                        | Worker is slow or unavailable             |
| **Database**                                          | Connection pool queue             | Too many concurrent queries, slow queries |
| **Thread Pools**                                      | Thread/task execution queue       | CPU-bound or I/O-bound bottlenecks        |
| **Disk / File I/O**                                   | File write buffer queue           | Slow disks, too many write ops            |
| **API Gateway**                                       | Request queue for backend service | Backend throttled or overloaded           |
| **Cache Layer (e.g., Redis)**                         | Command execution queue           | Too many cache ops / eviction pressure    |

## Example of Queue

A user uploads an image, and the system must resize it into multiple resolutions (thumbnail, medium, high-res).

### Without a Queue (Synchronous):

- Upload → Resize → Save → Respond
- Slow, blocks user request

### With a Queue (Asynchronous):

1. User uploads image
2. API Server stores image metadata and sends a task to the queue:

```json
{
  "image_id": "123",
  "resize_sizes": ["100x100", "300x300"]
}
```

3. Queue holds the task
4. Worker picks up the task, resizes the image, and saves the results
5. User gets a fast response, and image processing happens in the background

Queue = buffer between upload and processing

## Common Queue Tools

| Tool           | Description                             |
| -------------- | --------------------------------------- |
| **RabbitMQ**   | Open-source message broker              |
| **Kafka**      | Distributed streaming platform          |
| **Amazon SQS** | Fully managed message queue service     |
| **Redis**      | Can be used for simple in-memory queues |
| **Celery**     | Distributed task queue in Python        |

## Strategy to Prevent Queue

| Strategy                     | Prevents                       | Example Tool/Tech      |
| ---------------------------- | ------------------------------ | ---------------------- |
| Auto-scale consumers         | Slow processing                | AWS Lambda, Kubernetes |
| Rate limiting                | Burst producer load            | API Gateway, NGINX     |
| Queue monitoring             | Silent queue growth            | Prometheus, CloudWatch |
| Backpressure                 | System overload                | Node.js, Kafka         |
| DLQ                          | Retry storm, poisoned messages | SQS DLQ, RabbitMQ      |
| Timeouts + exponential retry | Worker hang, retry floods      | Celery, Sidekiq        |
| Priority or multiple queues  | Starvation of urgent tasks     | RabbitMQ, Redis, Kafka |
