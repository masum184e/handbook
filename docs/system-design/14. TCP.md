---
sidebar_position: 15
---

TCP (Transmission Control Protocol) is a reliable, connection-oriented protocol in the transport layer of the OSI model (Layer 4) and Internet Protocol Suite (TCP/IP stack). It enables reliable communication between two endpoints (e.g., client and server) over an unreliable network like the Internet.

## Features of TCP

| Feature                 | Description                                                                                                       |
| ----------------------- | ----------------------------------------------------------------------------------------------------------------- |
| **Connection-oriented** | TCP establishes a connection using a 3-way handshake (SYN → SYN-ACK → ACK) before sending data.                   |
| **Reliable delivery**   | Guarantees all packets are delivered in order and without corruption (using acknowledgments and retransmissions). |
| **Error checking**      | Uses checksums to detect errors in data transmission.                                                             |
| **Flow control**        | Uses **sliding window protocol** to prevent overwhelming the receiver.                                            |
| **Congestion control**  | Avoids network congestion via algorithms like **TCP Tahoe, Reno, Cubic**, etc.                                    |
| **Stream-oriented**     | Treats data as a continuous stream (not message-based like UDP).                                                  |

## How TCP Works

1. Client sends a request to server (e.g., HTTP over TCP).
2. TCP handshake ensures both sides are ready to communicate.
3. Data is split into segments, numbered, and sent.
4. Receiver acknowledges each received packet.
5. Missing packets are retransmitted.
6. Connection is gracefully closed using FIN-ACK sequence.

## Example Architecture Using TCP

**Scenario:**

You’re designing a basic web system:

- Frontend (React/Browser)
- Backend API (Node.js)
- Database (PostgreSQL)

All these components use TCP under the hood.

System Design Diagram (simplified):

```
[Client Browser]
     |
     |  HTTP over TCP
     v
[Node.js Backend]
     |
     |  TCP (pg driver)
     v
[PostgreSQL DB]
```

**Explanation:**

1. Client ↔ Backend (HTTP over TCP):

   - The browser opens a TCP connection to the server (e.g., port 443 for HTTPS).
   - TCP ensures the request and response are delivered reliably.

2. Backend ↔ Database (TCP Socket):

   - The backend uses a TCP connection to communicate with the database.
   - The Node.js pg driver uses TCP to send SQL queries and receive results.

3. Reliability is critical. If any packets are dropped (common on WiFi or mobile), TCP retransmits them without your app needing to handle it manually.

## Example of TCP with Node.js

TCP Server (Node.js)

```js
const net = require("net");

const server = net.createServer((socket) => {
  console.log("Client connected");

  socket.on("data", (data) => {
    console.log(`Received: ${data}`);
    socket.write("Hello from server!");
  });

  socket.on("end", () => {
    console.log("Client disconnected");
  });
});

server.listen(3000, () => {
  console.log("TCP server listening on port 3000");
});
```

TCP Client (Node.js)

```js
const net = require("net");

const client = net.createConnection({ port: 3000 }, () => {
  console.log("Connected to server");
  client.write("Hello from client!");
});

client.on("data", (data) => {
  console.log(`Server says: ${data}`);
  client.end();
});

client.on("end", () => {
  console.log("Disconnected from server");
});
```

## When to Use TCP in System Design

- Web apps (HTTP, HTTPS)
- Database connections
- Microservice communication via HTTP/gRPC
- File transfer protocols (FTP, SFTP)

## Advantages & Disadvantages of TCP

| Advantage                                | Disadvantage                                              |
| ---------------------------------------- | --------------------------------------------------------- |
| Reliable & ordered delivery              | Slower than UDP due to overhead                           |
| Built-in congestion & flow control       | More complex than connectionless protocols                |
| Suited for critical apps (e.g., web, DB) | Not ideal for low-latency needs (e.g., gaming, streaming) |
