

It is a software design pattern where the system is divided into two main layers:

1. Client Tier (Presentation Layer)
2. Server Tier (Data Layer)

### Layers of 2-Tier Architecture

1. **Client Tier (Presentation Layer)**

- This is the front-end interface that users interact with.
- Responsible for:
  - Displaying data to the user
  - Taking user inputs
  - Sending requests to the server

2. **Server Tier (Data Layer)**

- This is the back-end server that processes requests and interacts with the database.
- Responsible for:
  - Handling business logic (optional in simple 2-tier)
  - Querying/updating the database
  - Sending results back to the client

### Communication Flow of 2-Tier Architecture

```
[ Client Application ] ⇄ [ Server with Database ]
```

- The client directly communicates with the database server using protocols like SQL or APIs.
- No middle-layer (like an application server or API gateway) exists between the client and server.

### Characteristics of 2-Tier Architecture

| Feature        | Description                             |
| -------------- | --------------------------------------- |
| Simplicity     | Easy to develop and deploy              |
| Tight coupling | Client is tightly coupled with server   |
| Performance    | Good for small systems with fewer users |
| Scalability    | Poor — not suitable for large systems   |
| Security       | Less secure as DB is exposed to clients |

### Example of 2-Tier Architecture

**Scenario:** A small desktop-based library management system used by staff.

**Client Application (Tier 1)**

- A desktop GUI built using Java Swing or .NET
- Users can:
  - Add new books
  - Issue/return books
  - Search for books

**Server with Database (Tier 2)**

- MySQL or PostgreSQL running on a local server
- The client connects directly using JDBC (Java Database Connectivity)

**How it works:**

1. A librarian searches for a book.
2. The desktop app sends a SQL query directly to the MySQL server.
3. The server fetches the data and returns it to the GUI for display.

### Limitations

- **Scalability:** Can’t handle thousands of users well.
- **Maintainability:** Business logic scattered between UI and DB logic.
- **Security:** Exposes DB to clients directly.

### Suitable For

- Small-scale internal applications
- Single-location systems (like school software, small inventory tools)
- Rapid development with limited infrastructure

### Comparison Table: 2-Tier vs. Monolithic Architecture

| Feature                     | 2-Tier Architecture                         | Monolithic Architecture                             |
| --------------------------- | ------------------------------------------- | --------------------------------------------------- |
| **Definition**              | System divided into client and server tiers | Entire application built as one large unit          |
| **Structure**               | - Client (UI) <br/> - Server (DB + logic)    | All logic (UI, business, data access) in one app    |
| **Business Logic Location** | Usually on the server (sometimes shared)    | Part of the monolith; often tightly coupled         |
| **Deployment Unit**         | Two separate tiers (UI + server)            | Single deployment (usually a large binary or app)   |
| **Scalability**             | Limited scalability                         | Can be scaled vertically, but not horizontally well |
| **Maintainability**         | Moderate – client/server split helps a bit  | Hard to maintain as codebase grows                  |
| **Performance**             | Good for small apps (less overhead)         | Good initially, but performance degrades with size  |
| **Communication**           | Direct DB calls (e.g., via JDBC, ODBC)      | Internal method calls within the same app           |
| **Example**                 | Java Swing app connecting directly to MySQL | E-commerce site built with Spring Boot monolith     |
| **Security**                | Less secure – DB exposed to client          | Better control since access is internal             |
| **Technology Stack**        | Often mixed (desktop + DB)                  | Unified stack (Java, Python, etc.)                  |

**Visualization:**

2-Tier Architecture

```
[ Client App (UI) ] ⇄ [ Server (DB + Business Logic) ]
```
