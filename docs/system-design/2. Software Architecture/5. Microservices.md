
Microservices architecture is a software design approach where an application is structured as a collection of small, independent services that communicate over well-defined APIs. Each service is focused on a specific business capability and can be developed, deployed, and scaled independently.

### Key Characteristics of Microservices Architecture

1. **Independently Deployable Services:** Each microservice is self-contained and can be deployed without affecting others.
2. **Decentralized Data Management:** Every service has its own database or data source to prevent data coupling.
3. **Technology Agnostic:** Different services can be written in different languages and use different data stores.
4. **Service Communication via APIs:** Services communicate with each other using lightweight protocols like HTTP/REST or messaging queues (e.g., RabbitMQ, Kafka).
5. **Domain-Driven Design (DDD):** Services are modeled around business domains (bounded contexts).
6. **Scalability and Resilience:** Individual services can scale horizontally, and if one fails, others continue to function.
7. **DevOps & CI/CD Friendly:** Microservices enable continuous integration and deployment because services are small and isolated.

### Architecture Diagram

```
   [ API Gateway ]
        /   |   \
 [User Service] [Product Service] [Order Service]
       |            |                 |
   [User DB]   [Product DB]       [Order DB]
```

### Example

1. User Service

   - Handles registration, login, profile.
   - Owns `UserDB`.
   - Exposes APIs like:
     - `POST /users/register`
     - `GET /users/{id}`

2. Product Service

   - Manages products, categories, inventory.
   - Owns `ProductDB`.
   - Exposes APIs like:
     - `GET /products`
     - `POST /products/add`

3. Order Service

   - Handles orders, checkout, payments.
   - Owns OrderDB.
   - Exposes APIs like:
     - `POST /orders/create`
     - `GET /orders/{userId}`

4. API Gateway
   - Entry point for clients (web/mobile).
   - Routes requests to the appropriate service.
   - Can handle authentication, rate-limiting, and logging.

### How It Works Together

1. A user registers via the API Gateway, which forwards the request to the User Service.
2. The user adds items to a cart (frontend logic), and when checking out:

   - Product Service is queried for item availability.
   - Order Service processes the order and stores it in OrderDB.
   - Payment is handled via a third-party or separate Payment Service.

### Advantages of Microservices Architecture

- **Scalability:** Scale services independently.
- **Resilience:** Failure in one service doesn't crash the whole system.
- **Flexibility:** Use best-fit technologies for each service.
- **Faster Development:** Teams can work on services in parallel.
- **Easier Maintenance:** Smaller codebases per service.

### Challenges

- **Complex Deployment:** Managing many services is harder than a monolith.
- **Data Consistency:** Harder to maintain ACID properties across services.
- **Distributed Debugging:** Tracing bugs across services can be tough.
- **Network Latency & Failures:** Inter-service calls introduce overhead.

### Technologies Commonly Used

- **Service Communication:** REST, gRPC, GraphQL, Kafka, RabbitMQ
- **Service Discovery:** Eureka, Consul, Kubernetes DNS
- **API Gateway:** NGINX, Kong, AWS API Gateway
- **Containerization:** Docker, Kubernetes
- **Monitoring:** Prometheus, Grafana, ELK Stack
- **CI/CD:** Jenkins, GitHub Actions, GitLab CI
