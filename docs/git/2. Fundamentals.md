---
title: Fundamentals
sidebar_position: 3
---

## Initialization

`git init` is the command used to create a new Git repository in a directory. It initializes Git tracking for the project, allowing you to version control files, track changes, and collaborate with others.

Once you run `git init`, Git creates a hidden `.git` folder in the project directory, which stores all version control data such as commits, branches, and configurations.

**Verify Initiaization**

To check if the repository was initialized successfully:

```shell
ls -a
```

Output:

```shell
. .. .git
```

Reinitializing won’t overwrite existing version history. If the repository is already initialized, it will simply reinitialize Git settings.

```shell
Reinitialized existing Git repository in /path/to/project/.git/
```

## Staging

`git add` is a command in Git that moves changes from the working directory to the staging area (also known as the index). The staging area is an intermediate space where Git collects changes before committing them to the repository.

This allows you to control which changes are included in the next commit, giving you flexibility in tracking modifications.

### Why is Staging Important?

- **Selective Commit** – You can stage specific files while leaving others uncommitted.
- **Organized Workflow** – Allows reviewing changes before committing.
- **Avoids Mistakes** – Prevents accidental commits of unfinished changes.

### Commands

- `git add file_name` -> take the file into staging state(here files are trackable)
- `git add -A` -> stage all changed file in directory and subdirectories
- `git add .` -> stage all changed file in directory but not subdirectories
- `git add *.extension` -> stage all changed file in directory with specific extension
- `git add **/*.extension` -> stage all changed file in directory and subdirectories with specific extension
- `git restore --staged file_name` -> unstage file without losing your changes.

## Commits

A commit in Git is a snapshot of the current state of your project. The `git commit` command takes all staged changes (added using `git add`) and saves them permanently in the repository's history.

**Each commit has:**

- A unique commit ID (SHA-1 hash).
- A commit message describing the changes.
- A reference to the previous commit, forming a history.

### Why Are Commits Important?

- **Version Control** – You can track changes over time.
- **Revert to Previous States** – Restore any earlier version of your project.
- **Collaboration** – Helps teams understand what was changed and why.

### Commands

- `git commit -m 'message here'` -> moving staging to local repository(message should be clear and understandable).
- `git commit -am 'message here'` -> staging and commiting together.
- `git reset --soft HEAD~1` -> undo the last commit but keep changes in staging area.
- `git reset --mixed HEAD~1` -> undo the last commit but keep changes in working directory.
- `git reset --hard HEAD~1` -> permanently deletes the last commit and all changes.

## History

Git provides powerful tools to view the history of commits made to a repository. The most commonly used commands for this purpose are:

- `git log`: Shows the commit history.
- `git reflog`: Shows a reference log of changes to the branch's HEAD.

### `git log`

Git provides commands like `git log` to navigate through the commit history.

1. `git log` displays a list of commits in reverse chronogloical order(latest commit first)

It shows:

- **Commit hash** – A unique identifier (SHA-1 hash) for each commit.
- **Author** – The person who made the commit.
- **Date** – When the commit was created.
- **Commit message** – A short description of the commit.

**Example Output:**

```shell
commit d6f9b1a2b6c3e9d0d46f15e5b2af324e54b8d214 (HEAD -> main)
Author: John Doe <john@example.com>
Date:   Sat Feb 23 10:30:00 2025

    Updated README file

commit b1c3d9f3e6a2d8a7c9b3e8a2f9c1d6e7a8f5c3d2
Author: John Doe <john@example.com>
Date:   Fri Feb 22 14:20:15 2025

    Initial commit: Added README
```

2. `git log --online` -> return online-log

**Example Output:**

```shell
d6f9b1a Updated README file
b1c3d9f Initial commit: Added README
```

3. `git log -n` -> return latest n commit.
4. `git log --author="John Doe"` -> return commits by a specific user.
5. `git log --grep="bug fix"` -> search commit contain specific keyword.
6. `git log -p` -> shows changes(diff) introduced by each commit.

### `git reflog`

Unlike `git log`, which shows the commit history, `git reflog` tracks local reference changes, including:

- When a commit was made
- When branches were switched
- When commits were reset, rebased, or amended

1. `git reflog` shows:
   ```shell
   e3a1b5c (HEAD -> main) HEAD@{0}: commit: Updated index.html with a welcome message
   f3a29c1 HEAD@{1}: commit: Added index.html with a basic heading
   d7e4f12 HEAD@{2}: checkout: moving from feature-branch to main
   ```

- `HEAD@{0}`: Most recent reference update (latest commit).
- `HEAD@{1}`: Previous commit before the latest.
- `checkout: moving from feature-branch to main:` Shows that the branch was switched.

### Difference Between `git log` and `git reflog`

| Feature                           | `git log` | `git reflog` |
| --------------------------------- | --------- | ------------ |
| Shows commit history              | ✅        | ✅           |
| Shows branch movements (checkout) | ❌        | ✅           |
| Shows reset/rebase history        | ❌        | ✅           |
| Available only locally            | ❌        | ✅           |
| Shows remote commits              | ✅        | ❌           |

### Using `git log` and `git reflog` for Recovery

If you accidentally reset or delete a commit, you can recover.

1. View the reference log with `git reflog`. Suppose the lost commit hash was `e3a1b5c`.
2. Reset to the lost commit with `git reset --hard e3a1b5c`. This restores the repository to the state of that commit.

## Differences

The `git diff` command allows you to compare changes in your project.

It helps identify differences between:

- Working directory and staging area
- Staged changes and last commit
- Two commits
- Two branches

### Commands

- `git diff` - show differences before `git add .`
- `git diff --staged` - show differences after `git add .`
- `git diff HEAD` - show differences both before and after `git add .`
- `git diff <commit1> <commit2>` - Compare two specific commits
- `git diff -- file.txt` - Show changes for a specific file

## Status

The git status command is used to check the state of the working directory and staging area. It helps you understand which changes are tracked, untracked, or staged before committing them.

It provides information about:

- Untracked files (new files not yet added to Git)
- Modified files (changes not yet staged)
- Staged files (ready to be committed)
- Branch information (current branch, ahead/behind status)

### States

1. Before `git init`

   ```shell
   fatal: not a git repository (or any of the parent directories): .git
   ```

2. After `git init` with empty file

   ```shell
   On branch master

   No commits yet

   nothing to commit (create/copy files and use "git add" to track)
   ```

3. After `git init` with untracked file

   ```shell
   On branch master

   No commits yet

   Untracked files:
     (use "git add <file>..." to include in what will be committed)
           index.html

   nothing added to commit but untracked files present (use "git add" to track)
   ```

4. After `git add .`

   ```shell
   On branch master

   No commits yet

   Changes to be committed:
     (use "git rm --cached <file>..." to unstage)
           new file:   index.html
   ```

5. After `git commit -m"commit message"`

   ```shell
   On branch master
   nothing to commit, working tree clean
   ```

6. After making another change after initialization

   ```shell
   On branch master
   Changes not staged for commit:
     (use "git add <file>..." to update what will be committed)
     (use "git restore <file>..." to discard changes in working directory)
           modified:   index.html

   no changes added to commit (use "git add" and/or "git commit -a")
   ```

7. After tracked
   ```shell
   On branch master
   Changes to be committed:
     (use "git restore --staged <file>..." to unstage)
           modified:   index.html
   ```
8. Create and Leave an Untracked File
   ```shell
   On branch main
   Untracked files:
     (use "git add <file>..." to include in what will be committed)
   	newfile.txt
   ```
9. Removed a Tracked File
   ```shell
      On branch main
   Changes not staged for commit:
     (use "git add/rm <file>..." to update what will be committed)
     (use "git restore <file>..." to discard changes)
   	deleted:    hello.txt
   ```
   To stage the deletion run `git add hello.txt` or `git rm hello.txt`. Then check again:
   ```
      On branch main
   Changes to be committed:
   	deleted:    hello.txt
   ```
   Then commit the deletion
