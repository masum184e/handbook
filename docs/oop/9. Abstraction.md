- Encapsulation → protecting correctness
- Abstraction → defining capability and role

Abstraction is the principle of:

> Focusing on what an object does, not how it does it.

It defines:

- Interfaces
- Contracts
- Boundaries between components

While encapsulation hides internal state,  
abstraction hides implementation complexity.

## Abstraction vs Encapsulation (Core Difference)

| Encapsulation       | Abstraction                        |
| ------------------- | ---------------------------------- |
| Hides internal data | Hides implementation details       |
| Protects invariants | Defines behavior                   |
| Uses private fields | Uses interfaces / abstract classes |
| Focus: correctness  | Focus: capability                  |

Encapsulation = protecting the object  
Abstraction = describing the object

## Abstraction Through Interfaces

An interface defines:

- What methods exist
- What behavior is promised
- Without saying how it’s implemented

It defines a contract.

### Example: Payment System

We define an abstraction:

```java
interface PaymentMethod {
    void pay(double amount);
}
```

This says:

> Any payment method must be able to process a payment of a given amount.

It does NOT say:

- How the payment works
- Whether it's credit card, PayPal, crypto, etc.

That’s abstraction.

### Concrete Implementations

```java
class CreditCardPayment implements PaymentMethod {
    public void pay(double amount) {
        System.out.println("Processing credit card payment of $" + amount);
    }
}

class PayPalPayment implements PaymentMethod {
    public void pay(double amount) {
        System.out.println("Processing PayPal payment of $" + amount);
    }
}
```

Each class:

- Has its own implementation
- Satisfies the same contract

### Using the Abstraction

```java
public class Checkout {
    public void processPayment(PaymentMethod method) {
        method.pay(100);
    }
}
```

Notice something powerful:

`Checkout` does NOT know:

- What type of payment is used
- How payment is processed

It only knows the contract.

This is abstraction creating a boundary.

### What is a Contract

A contract specifies:

- What inputs are expected
- What behavior is guaranteed
- What outputs will result

It does NOT describe internal algorithm.

Example contract for `pay(amount)`:

- Precondition: amount > 0
- Postcondition: payment is processed or exception thrown

That’s a behavioral promise.

## Abstraction Creates Boundaries

Abstraction separates components.

For example:

```
[ Checkout System ]
        |
        |  (PaymentMethod interface)
        |
[ Payment Implementations ]
```

Checkout is independent from:

- Bank APIs
- Payment provider logic
- Security mechanisms

This reduces coupling.

If tomorrow you add:

```java
class CryptoPayment implements PaymentMethod
```

Checkout does not change.

That’s the power of abstraction.

## Encapsulation vs Abstraction — Same Example

Let’s analyze both principles in the Payment example.

Abstraction:

- Interface defines behavior (`pay`)
- Checkout depends on interface
- Implementation hidden

### Encapsulation:

Inside `CreditCardPayment`:

```java
class CreditCardPayment implements PaymentMethod {
    private String cardNumber;

    public CreditCardPayment(String cardNumber) {
        this.cardNumber = cardNumber;
    }

    public void pay(double amount) {
        validateCard();
        charge(amount);
    }

    private void validateCard() { }
    private void charge(double amount) { }
}
```

Encapsulation:

- `cardNumber` is private
- Internal logic hidden
- Invariants protected

Abstraction:

- Only `pay()` is visible to outside world

### Deep Conceptual Difference

Think of abstraction as:

> A role or capability description.

Think of encapsulation as:

> A safety mechanism.

Abstraction answers: What can this object do?

Encapsulation answers: How does this object protect itself?

## Real-World Analogy

Car Example

**Abstraction:**

You interact with:

- Steering wheel
- Pedals
- Gear shift

You don’t know how combustion works.

That’s abstraction.

**Encapsulation:**

Engine internals:

- Pistons
- Fuel injection
- Timing system

They are protected.
You cannot randomly modify them.

That’s encapsulation.

## Stronger Technical Example

Let’s build a logging system.

### Step 1: Abstraction

```java
interface Logger {
    void log(String message);
}
```

### Step 2: Implementations

```java
class FileLogger implements Logger {
    public void log(String message) {
        System.out.println("Writing to file: " + message);
    }
}

class DatabaseLogger implements Logger {
    public void log(String message) {
        System.out.println("Writing to database: " + message);
    }
}
```

### Step 3: System Using Abstraction

```java
class Application {
    private Logger logger;

    public Application(Logger logger) {
        this.logger = logger;
    }

    public void run() {
        logger.log("Application started");
    }
}
```

Application does not care:

- Where logs go
- How they are stored
- What storage system exists

It depends only on the abstraction.

## Why Abstraction is Powerful

1. Reduces complexity
2. Enables substitution (polymorphism)
3. Encourages loose coupling
4. Makes systems extensible
5. Improves testability (you can mock interfaces)

## Quick Comparison Summary

| Concept       | Purpose                  | Mechanism                         | Example             |
| ------------- | ------------------------ | --------------------------------- | ------------------- |
| Encapsulation | Protect object integrity | private fields, controlled access | BankAccount balance |
| Abstraction   | Define behavior and role | interfaces, abstract classes      | PaymentMethod       |

## Final Key Insight

Encapsulation works inside a class.  
Abstraction works between classes.

Encapsulation protects correctness.  
Abstraction enables flexibility.

They complement each other.
