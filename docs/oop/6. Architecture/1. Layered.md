Layered Architecture organizes a software system into horizontal layers, where each layer has a specific responsibility and interacts only with the layers directly above or below it.

The main goal is to:

- Improve maintainability
- Increase modularity
- Support separation of concerns
- Make systems easier to test and modify

## Typical Layers in Object-Oriented Architecture

Although the number of layers can vary, a common structure includes:

### Presentation Layer (UI Layer)

- Handles user interaction.
- Displays data and collects user input.
- Contains UI classes, controllers, or views.

Examples: Web pages, mobile screens, API controllers.

### Application Layer (Service / Business Layer)

- Coordinates application tasks.
- Contains business rules and workflows.
- Acts as a bridge between UI and data layers.

Examples: OrderService, PaymentProcessor, UserManager.

### Domain Layer (Business Logic / Model Layer)

- Represents core business concepts and rules.
- Contains domain objects (entities, value objects).

Examples: Order, Customer, Invoice, Product.

### Data Access Layer (Persistence Layer)

Handles storage and retrieval of data.

Isolates the database from the rest of the system.

Examples: Repositories, DAOs, database mappers.

### Infrastructure Layer (Optional)

- Provides technical services such as logging, email, caching, file systems, or external APIs.

## Rules of Layered Architecture

1. Each layer has a defined responsibility.
2. Upper layers depend on lower layers, not the other way around.
3. A layer should only communicate with the layer directly below it (strict layering).
4. Layers should be replaceable without affecting others (e.g., switching databases).

## Example: Online Shopping System

Let’s model an Online Shopping System using layered architecture.

### Presentation Layer

```java
class OrderController {
    private OrderService orderService;

    public void placeOrder(int customerId, List<Item> items) {
        orderService.processOrder(customerId, items);
    }
}
```

Role: Receives user requests and sends them to the service layer.

### Application / Service Layer

```java
class OrderService {
    private OrderRepository orderRepository;
    private PaymentService paymentService;

    public void processOrder(int customerId, List<Item> items) {
        Order order = new Order(customerId, items);
        paymentService.processPayment(order);
        orderRepository.save(order);
    }
}
```

Role: Implements business workflows like order processing and payment.

### Domain Layer

```java
class Order {
    private int customerId;
    private List<Item> items;

    public Order(int customerId, List<Item> items) {
        this.customerId = customerId;
        this.items = items;
    }

    public double calculateTotal() {
        return items.stream().mapToDouble(Item::getPrice).sum();
    }
}
```

Role: Represents core business objects and rules.

### Data Access Layer

```java
class OrderRepository {
    public void save(Order order) {
        // Save order to database
    }

    public Order findById(int id) {
        // Retrieve order from database
        return null;
    }
}
```

Role: Manages persistence and database interactions.

## How the Layers Work Together

User → UI → Service → Domain → Data → Database

Example flow:

1. User places an order through the UI.
2. Presentation layer sends request to service layer.
3. Service layer creates domain objects and applies business rules.
4. Data layer stores the order.
5. Result flows back up to the user.

**Advantages of Layered Architecture**

- Clear separation of concerns
- Easier maintenance and updates
- Improved testability
- Supports parallel development
- Encourages reuse

**Disadvantages**

- Can introduce performance overhead
- May become rigid for complex workflows
- Changes in lower layers can still affect upper layers
