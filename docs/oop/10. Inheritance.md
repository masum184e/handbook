Inheritance allows one class (child/subclass) to reuse and extend another class (parent/superclass).

```java
class Animal {
    public void eat() {
        System.out.println("Eating...");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Bark!");
    }
}
```

- `Dog` inherits behavior from `Animal`.
- But inheritance is more than code reuse.
- It creates an "is-a" relationship: Dog is an Animal.

## The Real Question: When Should You Use Inheritance?

Use inheritance only when:

> The subclass truly satisfies the behavioral contract and invariants of the superclass.

This is called the Liskov Substitution Principle (LSP):

If `B` extends `A`, then `B` must be usable anywhere `A` is expected without breaking correctness.

That means:

- All invariants of `A` must still hold in `B`.
- `B` must not weaken guarantees.
- `B` must not violate assumptions of `A`.

## Inheritance and Invariants

This is where encapsulation becomes critical.

A superclass defines:

- Internal state
- Invariants
- Behavioral contract

If a subclass breaks those invariants, inheritance is wrong.

## Classic Wrong Example: Rectangle–Square Problem

We define:

```java
class Rectangle {
    protected int width;
    protected int height;

    public void setWidth(int width) {
        this.width = width;
    }

    public void setHeight(int height) {
        this.height = height;
    }

    public int getArea() {
        return width * height;
    }
}
```

Now someone writes:

```java
class Square extends Rectangle {

    @Override
    public void setWidth(int width) {
        this.width = width;
        this.height = width;
    }

    @Override
    public void setHeight(int height) {
        this.width = height;
        this.height = height;
    }
}
```

Seems logical, right?

But Rectangle’s implicit invariant is:

> Width and height are independent.

Square’s invariant is:

> Width == height.

Now this breaks substitutability:

```java
Rectangle r = new Square();
r.setWidth(5);
r.setHeight(10);

System.out.println(r.getArea());  // Expected 50, gets 100
```

Boom.

Square cannot safely substitute Rectangle.

Inheritance violated invariants.

## When Inheritance Is Correct

Use inheritance when:

1. There is a true is-a relationship.
2. The subclass does not change invariants.
3. The subclass only extends behavior, not contradict it.
4. You want polymorphic substitution.

### Good Example: Shape Hierarchy

```java
abstract class Shape {
    public abstract double getArea();
}
```

Subclasses:

```java
class Circle extends Shape {
    private double radius;

    public Circle(double radius) {
        if (radius <= 0)
            throw new IllegalArgumentException();
        this.radius = radius;
    }

    public double getArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle extends Shape {
    private double width;
    private double height;

    public Rectangle(double width, double height) {
        if (width <= 0 || height <= 0)
            throw new IllegalArgumentException();
        this.width = width;
        this.height = height;
    }

    public double getArea() {
        return width * height;
    }
}
```

- No shared mutable invariant is broken.
- Both satisfy the contract: “a shape can compute area.”
- No subclass weakens guarantees.

This is safe inheritance.

## Now: Composition

Composition means:

> Instead of inheriting behavior, you include another object as a field.

"Has-a" relationship instead of "is-a".

### Example: Car and Engine

```java
class Engine {
    public void start() {
        System.out.println("Engine started");
    }
}

class Car {
    private Engine engine;

    public Car() {
        this.engine = new Engine();
    }

    public void startCar() {
        engine.start();
    }
}
```

Car has an Engine.

Car is not an Engine.

This preserves encapsulation better.

## Why Composition Is Often Better

Inheritance:

- Exposes parent internals to child.
- Couples child tightly to parent.
- Can break invariants.
- Hard to modify superclass later.

Composition:

- Preserves encapsulation.
- Looser coupling.
- More flexible.
- Easier to change behavior dynamically.

## Dangerous Inheritance Example (Fragile Base Class)

Imagine:

```java
class Logger {
    protected List<String> logs = new ArrayList<>();

    public void log(String message) {
        logs.add(message);
    }
}
```

Child class:

```java
class TimestampLogger extends Logger {
    @Override
    public void log(String message) {
        logs.add(System.currentTimeMillis() + ": " + message);
    }
}
```

If Logger later changes internal storage:

- Subclass may break.
- Encapsulation was weak because `logs` was protected.

Inheritance leaks implementation details.

## Safer Alternative Using Composition

```java
class TimestampLogger {
    private Logger logger;

    public TimestampLogger(Logger logger) {
        this.logger = logger;
    }

    public void log(String message) {
        logger.log(System.currentTimeMillis() + ": " + message);
    }
}
```

Now:

- Logger internals remain hidden.
- TimestampLogger depends only on public API.
- Encapsulation preserved.

## Clear Decision Rule

Use inheritance when:

- You want polymorphism
- There is a true "is-a" relationship
- Subclass does not change invariants
- You are extending behavior, not restricting it

Use composition when:

- Relationship is "has-a"
- You want flexibility
- You want to preserve encapsulation
- Behavior may change at runtime
- You are reusing functionality without true subtype meaning

## Deep Insight

Inheritance is about type hierarchy.

Composition is about behavior reuse.

If your goal is:

- Code reuse → prefer composition.
- Substitutability → inheritance may be appropriate.

## Golden Rule

Favor composition over inheritance.

Because:

- Composition preserves encapsulation.
- Inheritance exposes it.
- Encapsulation protects invariants.
- Broken invariants break systems.

## Final Comparison

| Inheritance               | Composition          |
| ------------------------- | -------------------- |
| "is-a"                    | "has-a"              |
| Tight coupling            | Loose coupling       |
| Can break invariants      | Preserves invariants |
| Compile-time relationship | Can be dynamic       |
| Harder to change          | More flexible        |
