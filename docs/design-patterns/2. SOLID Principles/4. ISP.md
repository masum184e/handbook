> Clients should not be forced to depend on interfaces they do not use.

Or more plainly:

> Don’t make classes implement methods they don’t need.

This principle fights fat interfaces.

## Why ISP Exists

Large interfaces create:

- Unnecessary coupling
- Fragile implementations
- Ripple effects when changing methods
- Fake implementations (throwing exceptions)

ISP keeps abstractions focused and minimal.

## Classic Violation Example

Imagine this interface:

```java
interface Machine {
    void print(Document doc);
    void scan(Document doc);
    void fax(Document doc);
}
```

Now we implement a simple printer:

```java
class BasicPrinter implements Machine {

    public void print(Document doc) {
        System.out.println("Printing...");
    }

    public void scan(Document doc) {
        throw new UnsupportedOperationException();
    }

    public void fax(Document doc) {
        throw new UnsupportedOperationException();
    }
}
```

Problem:

- BasicPrinter cannot scan or fax.
- Yet it is forced to depend on those methods.
- Clients might accidentally call unsupported methods.

This violates ISP.

## What’s Actually Wrong?

The interface mixes multiple responsibilities:

- Printing
- Scanning
- Faxing

Different clients need different capabilities.

We forced them together.

## Applying ISP Properly

Split the interface:

```java
interface Printer {
    void print(Document doc);
}

interface Scanner {
    void scan(Document doc);
}

interface Fax {
    void fax(Document doc);
}
```

Now:

```java
class BasicPrinter implements Printer {
    public void print(Document doc) {
        System.out.println("Printing...");
    }
}
```

And a multi-function device:

```java
class MultiFunctionPrinter implements Printer, Scanner, Fax {

    public void print(Document doc) { ... }

    public void scan(Document doc) { ... }

    public void fax(Document doc) { ... }
}
```

Now:

- Classes depend only on what they use.
- No fake methods.
- No broken contracts.

## Real-World Example: User System

Bad design:

```java
interface User {
    void login();
    void logout();
    void manageUsers();
    void viewReports();
}
```

Now:

- RegularUser implements User
- AdminUser implements User

But RegularUser cannot manage users.

So:

```java
public void manageUsers() {
    throw new UnsupportedOperationException();
}
```

That’s a smell.

## Correct Design

Split responsibilities:

```java
interface AuthenticatedUser {
    void login();
    void logout();
}

interface AdminPrivileges {
    void manageUsers();
}

interface ReportingPrivileges {
    void viewReports();
}
```

Now:

```
class RegularUser implements AuthenticatedUser { ... }

class AdminUser implements AuthenticatedUser, AdminPrivileges, ReportingPrivileges { ... }
```

## Relationship to Other SOLID Principles

ISP supports:

- SRP (interfaces have focused responsibility)
- LSP (no fake or unsupported methods)
- OCP (extensions through composition of small interfaces)
- DIP (depend on minimal abstractions)

Large interfaces often break LSP.

## Real-World Tradeoffs

ISP is powerful — but like all SOLID principles, it has tradeoffs.

### Too Many Small Interfaces

If taken too far:

You may create:

```
Readable
Writable
Executable
Closable
Flushable
Resettable
...
```

Now your code becomes fragmented.

Too many abstractions reduce readability.

Tradeoff:

> Granularity vs simplicity.

### Discoverability Problems

A large interface is easy to understand: “One thing does everything.”

Many small interfaces: You must know which ones to combine.

This increases cognitive load.

### Premature Segregation

If you split interfaces too early:

- You might guess wrong about variation points.
- You introduce abstraction before needed.
- You overcomplicate a simple system.

ISP is most valuable in:

- Large systems
- Framework design
- Public APIs
- Long-lived software

### Evolution Cost

If a new shared behavior emerges:

You might need:

- A new interface
- Refactoring of multiple classes

So ISP doesn’t eliminate change.
It localizes it.

## Subtle Insight

ISP is not about making interfaces small.

It’s about making them client-specific.

If three clients use different subsets of behavior,  
they probably deserve different interfaces.

## Real-World Case: Java Standard Library

Java uses ISP heavily.

Example:

Instead of one giant collection interface, it has:

- Iterable
- Collection
- List
- Set
- Queue
- Deque

A class implements only what it supports.

This keeps contracts honest.

## How to Detect ISP Violations

Warning signs:

- Methods throwing UnsupportedOperationException
- Classes implementing methods they don’t use
- Interfaces with unrelated method groups
- Frequent modification of interface for new features

If you see these → ISP likely violated.

## When Not to Overapply ISP

In:

- Small internal tools
- Short-lived projects
- Prototypes

Sometimes one interface is simpler.

Design maturity grows with system scale.

## Deep Insight

ISP reduces unnecessary coupling between modules.

It narrows dependency width.

Instead of: Module A → depends on 10 methods

You get: Module A → depends on 2 relevant methods

This makes change safer.

## Final Summary

Interface Segregation Principle means:

- Keep interfaces focused.
- Don’t force unused dependencies.
- Split by client needs.
- Keep contracts honest.

Benefits:

- Lower coupling
- Better LSP compliance
- Safer refactoring
- Cleaner abstractions

Costs:

- More interfaces
- More architectural complexity
- Risk of overengineering
