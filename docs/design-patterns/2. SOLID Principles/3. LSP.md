Many developers think LSP is just:

> “A subclass should be usable wherever its superclass is used.”

That’s only the surface.

Let’s go deep.

> If S is a subtype of T, then objects of type T should be replaceable with objects of type S without altering the correctness of the program.

In simpler terms:

> Subtypes must honor the contract of their base type.

Not just method signatures.
Not just inheritance.

But behavior.

## Why LSP Exists

Inheritance creates trust.

When you accept a base type:

```java
void process(Shape shape)
```

You are trusting:

Its invariants hold

Its methods behave as promised

It doesn’t break assumptions

If a subtype violates those assumptions → system breaks.

## The Rectangle–Square Problem (Classic LSP Violation)

Base class:

```java
class Rectangle {
    protected int width;
    protected int height;

    public void setWidth(int width) {
        this.width = width;
    }

    public void setHeight(int height) {
        this.height = height;
    }

    public int getArea() {
        return width * height;
    }
}
```

Now someone writes:

```java
class Square extends Rectangle {

    @Override
    public void setWidth(int width) {
        this.width = width;
        this.height = width;
    }

    @Override
    public void setHeight(int height) {
        this.width = height;
        this.height = height;
    }
}
```

Looks mathematically valid.

But now:

```java
Rectangle r = new Square();
r.setWidth(5);
r.setHeight(10);

System.out.println(r.getArea());
```

Expected (based on Rectangle logic):  
5 × 10 = 50

Actual:  
10 × 10 = 100

The program’s correctness changed.

LSP is violated.

## What Actually Broke?

Rectangle’s implicit contract:

- Width and height are independent.

Square’s invariant:

- Width == Height.

These invariants conflict.

Inheritance created a logical contradiction.

## The Three Core Rules of LSP

A subtype must:

### Not strengthen preconditions

If base method accepts any positive number:

```java
void withdraw(double amount)
```

The subclass cannot restrict it further.

Bad:

```java
@Override
void withdraw(double amount) {
    if (amount < 100) throw new IllegalArgumentException();
}
```

Now callers that worked before break.

### Not weaken postconditions

If base guarantees:

> Withdrawal reduces balance.

Subclass cannot change that behavior.

### Preserve invariants

If base ensures:

> Balance ≥ 0

Subclass must not violate it.

## Real-World Example: Bird Problem

```java
class Bird {
    public void fly() {
        System.out.println("Flying");
    }
}
```

Subclass:

```java
class Penguin extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException();
    }
}
```

Now:

```java
void makeBirdFly(Bird bird) {
    bird.fly();
}
```

If you pass a Penguin → crash.

Penguin is biologically a bird.

But not behaviorally substitutable.

Inheritance was wrong.

Better design:

```java
interface Bird { }

interface FlyingBird extends Bird {
    void fly();
}

class Eagle implements FlyingBird { ... }
class Penguin implements Bird { ... }
```

Now contracts match reality.

## Why LSP Is So Important

Without LSP:

- Polymorphism becomes unsafe
- OCP breaks down
- Systems become fragile
- Hidden bugs appear

LSP is what makes inheritance reliable.

## Real-World Tradeoffs

LSP is idealistic.
Real systems are messy.

Let’s talk tradeoffs.

### Strict LSP Reduces Inheritance Use

If you follow LSP strictly:

- You’ll use less inheritance.
- You’ll favor composition.
- You’ll create smaller, more precise interfaces.

This increases:

- Number of types
- Design complexity

But increases:

- Predictability
- Maintainability

### Overengineering Risk

If you try to perfectly model every contract:

You may create:

- Too many abstractions
- Microscopic interfaces
- Hard-to-understand hierarchies

Balance matters.

### Domain vs Behavior Conflict

Sometimes domain hierarchy ≠ behavioral hierarchy.

Mathematically: Square is a Rectangle.

Behaviorally: Square cannot substitute Rectangle safely.

OOP models behavior, not taxonomy.

That’s a mental shift many struggle with.

## Subtle Real Example: Read-Only Collection

Imagine:

```java
interface List {
    void add(String item);
}
```

Now someone creates:

```java
class ReadOnlyList implements List {
    @Override
    public void add(String item) {
        throw new UnsupportedOperationException();
    }
}
```

This compiles.
But violates LSP.

Because base type contract implied:

> `add()` works.

Better design:

Split interface:

```java
interface ReadableList { ... }
interface ModifiableList extends ReadableList {
    void add(String item);
}
```

Now contracts are honest.

## LSP and SOLID

LSP supports:

- OCP (safe extension)
- DIP (safe substitution)
- SRP (clear responsibilities)

If LSP fails:
Everything collapses.

## Deep Insight

LSP is about behavioral compatibility.

Not structure.
Not inheritance syntax.
Not code reuse.

Behavior.

It forces you to ask:

> What promises does this type make?

If the subtype cannot fully keep those promises,
it should not inherit.

## When Breaking LSP Might Be Acceptable

In:

- Internal, small systems
- Controlled environments
- Performance-critical code

Sometimes you knowingly bend it.

But in large evolving systems?  
Violating LSP becomes expensive.

## Practical Rule of Thumb

Before using inheritance, ask:

1. Can I replace parent with child without changing expectations?
2. Does the child strengthen preconditions?
3. Does the child weaken guarantees?
4. Are invariants compatible?

If unsure → use composition.

## Final Summary

Liskov Substitution Principle ensures:

- Safe polymorphism
- Reliable inheritance
- Stable contracts

It prevents:

- Fragile hierarchies
- Hidden runtime failures
- Behavioral contradictions

It pushes you toward:

- Clear contracts
- Smaller interfaces
- Composition over inheritance
