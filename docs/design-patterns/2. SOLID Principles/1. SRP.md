The Single Responsibility Principle (SRP) is one of the most crucial concepts in SOLID. It's deceptively simple but incredibly impactful in creating clean, maintainable, and flexible systems.

A class should have only one reason to change, meaning that it should have only one job or responsibility.

In simpler terms:

> A class should have one focus — and should not be burdened with unrelated responsibilities.

## Why SRP Exists

Every time you change a class for a new reason, you risk:

- Unexpected side effects in other parts of the system.
- Increased coupling between unrelated features.
- Harder-to-test and maintain code.

If a class takes on multiple responsibilities:

- A change in one responsibility forces you to modify the class, affecting other parts of the system.
- This creates a domino effect — changes spread unpredictably.

## Violating SRP — Classic Example

Imagine a User class that handles both user data management and email notifications:

```java
class User {
    private String name;
    private String email;

    public void save() {
        // Save user to database
    }

    public void sendWelcomeEmail() {
        // Send email to user
    }
}
```

Problems:

- The User class has two responsibilities:
  1. Managing user data (save).
  2. Sending email notifications.

When the email notification logic changes (e.g., change email provider), we must modify the User class. This creates a fragile class and a highly coupled system.

## Applying SRP Properly

We split responsibilities into separate classes. Each class should have one reason to change.

### Step 1: User Class for Data Management

```java
class User {
    private String name;
    private String email;

    public void save() {
        // Save user to database
    }
}
```

### Step 2: EmailService Class for Email Notifications

```java
class EmailService {
    public void sendWelcomeEmail(User user) {
        // Send welcome email to user
    }
}
```

Now:

- User has only one responsibility: user data management.
- EmailService has only one responsibility: sending email notifications.

### Step 3: Dependency Injection (Optional for Flexibility)

We inject the email service into the User class, making it testable and flexible.

```java
class User {
    private String name;
    private String email;
    private EmailService emailService;

    public User(EmailService emailService) {
        this.emailService = emailService;
    }

    public void save() {
        // Save user to database
    }

    public void sendWelcomeEmail() {
        emailService.sendWelcomeEmail(this);
    }
}
```

## Real-World Example: Reporting System

Imagine a system where you generate reports, and your class handles both the logic of creating reports and printing them.

```java
class ReportGenerator {
    private String data;

    public void generateReport() {
        // Logic to generate report
    }

    public void printReport() {
        // Logic to print report
    }
}
```

This violates SRP because:

- The class is responsible for generating reports.
- The class is responsible for printing reports.

## Correct Design (SRP Compliant)

We split the responsibilities:

```java
class ReportGenerator {
    private String data;

    public void generateReport() {
        // Logic to generate report
    }
}
```

```java
class ReportPrinter {
    public void printReport(ReportGenerator reportGenerator) {
        // Logic to print report
    }
}
```

Now:

- ReportGenerator only generates reports.
- ReportPrinter only handles printing.

Each class has a single responsibility and one reason to change.

## Real-World Example: Logging

Imagine a UserService class that both manages users and logs every operation.

```java
class UserService {
    private Logger logger = new Logger();

    public void createUser(String name) {
        // Logic to create user
        logger.log("User created: " + name);
    }
}
```

Problems:

- UserService is now responsible for:
  1. User creation.
  1. Logging.

When logging needs to change (e.g., switch to a different logging framework), we must modify UserService, breaking SRP.

## Apply SRP by Extracting Logging

```java
class Logger {
    public void log(String message) {
        // Log the message to the console or file
    }
}
```

```java
class UserService {
    private Logger logger;

    public UserService(Logger logger) {
        this.logger = logger;
    }

    public void createUser(String name) {
        // Logic to create user
        logger.log("User created: " + name);
    }
}
```

Now:

- UserService only manages user creation.
- Logger is responsible for logging.

## Tradeoffs of SRP

The benefits of SRP are clear, but like all principles, there are tradeoffs.

### Increased Number of Classes

SRP often leads to:

- **More classes** in the system
- **Smaller classes**, each with a specific responsibility

While this improves flexibility, it can also increase complexity if taken too far.

- **Small systems** might not need so much abstraction.
- **Larger systems** benefit significantly from SRP because it minimizes the ripple effect of changes.

### Over-Engineering Risk

In some cases, applying SRP too early might result in unnecessary splitting of functionality into multiple classes.

For example, creating separate classes for trivial responsibilities that aren’t likely to change or grow can:

- Make the codebase harder to navigate.
- Increase cognitive load for new developers.

```java
class OrderValidator { ... }
class OrderProcessor { ... }
class OrderEmailer { ... }
```

If your order class is extremely simple and doesn’t need to change in the near future, splitting every small responsibility can become an over-engineering issue.

### Maintenance Costs

Although SRP improves maintainability in the long term, the short-term cost of refactoring a monolithic class into smaller ones can sometimes be high.

- You need to ensure that dependencies are injected properly.
- You may need to reorganize the system to accommodate the new structure.

However, once these changes are made, testing and extending the system become much easier.

### Dependency Injection Overhead

With SRP, you're often forced to rely on dependency injection (DI) to decouple the responsibilities. While DI makes testing and swapping components easier, it can introduce complexity:

- More constructors or setters to inject dependencies.
- Sometimes harder to follow the flow of the program.

## SRP vs Other SOLID Principles

SRP is foundational but interacts with other SOLID principles:

- **OCP (Open/Closed Principle)**: SRP allows classes to remain closed for modification by breaking down responsibilities.
- **LSP (Liskov Substitution Principle)**: SRP ensures that your class does one thing well, which makes it safer to substitute.
- **DIP (Dependency Inversion Principle)**: SRP often requires dependency injection, which is enhanced by DIP, allowing for cleaner architecture.
- **ISP (Interface Segregation Principle)**: SRP helps ensure that interfaces don’t become too large because each class has a single responsibility and needs fewer methods.

## When SRP Should Be Used

- For large and complex systems, SRP reduces the risk of tightly coupled code.
- When your system is growing and likely to require changes in the future. The more things a class is responsible for, the more it will break when any part changes.
- For code that's going to be reused. By isolating a class’s responsibility, you increase its reusability.
- When your code needs to be easily testable, SRP helps you isolate each behavior.

Avoid applying SRP too rigidly when:

- You're working with a simple, small system.
- You don’t expect much change or growth in certain features.
- You prioritize short-term speed over long-term maintainability.

## Final Summary

The Single Responsibility Principle encourages you to:

- Split classes based on their responsibilities.
- Ensure each class has one reason to change.

Benefits:

- More maintainable code.
- Easier to extend and test.
- Clearer separation of concerns.

Tradeoffs:

- More classes and interfaces.
- Over-engineering risk.
- Initial complexity from refactoring.

SRP helps manage complexity by minimizing coupling and focusing each class on one responsibility, making the codebase easier to maintain and extend.
