---
title: Authentication
sidebar_position: 13
---

## `next-auth`

### Install NextAuth

```bash
npm install next-auth
```

### Configure Environment Variables

Create a `.env` file with the following values:

```env
NEXT_PUBLIC_BASE_URL=http://localhost:3000
NEXTAUTH_SECRET=strong_secret
NEXTAUTH_URL=http://localhost:3000
GITHUB_ID=your_github_client_id
GITHUB_SECRET=your_github_client_secret
```

### Configure API Route

Create the NextAuth API route in `app/api/auth/[...nextauth].ts`:

```ts
import NextAuth from "next-auth";
import GithubProvider from "next-auth/providers/github";
import CredentialsProvider from "next-auth/providers/credentials";
import { verfiyUser } from "@/lib/auth"; // your custom verify function

const handler = NextAuth({
  providers: [
    GithubProvider({
      clientId: process.env.GITHUB_ID || "",
      clientSecret: process.env.GITHUB_SECRET || "",
    }),
    CredentialsProvider({
      credentials: {
        email: { label: "Email Address", type: "email" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        try {
          if (credentials?.email && credentials?.password) {
            return await verfiyUser(credentials.email, credentials.password);
          }
        } catch (error) {
          console.error(error);
        }
        return null;
      },
    }),
  ],
  pages: {
    signIn: "/signin",
  },
});

export { handler as GET, handler as POST };
```

### Sign In with Credentials

Use the `signIn` function from `next-auth/react`:

```ts
import { signIn } from "next-auth/react";

const response = await signIn("credentials", { email, password });
```

### Sign Up

Create a sign-up API route or call an existing endpoint:

```ts
const response = await fetch("/api/auth/signup", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ name, email, password }),
});
```

### Protect Client Components

Use `useSession` to check authentication:

```ts
import { useSession, signIn, signOut } from "next-auth/react";

export default function Component() {
  const { data: session } = useSession();

  if (session) {
    return (
      <>
        Signed in as {session.user?.email} <br />
        <button onClick={() => signOut()}>Sign out</button>
      </>
    );
  }

  return (
    <>
      Not signed in <br />
      <button onClick={() => signIn()}>Sign in</button>
    </>
  );
}
```

### Protect Server-Side Routes

Use `getServerSession` in API routes:

```ts
import { getServerSession } from "next-auth/next";
import { authOptions } from "./auth/[...nextauth]";

export default async (req, res) => {
  const session = await getServerSession(req, res, authOptions);

  if (session) {
    res.send({
      content:
        "This is protected content. You can access it because you are signed in.",
    });
  } else {
    res.send({
      error: "You must be signed in to view this content.",
    });
  }
};
```

- `getSession(context)` can also be used for server-rendered pages.
- Redirect users to login if no session is found.
- Ensures server-side protection for pages and API routes.

## JWT Authentication

### How JWT Authentication Works

1. **Login**: User submits credentials via a POST request to your API.
2. **Verify & Sign**: Server verifies credentials and issues a JWT.
3. **Store Token**: Client stores the JWT (in an HttpOnly cookie or `localStorage`).
4. **Authenticated Requests**: Client includes the JWT in headers or cookies when accessing protected routes.
5. **Verify Token**: Server checks the JWT on each protected request.

### Protecting Server-Side Routes

```ts
import jwt from "jsonwebtoken";

export default function Dashboard({ user }) {
  return (
    <h1>
      Welcome {user.email}! Role: {user.role}
    </h1>
  );
}

export async function getServerSideProps({ req }) {
  // Extract token from cookies
  const token = req.headers.cookie?.split("=")[1] || "";

  try {
    // Verify JWT
    const user = jwt.verify(token, process.env.JWT_SECRET);
    return { props: { user } };
  } catch (err) {
    // Redirect to login if verification fails
    return {
      redirect: { destination: "/login", permanent: false },
    };
  }
}
```

- Prefer HttpOnly cookies for storing JWTs to prevent XSS attacks.
- Always verify the JWT on every request to protected server-side pages.
- Customize payload to include user roles or permissions for fine-grained access control.

## Role-Based Access Control

### Adding Roles to JWT and Session

Configure the callbacks in your NextAuth options to attach user roles:

```ts
callbacks: {
  async jwt({ token, user }) {
    if (user) token.role = user.role; // attach role to JWT
    return token;
  },
  async session({ session, token }) {
    session.user.role = token.role; // make role available in session
    return session;
  },
}
```

### Protecting Client-Side Components by Role

```ts
"use client";
import { useSession } from "next-auth/react";

export default function AdminOnly({ children }) {
  const { data: session } = useSession();

  // Hide content if not logged in or not an admin
  if (!session || session.user.role !== "admin") return null;

  return <>{children}</>;
}
```

- Useful for rendering UI elements that only admins should see.
- Prevents accidental exposure of restricted content on the client.

### Protecting Server-Side Routes by Role

```ts
import { getSession } from "next-auth/react";

export default function AdminDashboard() {
  return <h1>Admin Dashboard - Only Admins Can See This</h1>;
}

export async function getServerSideProps(context) {
  const session = await getSession(context);

  // Redirect if not logged in
  if (!session) {
    return { redirect: { destination: "/login", permanent: false } };
  }

  // Redirect if not an admin
  if (session.user.role !== "admin") {
    return { redirect: { destination: "/", permanent: false } };
  }

  return { props: {} };
}
```

- First check ensures the user is authenticated.
- Second check ensures the user has the required `admin` role.
- Unauthorized users are redirected accordingly.
