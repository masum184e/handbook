---
title: Middleware
sidebar_position: 14
---

Middleware in Next.js is a powerful feature that lets you run code before a request is completed. It sits between the client request and the response, allowing you to modify requests, responses, or perform conditional routing.

## Features of Next.js Middleware

1. **Execution**:
   - Runs on the Edge Runtime (lighter, faster, no Node.js APIs).
   - Executes before rendering a page or running an API route.
2. **Use Cases**:
   - Authentication & authorization (redirect unauthorized users).
   - URL rewrites or redirects.
   - Logging, analytics, A/B testing.
   - Localization (redirecting users based on locale or region).
3. **File Location**:
   - Create a `middleware.ts` or `middleware.js` file at the root of your project (same level as `pages/` or `app/`).
   - Or inside specific directories for scoped middleware.
4. **Request Object**:
   - Middleware receives a `NextRequest` object.
   - Returns a `NextResponse` object to control what happens next.

## Custom Logic

Middleware in Next.js isn’t just for authentication or redirects—you can also write custom logic that runs before your routes are processed. This allows you to intercept, modify, or enforce rules at the edge layer.

### Steps for Writing Middleware

1. **Create the middleware file**

   - Add a `middleware.ts` or `middleware.js` at the root of your project (next to `pages/` or `app/`).
   - You can also scope it to a directory (e.g., `app/dashboard/middleware.ts`) if you want it to apply only to specific routes.

2. **Define your middleware function**
   - The function receives a `NextRequest` object.
   - You return a `NextResponse` that either:
     - Allows the request: `NextResponse.next()`
     - Redirects: `NextResponse.redirect()`
     - Rewrites: `NextResponse.rewrite()`
     - Or blocks / sends a custom response.
3. **(Optional) Add configuration**
   - Use the `config.matcher` property to decide which routes the middleware applies to.

### Custom Header Validation

Suppose you want all API requests to include a custom header `x-api-key`. If it’s missing or incorrect, reject the request.

```ts
// middleware.ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

export function middleware(request: NextRequest) {
  // Only check API routes
  if (request.nextUrl.pathname.startsWith("/api")) {
    const apiKey = request.headers.get("x-api-key");

    if (apiKey !== process.env.API_KEY) {
      return new NextResponse(
        JSON.stringify({ error: "Unauthorized request" }),
        { status: 401, headers: { "Content-Type": "application/json" } }
      );
    }
  }

  // Otherwise allow the request
  return NextResponse.next();
}
```

- We check if the request URL starts with `/api`.
- If yes, validate the `x-api-key` header.
- If invalid, return a custom 401 Unauthorized JSON response.
- If valid, continue with `NextResponse.next()`.

### Time-Based Access Control

Only allow access to `/dashboard` during working hours (9 AM – 6 PM). Outside this time, redirect to `/closed`.

```ts
// middleware.ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

export function middleware(request: NextRequest) {
  const hour = new Date().getHours();

  // Only allow during 9 AM - 6 PM
  if (hour < 9 || hour >= 18) {
    return NextResponse.redirect(new URL("/closed", request.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: "/dashboard/:path*",
};
```

- Uses `Date().getHours()` to check the server’s time.
- If the request is outside working hours, users are redirected to `/closed`.
- Applies only on `/dashboard/*` routes via `matcher`.

## Understanding `next.config.js`

By default, middleware in Next.js is controlled using the `config` export inside `middleware.ts` (with the `matcher` option).

But sometimes you need global project-level configuration that lives in `next.config.js`. This file defines build-time and runtime configurations for your Next.js project, and it can also influence how middleware behaves.

### Key Points

1. `matcher` vs `next.config.js`
   - Middleware itself can export a `config` with `matcher`.
   - But in some advanced cases, you may centralize route matching and rewrites in `next.config.js` so that middleware and routing work consistently.
2. Where it fits
   - `next.config.js` configures global behavior such as rewrites, redirects, and headers.
   - Middleware can then react to those rules.
3. What you can configure in `next.config.js` that affects middleware
   - `async rewrites()` – rewrite incoming requests before middleware executes.
   - `async redirects()` – define static redirects.
   - `headers()` – add security or custom headers globally.
   - `experimental.middlewarePrefetch (older versions)` – controls prefetch behavior with middleware.

### Middleware with Inline Matcher

```ts
// middleware.ts
export const config = {
  matcher: ["/dashboard/:path*", "/profile/:path*"],
};
```

### Centralized Routing

```ts
// next.config.js
module.exports = {
  async redirects() {
    return [
      {
        source: "/old-dashboard/:path*",
        destination: "/dashboard/:path*",
        permanent: true,
      },
    ];
  },
};
```

- If someone visits `/old-dashboard/settings`, Next.js redirects to `/dashboard/settings` before middleware runs.
- Then, middleware with `/dashboard/:path*` matcher takes over for authentication, logging, etc.

### Localization

```ts
// next.config.js
module.exports = {
  async rewrites() {
    return [
      { source: "/fr/:path*", destination: "/:path*" },
      { source: "/bd/:path*", destination: "/:path*" },
    ];
  },
};
```

```ts
// middleware.ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

export function middleware(request: NextRequest) {
  const country = request.geo?.country || "US";

  if (request.nextUrl.pathname === "/") {
    if (country === "FR") {
      return NextResponse.redirect(new URL("/fr", request.url));
    }
    if (country === "BD") {
      return NextResponse.redirect(new URL("/bd", request.url));
    }
  }

  return NextResponse.next();
}
```

- `next.config.js` ensures `/fr/*` and `/bd/*` map internally to the same routes (`/:path*`).
- Middleware adds dynamic redirection so `/` visitors get redirected to `/fr` or `/bd` based on location.

This combo makes localization powerful and consistent.

### Headers + Middleware

```ts
// next.config.js
module.exports = {
  async headers() {
    return [
      {
        source: "/:path*",
        headers: [
          { key: "X-Frame-Options", value: "DENY" },
          { key: "X-Content-Type-Options", value: "nosniff" },
        ],
      },
    ];
  },
};
```

```ts
// middleware.ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

export function middleware(request: NextRequest) {
  console.log(`Request to: ${request.nextUrl.pathname}`);
  return NextResponse.next();
}
```

- `next.config.js` ensures every route gets security headers automatically.
- Middleware focuses only on custom logic (logging, authentication, etc.).
- This separation of concerns keeps middleware lightweight.
