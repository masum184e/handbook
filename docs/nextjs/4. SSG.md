---
title: Static Side Generation
sidebar_position: 5
---

Static Site Generation (SSG) means that a page’s HTML is pre-rendered at build time (during deployment). The generated HTML, along with JSON data if needed, is then cached and served to every user.

- The server (or build process) creates the HTML ahead of time.
- The browser just loads the static HTML and hydrates it with React for interactivity.
- Data is fetched at build time, not per request.

In Next.js, SSG is used when:

1. Content doesn’t change often.
2. SEO matters (pages are fully rendered upfront).
3. You want very fast load times (served from CDN).
4. You can tolerate waiting until the `next build` to see content updates.

## How SSG Works

1. During the build (`next build`), Next.js runs `getStaticProps` (and optionally `getStaticPaths`).

2. Pages are converted into static HTML + JSON.

3. User requests the page → HTML is instantly served (no server computation).

4. React hydrates the static HTML → makes the page interactive.

## Best Use Cases for SSG

- **Blogs / Marketing sites** → SEO-friendly, rarely changing content.
- **E-commerce product catalogs** → Products don’t change per user.
- **Landing pages** → Homepages, feature pages.
- **Documentation / Knowledge bases** → Developer docs, help centers.
- **News sites / public data** → Can use ISR to rebuild periodically.

**Advantages**

- Super fast (served from CDN, no server computation).
- SEO-friendly (full HTML delivered upfront).
- Scales well (static files, no database calls).
- Can use Incremental Static Regeneration (ISR) to update content after build.

**Disadvantages**

- Content is only as fresh as the last build (unless ISR is used).
- Build times grow with large numbers of pages.
- Not suitable for highly personalized content.
- Requires redeploy (or ISR) to reflect new data.

## Data Fetching in SSG

- Use `getStaticProps` → Runs at build time.
- Use `getStaticPaths` (for dynamic routes) → Tells Next.js which paths to pre-generate.
- Data is embedded into the HTML/JSON and reused on every request.

This is different from CSR (data fetched in browser after load) and SSR (data fetched at request time).

## How to Use SSG

In Next.js, define `getStaticProps` (and optionally `getStaticPaths`) in your page component.

```tsx
// pages/posts/[id].tsx
import { GetStaticProps, GetStaticPaths, NextPage } from "next";

type Post = {
  id: string;
  title: string;
  body: string;
};

interface PostPageProps {
  post: Post;
}

const PostPage: NextPage<PostPageProps> = ({ post }) => {
  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold">{post.title}</h1>
      <p className="mt-4">{post.body}</p>
    </div>
  );
};

export default PostPage;

// Fetch all possible paths at build time
export const getStaticPaths: GetStaticPaths = async () => {
  const res = await fetch("https://jsonplaceholder.typicode.com/posts");
  const posts: Post[] = await res.json();

  const paths = posts.map((post) => ({
    params: { id: post.id.toString() },
  }));

  return { paths, fallback: false }; // fallback options explained below
};

// Fetch data for each page at build time
export const getStaticProps: GetStaticProps<PostPageProps> = async ({
  params,
}) => {
  const res = await fetch(
    `https://jsonplaceholder.typicode.com/posts/${params?.id}`
  );
  const post: Post = await res.json();

  return {
    props: { post },
    revalidate: 60, // ISR: Regenerate page every 60 seconds
  };
};
```

1. `getStaticPaths` → Defines which post pages should be generated.
2. `getStaticProps` → Fetches data for each page at build time.
3. Pages are pre-built as static HTML + JSON.
4. `revalidate: 60` → Enables ISR (page will regenerate every 60s when requested).

**Why SSG is the Right Choice Here**

- Blog posts and product pages don’t change per user.
- SEO matters (content should be indexed).
- Pages load super fast (served from CDN).
- Updates are infrequent, so build time or ISR is acceptable.

## `getStaticProps` Explained

- Runs at build time (server-side only).
- Fetches data for a page and passes it as props.
- Only works in page components, not regular components.

### Step-by-step:

1. Create a page component.
2. Export async `function getStaticProps()`.
3. Fetch data from API, database, or filesystem.
4. Return `{ props: { ... } }`.
5. Next.js pre-renders the page as static HTML.
6. On client load, React hydrates the page for interactivity.

## `getStaticPaths` Explained

- Used with dynamic routes (e.g., `[id].tsx`).
- Tells Next.js which paths to pre-render.

### Step-by-step:

1. Create a dynamic route (`[id].tsx`).
2. Export `async function getStaticPaths()`.
3. Fetch all dynamic entries (e.g., posts).
4. Return `{ paths: [...], fallback: ... }`.
5. Next.js pre-renders those paths with `getStaticProps`.

### `fallback` Options

| fallback value | Behavior                                                                                                                                             |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| `false`        | Only pre-rendered paths exist. Any other path → 404.                                                                                                 |
| `true`         | New paths are generated on-demand. The client sees a **loading state** (`router.isFallback`) while the page is being built.                          |
| `"blocking"`   | New paths are generated on-demand **server-side before sending HTML**. The user **does not see a loading state**; they wait until the page is ready. |

### Alternatives of SSG

1. Server-Side Rendering (SSR):

   ```ts
   export async function getServerSideProps({ params }) {
     const res = await fetch(`https://api.example.com/posts/${params.id}`);
     const post = await res.json();
     return { props: { post } };
   }
   ```

   - Runs on every request.
   - No need for `getStaticPaths`.

2. Client-Side Fetching (CSR):

   - Fetch data in a component using `useEffect`.
   - Slower initial load, poor SEO.
