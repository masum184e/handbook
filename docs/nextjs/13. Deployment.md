---
title: Deployment
sidebar_position: 15
---

## Vercel

Handles serverless API routes, ISR (Incremental Static Regeneration), and Edge Functions out-of-the-box.

- Vercel installs dependencies (npm install)
- Builds Next.js (npm run build)
- Deploys:
  - Static pages (SSG) → served via CDN
  - API routes → deployed as serverless functions
  - Middleware → deployed as edge functions

## Environment Variables

- Variables prefixed with `NEXT_PUBLIC_` are exposed to the browser.
- Variables without `NEXT_PUBLIC_` are server-only and never exposed client-side.

```env
NEXT_PUBLIC_API_URL=https://api.example.com    # accessible in browser
DATABASE_URL=postgres://user:pass@host:5432/db   # server-only
JWT_SECRET=mysecretkey                           # server-only
```

## Optimizing the build process

### What is `next build`

`next build` is the Next.js build command that prepares your app for production. It performs:

1. Compiling JavaScript and TypeScript

2. Generating static assets for SSG pages

3. Creating server-side rendered (SSR) pages

4. Optimizing images, CSS, and other assets

5. Tree-shaking and minifying code for production

Optimizing this process ensures faster builds, smaller bundles, and better performance.

### Strategies to Optimize Next.js Build

#### Analyze Bundle Size

Large bundles slow down both build and runtime. Use Webpack bundle analyzer:

```ts
npm install @next/bundle-analyzer
```

`next.config.js`:

```ts
const withBundleAnalyzer = require("@next/bundle-analyzer")({
  enabled: process.env.ANALYZE === "true",
});

module.exports = withBundleAnalyzer({});
```

Run analysis:

```bash
ANALYZE=true next build
```

- Helps identify heavy dependencies.
- Allows code-splitting and dynamic imports for large components.

#### Use Dynamic Imports

For large components or libraries, use dynamic imports:

```tsx
import dynamic from "next/dynamic";

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
  ssr: false, // optional: render only on client
});
```

- Reduces initial JS bundle size.
- Improves Time to Interactive (TTI).

#### Cache Dependencies in CI/CD

In Vercel, Netlify, or GitHub Actions, caching `node_modules` or `.next/cache` speeds up builds.

GitHub Actions Example:

```yaml
- name: Cache node modules
  uses: actions/cache@v2
  with:
    path: ~/.npm
    key: ${{ runner.os }}-node-${{ hashFiles('package-lock.json') }}
```

#### Enable SWC Minification

Next.js uses SWC compiler by default. Ensure minification is enabled:

```ts
// next.config.js
module.exports = {
  swcMinify: true,
};
```

- Faster than Terser
- Produces smaller JS bundles

#### Static Generation Where Possible

- Use SSG (`getStaticProps`) instead of SSR (`getServerSideProps`) when data is mostly static.
- SSG allows pre-rendering at build time, reducing runtime server load.

```ts
export async function getStaticProps() {
  const res = await fetch("https://api.example.com/posts");
  const posts = await res.json();

  return { props: { posts }, revalidate: 60 }; // ISR
}
```

ISR updates pages incrementally without rebuilding the whole site.
