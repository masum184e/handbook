---
title: Performance Optimization
sidebar_position: 10
---

## Lazy Loading

- Lazy loading (or dynamic importing) is a way to defer loading of non-critical code until it’s actually needed.
- Useful for:
  - Heavy components (charts, maps, editors, video players)
  - Rarely used UI parts (modals, sidebars)
  - Third-party libraries

### How Next.js Supports Lazy Loading

Next.js provides a built-in function `next/dynamic` to load components lazily.

```ts
import dynamic from "next/dynamic";

const Chart = dynamic(() => import("../components/Chart"));
```

By default:

- `Chart` will not be included in the initial JavaScript bundle.
- It will be loaded only when rendered.
  `pages/dashboard.ts`

```ts
import dynamic from "next/dynamic";

// Lazy load the Chart component
const Chart = dynamic(() => import("../components/Chart"), {
  loading: () => <p>Loading chart...</p>, // Optional fallback
  ssr: false, // Disable server-side rendering for client-only libs
});

export default function Dashboard() {
  return (
    <div>
      <h1>Welcome to Dashboard</h1>
      <p>User Info: John Doe</p>

      {/* Chart loads only when this line is rendered */}
      <Chart />
    </div>
  );
}
```

1. The initial load only includes Dashboard’s basic UI (small bundle).
2. The `Chart` code is split into a separate bundle.
3. When the Dashboard renders `<Chart />`, Next.js dynamically fetches that bundle.
4. The user sees `"Loading chart..."` until the Chart is ready.

## Prefetching

- Prefetching means downloading resources (like code or data) for future navigation before the user explicitly requests them.
- This makes navigations faster because Next.js already has the JavaScript bundle and/or data ready.

### How Next.js Handles Prefetching

- By default, when you use the built-in `<Link>` component, Next.js prefetches the JS bundle for the linked page when it appears in the viewport.
- This is done using `<link rel="prefetch">`.

Result: The next page loads almost instantly when the user clicks.

**Prefetching Page Bundles**

```ts
import Link from "next/link";

export default function Home() {
  return (
    <div>
      <h1>Home Page</h1>

      {/* Next.js automatically prefetches About.js bundle */}
      <Link href="/about">Go to About</Link>
    </div>
  );
}
```

1. When `<Link>` is visible in the viewport, Next.js prefetches `about.js` in the background.

2. When the user clicks, navigation is instant—no waiting for network fetch.

**Prefetch Control**

- Prefetch is enabled by default in production (not in dev mode).
- You can disable it if you don’t want background prefetching:

```tsx
<Link href="/about" prefetch={false}>
  Go to About
</Link>
```

## Preloading

- While prefetching handles the JS bundle, preloading data means fetching server-side or client-side data ahead of time so it’s ready when needed.
- Useful for:
  - Pages that need API data
  - Avoiding loading spinners on navigation

Next.js provides multiple strategies to preload both data and components, depending on where your data lives and how you fetch it.

### Preloading Data with `getStaticProps` + Link Prefetch

When a page uses Static Generation (`getStaticProps`), Next.js can prefetch both the JavaScript bundle and the JSON data in advance when using `<Link>`.

**Example: Blog Posts**

`pages/blog/[id].js`

```tsx
export async function getStaticProps({ params }) {
  const res = await fetch(
    `https://jsonplaceholder.typicode.com/posts/${params.id}`
  );
  const post = await res.json();

  return { props: { post } };
}

export async function getStaticPaths() {
  const res = await fetch(
    `https://jsonplaceholder.typicode.com/posts?_limit=5`
  );
  const posts = await res.json();

  return {
    paths: posts.map((p) => ({ params: { id: p.id.toString() } })),
    fallback: false,
  };
}

export default function BlogPost({ post }) {
  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
    </div>
  );
}
```

`pages/index.js`

```tsx
import Link from "next/link";

export default function Home({ posts }) {
  return (
    <div>
      <h1>Blog</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>
            {/* Prefetches both JS + JSON data */}
            <Link href={`/blog/${post.id}`}>{post.title}</Link>
          </li>
        ))}
      </ul>
    </div>
  );
}

export async function getStaticProps() {
  const res = await fetch(
    "https://jsonplaceholder.typicode.com/posts?_limit=5"
  );
  const posts = await res.json();
  return { props: { posts } };
}
```

**What gets preloaded?**

- The `blog/[id].ts` JavaScript bundle
- The JSON data file generated by getStaticProps

### Preloading Data with SWR / React Query

For client-side fetching, you can preload queries so that data is available immediately when the component renders.

```tsx
import useSWR, { preload } from "swr";

const fetcher = (url) => fetch(url).then((r) => r.json());

export default function Dashboard() {
  // Preload the data
  preload("/api/user", fetcher);

  // When rendered, it instantly has cached data
  const { data, error } = useSWR("/api/user", fetcher);

  if (error) return <p>Error loading</p>;
  if (!data) return <p>Loading...</p>;

  return <div>Welcome, {data.name}!</div>;
}
```

- `preload()` fetches the data in advance.
- When `<Dashboard />` renders, SWR already has the data → no spinner.

### Preloading Components with `next/dynamic`

You can also preload heavy components before user action:

```tsx
import dynamic from "next/dynamic";

const Chart = dynamic(() => import("../components/Chart"));

Chart.preload(); // Preloads the component

export default function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      {/* Chart loads instantly since it was preloaded */}
      <Chart />
    </div>
  );
}
```

Useful for charts, editors, or other expensive components.

### Prefetching vs Preloading Data

| Feature                | Prefetching                                  | Preloading Data                             |
| ---------------------- | -------------------------------------------- | ------------------------------------------- |
| **What it loads**      | Page JS bundles (+ static JSON if available) | API data, components, or resources          |
| **When it happens**    | When link/component enters viewport          | When you explicitly trigger preload         |
| **Default in Next.js** | Enabled with `<Link>` in production          | Manual (SWR, React Query, preload())        |
| **Goal**               | Faster navigation to new page                | Faster rendering with ready data/components |

- Prefetching: Automatic with `<Link>` → speeds up page navigation.
- Preloading Data: Manual (via `getStaticProps`, SWR, or `preload`) → avoids loading spinners.
- Combine both for blazing-fast navigation:
  - Prefetch the page bundle + static data
  - Preload client-side queries or components

## Performance Challenges in SSR

- Every request triggers: Server fetch → render React → send HTML + JSON → hydrate on client.

- Bottlenecks:
  - Expensive DB/API queries
  - Unnecessary recomputation
  - Blocking the event loop
- Slow SSR = high Time to First Byte (TTFB)

**Optimizations for SSR**

1. Cache responses (HTTP caching, CDN, or Next.js middleware).

2. Use Incremental Static Regeneration (ISR) if real-time freshness isn’t needed.

3. Stream HTML (React 18 SSR streaming in App Router).

4. Reduce server payload size (strip unused data).

5. Parallelize data fetching with `Promise.all`.

```tsx
export async function getServerSideProps() {
  // Parallel fetching
  const [headlines, weather] = await Promise.all([
    fetch("https://newsapi.org/v2/top-headlines?country=us").then((r) =>
      r.json()
    ),
    fetch("https://api.weatherapi.com/v1/current.json?q=New York").then((r) =>
      r.json()
    ),
  ]);

  return {
    props: { headlines, weather },
  };
}

export default function News({ headlines, weather }) {
  return <DisplayWeatherData />;
}
```

- `Promise.all` → avoids sequential fetches.
- Page served fresh per request.
- Can be paired with server/CDN caching to reduce load.

## Performance Challenges in CSR

- Slower first paint (empty HTML shell at start).
- Extra network requests after page load.
- Bad for SEO if search engines can’t wait for hydration.

**Optimizations for CSR**

1. Lazy-load non-critical components (`next/dynamic`).
2. Preload client data (SWR `preload`, React Query `prefetchQuery`).
3. Use Suspense (React 18 streaming + Suspense boundaries).
4. Cache data locally (SWR/React Query) to avoid refetching.
5. Split bundles so only critical JS loads first.

```ts
import useSWR from "swr";

const fetcher = (url) => fetch(url).then((res) => res.json());

export default function Dashboard() {
  // SWR caches and reuses data
  const { data, error } = useSWR("/api/user", fetcher, {
    revalidateOnFocus: false,
    dedupingInterval: 10000, // Cache data for 10s
  });

  if (error) return <p>Error loading dashboard</p>;
  if (!data) return <p>Loading...</p>;

  return (
    <div>
      <h1>Welcome, {data.name}</h1>
      <p>Account Balance: ${data.balance}</p>
    </div>
  );
}
```

- Uses SWR to cache API data.
- Prevents redundant fetches with `dedupingInterval`.
- Only user-specific data is fetched on client.

### When to Use SSR vs CSR (Performance Trade-offs)

| Feature           | Server-Side Rendering (SSR)  | Client-Side Rendering (CSR)      |
| ----------------- | ---------------------------- | -------------------------------- |
| **First Load**    | Faster (HTML pre-rendered)   | Slower (empty shell first)       |
| **SEO**           | Great for SEO                | Not SEO-friendly                 |
| **Freshness**     | Always fresh                 | Depends on client fetch          |
| **Server Load**   | Higher (compute per request) | Lower (server just serves shell) |
| **Best Use Case** | Public pages, SEO content    | User-specific dashboards, apps   |

Next.js allows mixing SSR + CSR:

- Use SSR for initial render (SEO + fast paint).
- Use CSR for interactive updates.

```ts
import useSWR from "swr";

export async function getServerSideProps() {
  const res = await fetch("https://api.example.com/posts");
  const initialPosts = await res.json();
  return { props: { initialPosts } };
}

export default function Posts({ initialPosts }) {
  const { data } = useSWR(
    "/api/posts",
    (url) => fetch(url).then((r) => r.json()),
    {
      fallbackData: initialPosts,
      refreshInterval: 10000, // Keep data fresh
    }
  );

  return (
    <div>
      <h1>Latest Posts</h1>
      <ul>
        {data.map((p) => (
          <li key={p.id}>{p.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

- Page first renders with SSR (fast + SEO).
- SWR then hydrates with fresh data in background (CSR).
- The user sees fast + always up-to-date content.
