---
title: Incremental Site Rendering
sidebar_position: 6
---

Normally in Static Site Generation (SSG), all pages are pre-rendered at build time.
But this creates a problem:

- If your data changes frequently (like blog posts, product prices, news articles), the static pages become outdated unless you rebuild the whole app.

ISR solves this by allowing you to update static pages in the background without rebuilding the entire site.

With ISR:

- Pages are generated once at build time (like SSG).
- After deployment, if the data changes, the pages can be incrementally regenerated on the server.
- Users see cached (old) pages until regeneration is done in the background, then the new static version replaces it.

## How ISR Works

With ISR:

1. Pages are generated at build time like SSG.
2. After deployment, pages can be regenerated incrementally on the server when data changes.
3. Users see the cached old page until regeneration finishes.
4. Once regeneration is complete, the new static page replaces the old version automatically.

The key to ISR is the `revalidate` property in `getStaticProps`.

```
revalidate: N
```

- The page is cached for N seconds.
- After N seconds, the next request triggers regeneration in the background.
- While regenerating, users still see the old page (no downtime).
- After regeneration, the new page replaces the old page for future requests.

## How to Use ISR

```tsx
// pages/blog/[id].tsx
import { GetStaticPaths, GetStaticProps, NextPage } from "next";
import { useRouter } from "next/router";

type Post = {
  id: string;
  title: string;
  body: string;
};

interface BlogPostProps {
  post: Post;
}

const BlogPost: NextPage<BlogPostProps> = ({ post }) => {
  const router = useRouter();

  // Show loading state if fallback page is being generated
  if (router.isFallback) {
    return <p>Loading...</p>;
  }

  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold">{post.title}</h1>
      <p className="mt-4">{post.body}</p>
      <small>Last updated: {new Date().toLocaleTimeString()}</small>
    </div>
  );
};

export default BlogPost;

// Pre-generate some blog pages at build time
export const getStaticPaths: GetStaticPaths = async () => {
  const posts: Post[] = await fetch(
    "https://jsonplaceholder.typicode.com/posts?_limit=5"
  ).then((res) => res.json());

  const paths = posts.map((post) => ({
    params: { id: post.id.toString() },
  }));

  return {
    paths,
    fallback: "blocking", // Other pages generated on-demand with ISR
  };
};

// Fetch data and enable ISR
export const getStaticProps: GetStaticProps<BlogPostProps> = async ({
  params,
}) => {
  const post: Post = await fetch(
    `https://jsonplaceholder.typicode.com/posts/${params?.id}`
  ).then((res) => res.json());

  return {
    props: { post },
    revalidate: 10, // Regenerate page in the background every 10 seconds
  };
};
```

1. `getStaticPaths`
   - Pre-generates a few pages at build time (`/blog/1`, `/blog/2`, …).
   - Other pages are generated on-demand via `fallback: "blocking"`.
2. `getStaticProps` with `revalidate`
   - Page is cached and served for `revalidate` seconds.
   - After that, the next request triggers background regeneration.
   - Users see the old page while regeneration occurs.
   - Once done, the new page replaces the old one.
3. User experience
   - Pages load fast (static).
   - Data is relatively fresh without rebuilding the entire site.

## When to Use ISR

**Good for:**

- Blogs, news sites, product listings, documentation
- Data that changes often but not on every request
- Apps where rebuilding the whole site is slow or expensive

**Not ideal for:**

- Real-time data (stock prices, chat apps, dashboards → use SSR or CSR instead).

# Server-Side Rendering

Server-Side Rendering (SSR) means that the HTML for a page is generated on each request at runtime on the server. The server fetches the data, renders the React components into HTML, and then sends the fully rendered page to the client.

- The client receives a ready-to-view HTML page.
- After the initial render, React hydrates the page and takes over for interactivity.
- Every request triggers server-side data fetching and rendering.

In Next.js, SSR is used when:

1. You need dynamic content that changes per request.
2. SEO is important (search engines see the full HTML).
3. You can’t pre-render at build time (data changes too often).
4. You want fresh data on every page load.

## How SSR Works

1. User requests a page.

2. Next.js runs `getServerSideProps` on the server at request time.

3. Server fetches data → generates HTML.

4. Server sends HTML to browser → user sees fully rendered page.

5. React hydrates → adds interactivity.

## Best use cases for SSR

1. Dynamic, real-time content

   - Example: Stock prices, sports scores, live auctions.

2. SEO-sensitive pages with changing data

   - Example: News sites, event listings.

3. Personalized pages

   - Example: User-specific dashboards that must be indexed.

4. Authenticated pages

   - Example: Profile pages, order histories (when SEO is still needed).

**Advantages**

- Always fresh data (fetched at request time).
- SEO-friendly (full HTML delivered).
- Supports personalization (different users → different content).
- No rebuilds needed for data changes.

**Disadvantages**

- Slower response than SSG (server must fetch + render each request).
- Higher server load (compute required per request).
- Not as fast as CDN-served static files.
- Scaling requires more server resources.

## Data Fetching in SSR

- Use `getServerSideProps` → Runs on every request.
- Data is fetched at runtime → passed to the page as props.
- Unlike SSG, nothing is pre-built at build time.

## How to Use SSR

In Next.js, define `getServerSideProps` in your page component.

```tsx
// pages/profile.tsx

import { GetServerSideProps } from "next";

type User = {
  id: number;
  name: string;
  email: string;
};

export default function Profile({ user }: { user: User }) {
  return (
    <div className="p-6">
      <h1 className="text-xl font-bold">Server-Side Rendered Profile</h1>
      <p>
        <strong>ID:</strong> {user.id}
      </p>
      <p>
        <strong>Name:</strong> {user.name}
      </p>
      <p>
        <strong>Email:</strong> {user.email}
      </p>
    </div>
  );
}

export const getServerSideProps: GetServerSideProps = async () => {
  const res = await fetch("https://jsonplaceholder.typicode.com/users/1");
  const user: User = await res.json();

  return {
    props: { user }, // Sent to the component
  };
};
```

1. `getServerSideProps` → Runs on every request.
2. Server fetches the latest user data.
3. Page is rendered into HTML on the server.
4. User immediately sees a fully rendered profile page.

**Why SSR is the Right Choice Here**

- Profile data changes often → Needs fresh fetch each time.
- SEO matters → Profile pages should be indexed.
- Server can fetch + render the data on demand.
- Unlike CSR, the user doesn’t see a loading spinner first.
