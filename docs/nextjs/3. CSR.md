---
title: Client Side Rendering
sidebar_position: 3
---

Client-Side Rendering (CSR) means that a page’s HTML is mostly empty on initial load, and the actual rendering happens in the browser using JavaScript.

- The server sends a minimal HTML file with a `<div id="__next"></div>` container.
- The browser downloads and executes the bundled React JavaScript code.
- The React code runs inside the user’s browser, fetches data (if needed), and renders components dynamically.
- The page loads slowly at first, but once everything is loaded, navigating between pages becomes very fast.

In Next.js, CSR is used when:

1. You want dynamic content that should be rendered after the page loads.
2. You don’t need SEO for that particular page (because search engines might not see the content immediately).
3. You fetch data inside `useEffect` or from client-side hooks instead of server-side functions.

## How CSR Works

1. **Browser Requests the Page:** The user enters a URL in the browser (e.g., `https://example.com`).
2. **Server Responds with Minimal HTML:** The server responds with a lightweight HTML and Javscripts file.

   ```html
   <!DOCTYPE html>
   <html lang="en">
     <head>
       <meta charset="UTF-8" />
       <meta name="viewport" content="width=device-width, initial-scale=1.0" />
       <title>CSR Example</title>
     </head>
     <body>
       <div id="root"></div>
       <!-- This is where React inserts the content -->
       <script src="bundle.js"></script>
       <!-- JavaScript file that builds the page -->
     </body>
   </html>
   ```

   At this point, the page is still empty! The content is missing because JavaScript hasn’t run yet.

3. **Browser Downloads JavaScript File:**

   - The browser loads bundle.js, which contains the React app.
   - React runs and fetches the blog post from an API.

4. **JavaScript Fetches Data and Updates the Page:**

   ```tsx
   import React, { useState, useEffect } from "react";

   function BlogPost() {
     const [data, setData] = useState(null);

     useEffect(() => {
       fetch("https://jsonplaceholder.typicode.com/posts/1") // API call
         .then((response) => response.json())
         .then((json) => setData(json)); // Set data
     }, []);

     return (
       <div>
         <h1>Client-Side Rendering Example</h1>
         {data ? <h2>{data.title}</h2> : <p>Loading...</p>}
       </div>
     );
   }

   export default BlogPost;
   ```

5. **Content is Rendered in the Browser:** The fetched data is used to dynamically generate and update the page's content.
6. **User Interacts with the Page:** Since the page is now fully loaded in the browser, interactions like clicking buttons or navigating between pages happen instantly without needing a full page reload.

## Best use cases for CSR

1. Dynamic user-specific data
   - Example: A user dashboard (orders, messages, profile) where content is unique to the logged-in user.
   - Data shouldn’t be cached or indexed by search engines.
2. Highly interactive UI

   - Example: Chat apps, dashboards, or data that frequently updates.

3. Non-SEO critical pages

   - Example: Admin panels, analytics dashboards, or user settings.
   - Since content isn’t indexed, SEO doesn’t matter.

4. Third-party client-side SDKs

   - Example: Fetching data from Firebase, Stripe, or Auth0 where tokens are managed on the client.

5. Real-time data

   - Example: Stock prices, live sports scores, notifications.

**Advantages**

- Good for dynamic content (like dashboards, user-specific data).
- Lighter server load (server just sends shell).
- Better for highly interactive apps (like SPAs).
- Good for personalized dashboards and apps.
- Server doesn’t need to fetch/render user-specific content.
- Works well with APIs requiring authentication.

**Disadvantages**

- Slower First Contentful Paint (FCP) (user sees loading spinner).
- Not SEO friendly, since bots may not see dynamic content immediately.
- Depends on JavaScript being enabled in the browser.

## Data Fetching in CSR

When using Client-Side Rendering (CSR) in Next.js, data fetching happens inside the browser, not on the server.

- The server only returns a minimal HTML shell.
- After the page loads, React runs in the browser.
- React hooks like `useEffect` and `useState` are used to fetch and display the data.

## How to Use CSR

In Next.js, CSR means skipping server-side data fetching (`getServerSideProps`, `getStaticProps`) and instead fetching data inside the component with `useEffect`.

Steps:

1. Render a basic HTML shell from the server.

2. Inside the component, use React hooks (`useEffect`, `useState`) to fetch data.

3. Update the UI once the data arrives.

In App Router (Next.js 13+ with `app/` directory), mark components with `"use client"` if they rely on state, effects, or event listeners.

```tsx
// pages/users/profile.tsx
"use client";

import { useEffect, useState } from "react";

type User = {
  id: number;
  name: string;
  email: string;
};

export default function Dashboard() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  // Fetch user data after component mounts (CSR)
  useEffect(() => {
    async function fetchUser() {
      try {
        const res = await fetch("https://jsonplaceholder.typicode.com/users/1");
        const data = await res.json();
        setUser(data);
      } catch (err) {
        console.error("Failed to fetch user", err);
      } finally {
        setLoading(false);
      }
    }
    fetchUser();
  }, []);

  if (loading) return <p>Loading user dashboard...</p>;

  return (
    <div className="p-6">
      <h1 className="text-xl font-bold">Client-Side Rendered Dashboard</h1>
      {user ? (
        <div className="mt-4">
          <p>
            <strong>ID:</strong> {user.id}
          </p>
          <p>
            <strong>Name:</strong> {user.name}
          </p>
          <p>
            <strong>Email:</strong> {user.email}
          </p>
        </div>
      ) : (
        <p>Failed to load user data</p>
      )}
    </div>
  );
}
```

1. `use client` → Marks this as a client component.
2. `useEffect` ensures the data is fetched after the page loads (in the browser).
3. `loading` state → Shows a loading message until data is ready.
4. On first request, the user sees:

   ```html
   <div id="__next">
     <p>Loading user dashboard...</p>
   </div>
   ```

5. Then, the browser fetches users from the API and updates the DOM with React.

- This is CSR, because:
  - No posts are pre-rendered on the server.
  - All rendering happens in the client’s browser.

**Why CSR is the Right Choice Here**

- The user’s profile is private → No need for SEO or server-side pre-rendering.
- Data is dynamic → Changes per logged-in user.
- Reduces server load → Next.js just sends the shell, client does the rest.

## How to Combine CSR with SSR/SSG

- Use SSR/SSG for the base page (`getServerSideProps` or `getStaticProps`).
- Use CSR (`useEffect` + `useState`) for parts of the page that need client-side fetching

**Example**

```tsx
"use client"; // For app directory in Next.js 13+, not needed in pages dir

import { useEffect, useState } from "react";

// ---------- Server-side Rendering ----------
export async function getServerSideProps(context) {
  const { id } = context.params;
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`);
  const post = await res.json();

  return {
    props: { post }, // passed to component as props
  };
}

// ---------- Page Component ----------
export default function BlogPost({ post }) {
  // CSR states for comments
  const [comments, setComments] = useState([]);
  const [loading, setLoading] = useState(true);

  // ---------- Client-side Rendering for Comments ----------
  useEffect(() => {
    async function fetchComments() {
      const res = await fetch(
        `https://jsonplaceholder.typicode.com/posts/${post.id}/comments`
      );
      const data = await res.json();
      setComments(data);
      setLoading(false);
    }

    fetchComments();
  }, [post.id]);

  return (
    <div>
      {/* SSR Content */}
      <h1>{post.title}</h1>
      <p>{post.body}</p>

      {/* CSR Content */}
      <h2>Comments</h2>
      {loading ? (
        <p>Loading comments...</p>
      ) : (
        <ul>
          {comments.slice(0, 3).map((comment) => (
            <li key={comment.id}>
              <strong>{comment.name}</strong>: {comment.body}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```
