---
title: Error Handling
sidebar_position: 19
---

## Custom Error Pages

### App Router

#### `error.tsx`

- Works like a React error boundary.
- Automatically catches both server and client-side errors inside the same route segment.
- Receives two props:
  - `error` → The actual error object.
  - `reset` → A function to retry rendering.

```tsx
// app/dashboard/error.tsx
"use client";

export default function DashboardError({
  error,
  reset,
}: {
  error: Error;
  reset: () => void;
}) {
  return (
    <div style={{ padding: "20px", background: "#fee" }}>
      <h2>Oops, dashboard failed!</h2>
      <p>{error.message}</p>
      <button onClick={() => reset()}>Try again</button>
    </div>
  );
}
```

This overrides the default Next.js error overlay for just `/dashboard`.

Even though your `error.tsx` is a Client Component, it still handles server-side errors.

1. **Rendering starts on the server**
   - If something fails during server rendering (e.g., DB query throws, fetch fails, code bug), Next.js catches it.
2. **Error is serialized and sent to the client**
   - Next.js passes the `error` object (with its `.message`) into your `error.tsx` component.
3. **Your `error.tsx` runs in the browser**
   - That’s why `"use client"` is required: you get the `error` and a `reset()` function to retry rendering.

#### `not-found.tsx`

- Used to define custom 404 pages (missing routes or resources).
- Can be per-route or global.
- Works with the `notFound()` helper function from `next/navigation`.
- It wont't work if `notFound()` explicityl triggered, both for global and route level.

```tsx
// app/not-found.tsx (global 404)
export default function GlobalNotFound() {
  return (
    <div style={{ padding: "20px", background: "#eef" }}>
      <h1>404 - Page Not Found</h1>
      <p>Sorry, we couldn’t find the page you’re looking for.</p>
    </div>
  );
}
```

Now, in any route, you can trigger it manually:

```tsx
// app/blog/[id]/page.tsx
import { notFound } from "next/navigation";

export default function BlogPost({ params }: { params: { id: string } }) {
  if (params.id !== "123") {
    notFound();
  }

  return <h1>Blog Post {params.id}</h1>;
}
```

#### `global-error.tsx`

- Acts as a root-level error boundary.
- Catches any uncaught errors across the entire app.
- Unlike `error.tsx`, you must include `<html>` and `<body>`.
- It only catches errors during the initial render / top-level hydration, not route errors.
- Almost never fires in day-to-day development, so it feels “dead code” until something catastrophic happens.

```tsx
// app/global-error.tsx
"use client";

export default function GlobalError({
  error,
  reset,
}: {
  error: Error;
  reset: () => void;
}) {
  return (
    <html>
      <body style={{ padding: "20px", background: "#fdd" }}>
        <h2>Global error occurred!</h2>
        <p>{error.message}</p>
        <button onClick={() => reset()}>Try again</button>
      </body>
    </html>
  );
}
```

### Pages Router

#### `pages/_error.js`

- A fallback for both SSR errors and CSR runtime errors.
- Receives `statusCode` as a prop.
- You can customize based on whether it’s `404`, `500`, etc.

```js
// pages/_error.js
function Error({ statusCode }) {
  return (
    <div style={{ padding: "20px", background: "#fee" }}>
      <h1>{statusCode ? `Error ${statusCode}` : "An error occurred"}</h1>
      <p>Something went wrong on our end.</p>
    </div>
  );
}

Error.getInitialProps = ({ res, err }) => {
  const statusCode = res ? res.statusCode : err ? err.statusCode : 404;
  return { statusCode };
};

export default Error;
```

This replaces the default Next.js error screen globally.

#### `pages/404.js`

- A dedicated page for handling 404 errors.
- Automatically rendered if no route matches.

```js
// pages/404.js
export default function Custom404() {
  return (
    <div style={{ padding: "20px", background: "#eef" }}>
      <h1>404 - Page Not Found</h1>
      <p>The page you requested does not exist.</p>
    </div>
  );
}
```

#### `pages/500.js`

- Optional.
- Handles server-side errors (500-level).
- Displayed when an SSR request crashes.

```js
// pages/500.js
export default function Custom500() {
  return (
    <div style={{ padding: "20px", background: "#fdd" }}>
      <h1>500 - Server-side Error</h1>
      <p>Sorry, something broke on our server.</p>
    </div>
  );
}
```

## Error Boundaries

### App Router

In the App Router (Next.js 13+), you don’t usually need to create your own error boundary, because Next.js provides built-in error boundaries via special files:

- `error.tsx` → Per-route error boundary.
- `global-error.tsx` → Root-level fallback.

These act like React error boundaries, but you don’t write a class component manually. Instead, you just create the special file.

#### Route-level error boundary

Imagine a dashboard page with a client component that might throw an error:

```tsx
// app/dashboard/ClientComponent.tsx
"use client";

export default function ClientComponent() {
  const handleClick = () => {
    throw new Error("Button action failed!");
  };

  return <button onClick={handleClick}>Click me</button>;
}
```

Now add a route-level error boundary:

```tsx
// app/dashboard/error.tsx
"use client";

export default function DashboardError({
  error,
  reset,
}: {
  error: Error;
  reset: () => void;
}) {
  return (
    <div style={{ padding: "20px", background: "#fee" }}>
      <h2>Something went wrong in Dashboard!</h2>
      <p>{error.message}</p>
      <button onClick={() => reset()}>Try again</button>
    </div>
  );
}
```

- If the button throws an error, instead of crashing the entire app, `error.tsx` shows the fallback UI.
- Clicking Try again calls `reset()`, which re-renders the segment.

#### Global error boundary

- If you want a single error page for the entire app use `gloabal-error.tsx`

### Pages Router

In the Pages Router, Next.js does not provide built-in React error boundaries.

- `pages/_error.js` handles SSR and generic errors, but not runtime errors in React components.
- So you must create your own error boundary using React’s `componentDidCatch` or `getDerivedStateFromError`.

#### Custom ErrorBoundary component

```tsx
// components/ErrorBoundary.js
import React from "react";

export default class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    // Update state so the next render shows fallback UI
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    // Log error to monitoring service if needed
    console.error("ErrorBoundary caught:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div style={{ padding: "20px", background: "#fee" }}>
          <h2>Something went wrong!</h2>
          <p>{this.state.error?.message}</p>
        </div>
      );
    }
    return this.props.children;
  }
}
```

Usage in a page

```tsx
// pages/dashboard.js
import ErrorBoundary from "../components/ErrorBoundary";

function ClientComponent() {
  const handleClick = () => {
    throw new Error("Crash in client component!");
  };

  return <button onClick={handleClick}>Crash me</button>;
}

export default function DashboardPage() {
  return (
    <ErrorBoundary>
      <h1>Dashboard</h1>
      <ClientComponent />
    </ErrorBoundary>
  );
}
```

- If the button throws an error, the `ErrorBoundary` component catches it and renders fallback UI.
- Without it, the entire app would unmount in the client.

## Errors in SSR

### App Router

- When rendering a server component or fetching data via `fetch()` inside `page.js` or `layout.js`, errors can happen.
- If an error occurs during SSR:
  - Next.js will automatically catch it.
  - It will show your `error.js` file (local error boundary) if present.
  - If no local boundary exists, the error bubbles up to the nearest parent error boundary.
  - If none exist, the global error page is shown.

Define an error boundary:

```tsx
// app/dashboard/error.tsx
"use client";

export default function DashboardError({
  error,
  reset,
}: {
  error: Error;
  reset: () => void;
}) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <p>{error.message}</p>
      <button onClick={() => reset()}>Try again</button>
    </div>
  );
}
```

- On first SSR render, the error is caught and shown via `error.tsx`.
- If a client-side navigation later hits the same error, it’s also caught here.

### Pages Router

- Errors during SSR typically occur in: `getServerSideProps`, `getStaticProps`
- If you throw an error, Next.js will render the error page (pages/\_error.js).

```ts
// pages/dashboard.js
export async function getServerSideProps() {
  try {
    const res = await fetch("https://api.example.com/data");

    if (!res.ok) {
      throw new Error("Failed to fetch data");
    }

    const data = await res.json();
    return { props: { data } };
  } catch (err) {
    return {
      notFound: true, // or redirect to custom error page
    };
  }
}
```

- Return `{ notFound: true }` → show `404`.
- Return `{ redirect: { destination: "/error" } }` → redirect.
- Or let Next.js show `_error.js`.

## Errors in CSR

### App Router

Errors can occur during:

- Client navigation (moving between pages with `Link`).
- Client components (event handlers, React hooks, etc.).
- Since App Router uses React error boundaries, the same `error.tsx` will catch them.

```tsx
// app/dashboard/ClientComponent.tsx
"use client";

export default function ClientComponent() {
  const handleClick = () => {
    throw new Error("Button click failed!");
  };

  return <button onClick={handleClick}>Break me</button>;
}
```

If the button is clicked, the error will be caught by the nearest `error.tsx`.

### Pages Router

For client-side errors (button clicks, component crashes, navigation issues), you must use React error boundaries manually.
