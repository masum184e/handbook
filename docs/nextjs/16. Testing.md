---
title: Testing
sidebar_position: 18
---

Jest is a popular JavaScript testing framework:

- Built-in test runner and assertion library.
- Excellent TypeScript support.
- Works seamlessly with React and Next.js.
- Can be extended with React Testing Library for user-focused component testing.

## Utility Function Testing

### Installing Dependencies

Install Jest and TypeScript helpers:

```bash
npm install --save-dev jest @types/jest ts-jest
```

### Configuring Jest

Create a `jest.config.ts` file at the root:

```ts
import nextJest from "next/jest.js";

const createJestConfig = nextJest({
  dir: "./",
});

const customJestConfig = {
  setupFilesAfterEnv: ["<rootDir>/jest.setup.ts"],
  testEnvironment: "jest-environment-jsdom",
  moduleNameMapper: {
    "^@/(.*)$": "<rootDir>/src/$1",
  },
};

export default createJestConfig(customJestConfig);
```

### Utility Function

## Component Testing

Suppose you have a simple math utility:

```ts
// src/utils/math.ts
export const add = (a: number, b: number): number => a + b;
export const subtract = (a: number, b: number): number => a - b;
```

Create a test file: `src/utils/math.test.ts`

```ts
import { add, subtract } from "./math";

describe("Math Utilities", () => {
  it("adds two numbers correctly", () => {
    expect(add(2, 3)).toBe(5);
    expect(add(-2, -3)).toBe(-5);
  });

  it("subtracts two numbers correctly", () => {
    expect(subtract(5, 3)).toBe(2);
    expect(subtract(-2, -3)).toBe(1);
  });
});
```

- `describe` groups related tests.
- `it` (or `test`) defines a single test case.
- `expect(...).toBe(...)` asserts expected results.

**Run Tests**

```
npm test -- --runInBand
```

### Installing Dependencies

Install React Testing Library for component testing:

```bash
npm install --save-dev @testing-library/react @testing-library/jest-dom @testing-library/user-event jest-environment-jsdom
```

### Configuring Jest

Create `jest.setup.ts` to add RTL matchers:

```ts
import "@testing-library/jest-dom"; // Provides custom matchers like toBeInTheDocument()
```

Add a test script in `package.json`:

```json
"scripts": {
  "test": "jest --config jest.config.ts",
}
```

- `jest` → runs tests once.
- `jest --watch` → reruns tests when files change.

### React Components

React Testing Library encourages testing components as a user would interact with them.

```ts
// src/components/Title.tsx
interface TitleProps {
  title: string;
}

const Title = ({ title }: TitleProps) => {
  return <h1 className="text-4xl font-bold">{title}</h1>;
};

export default Title;
```

Example Test

```ts
// src/components/__tests__/Title.test.tsx
import { render, screen } from "@testing-library/react";
import Title from "../Title";

describe("Title Component", () => {
  it("renders the provided title", () => {
    render(<Title title="Hello World" />);
    const heading = screen.getByRole("heading", { name: /hello world/i });

    expect(heading).toBeInTheDocument();
    expect(heading).toHaveClass("text-4xl", "font-bold");
  });

  it("renders different titles dynamically", () => {
    render(<Title title="Next.js Testing" />);
    expect(screen.getByText(/next\.js testing/i)).toBeInTheDocument();
  });
});
```

## End-to-End Testing

E2E testing simulates real user interactions with your application. Unlike unit or integration tests, which test small pieces of functionality, E2E tests verify the entire workflow from the front-end UI to the back-end server.

For example, in a Next.js app, an E2E test might:

1. Open the browser.
2. Navigate to a page.
3. Click buttons or fill forms.
4. Verify that the expected behavior occurs (like a redirect or a new element appearing).

### Why Puppeteer for E2E Testing?

Puppeteer is a Node library that provides a high-level API to control Chrome/Chromium. It is perfect for E2E testing because:

- Runs a real browser for accurate tests.
- Supports headless mode (faster CI/CD runs).
- Can simulate user actions (click, type, scroll, etc.).
- Can take screenshots or record performance metrics.

### Setting up Puppeteer

#### Install dependencies

```bash
npm install --save-dev puppeteer  @types/puppeteer
```

#### Configure Jest for E2E tests

You may want a separate folder for E2E tests:

```
project-root/
│
├─ e2e/
│   └─ homePage.e2e.test.ts
```

Create a basic Jest config (`jest.e2e.config.ts`)

```ts
import type { Config } from "@jest/types";

const config: Config.InitialOptions = {
  preset: "ts-jest",
  testEnvironment: "node", // Puppeteer runs in Node
  testTimeout: 30000, // E2E tests can take longer
  testMatch: ["<rootDir>/e2e/**/*.test.ts"],
};

export default config;
```

Do not use `jest-environment-jsdom` for Puppeteer.

### Writing an E2E Test

Testing a Next.js homepage with a button that redirects.

File: `e2e/homePage.e2e.test.ts`

```ts
import puppeteer, { Browser, Page } from "puppeteer";

let browser: Browser;
let page: Page;

beforeAll(async () => {
  // Launch a real Chromium browser
  browser = await puppeteer.launch({
    headless: true, // set false if you want to see the browser
    args: ["--no-sandbox", "--disable-setuid-sandbox"],
  });
  page = await browser.newPage();
});

afterAll(async () => {
  if (browser) await browser.close();
});

describe("Home Page E2E Tests", () => {
  it("should load the homepage and display the title", async () => {
    await page.goto("http://localhost:3000"); // Make sure your Next.js app is running
    await page.waitForSelector("h1");

    const title = await page.$eval("h1", (el) => el.textContent);
    expect(title).toBe("Welcome to My Next.js App");
  });

  it("should navigate to About page when button is clicked", async () => {
    await page.goto("http://localhost:3000");

    await page.click('a[href="/about"]'); // App Router uses <Link>
    await page.waitForNavigation(); // Wait for navigation

    const url = page.url();
    expect(url).toBe("http://localhost:3000/about");

    const heading = await page.$eval("h1", (el) => el.textContent);
    expect(heading).toBe("About Us");
  }, 10000);
});
```

File: `/src/app/home.tsx`

```ts
import Link from "next/link";
import React from "react";

const HomePage: React.FC = () => {
  return (
    <main style={{ padding: "2rem", fontFamily: "sans-serif" }}>
      <h1>Welcome to My Next.js App</h1>
      <p>This is the homepage using the App Router.</p>

      <Link href="/about">
        <button
          style={{
            marginTop: "1rem",
            padding: "0.5rem 1rem",
            cursor: "pointer",
          }}
        >
          Go to About Page
        </button>
      </Link>
    </main>
  );
};

export default HomePage;
```

File: `/src/app/about.tsx`

```ts
import Link from "next/link";
import React from "react";

const AboutPage: React.FC = () => {
  return (
    <main style={{ padding: "2rem", fontFamily: "sans-serif" }}>
      <h1>About Us</h1>
      <p>This is the About page of your app.</p>

      <Link href="/">
        <button
          style={{
            marginTop: "1rem",
            padding: "0.5rem 1rem",
            cursor: "pointer",
          }}
        >
          Back to Home
        </button>
      </Link>
    </main>
  );
};

export default AboutPage;
```

1. `puppeteer.launch`
   - Starts a new Chromium instance.
   - `headless: true` runs the browser without a UI.
   - `args: ['--no-sandbox']` needed sometimes for CI environments.
2. `page.goto(url)`
   - Opens a page in the browser.
3. `page.waitForSelector('h1')`
   - Waits until the element appears in the DOM, ensuring the page is fully loaded.
4. `page.$eval(selector, callback)`
   - Extracts data from a DOM element.
   - Here, we get the text content of `<h1>`.
5. `page.click(selector)`
   - Simulates a user click.
6. `page.waitForNavigation()`
   - Waits until navigation is complete (useful for links and form submissions).
7. `expect()`
   - Jest assertion to verify the test results.

### NPM Configuration

```json
{
  "scripts": {
    "test:e2e": "jest --config jest.e2e.config.ts --watch"
  }
}
```

### Running E2E Tests

1. Start your Next.js app:

```bash
npm run dev
```

2. Run Jest with your E2E test:

```bash
npm run test:e2e
```

You should see the test opening a headless browser, navigating pages, and checking your elements.

## API routes Testing

Next.js allows you to write API routes inside the `pages/api` or `app/api` folder, for server-side logic such as fetching data, handling forms, or performing authentication.

Testing these routes is essential to ensure:

- Correct HTTP responses (status codes, body content)
- Proper handling of errors
- Integration with databases or external APIs
- Server-side logic correctness (functions, validations, etc.)

Unlike React components, API routes are pure Node.js functions, so we can test them as unit tests or integration tests using Jest and supertest.

**Setting Up for API Testing**

1. Install dependencies

   ```bash
   npm install --save-dev jest supertest
   ```

   - `jest` → test runner
   - `supertest` → helps test HTTP endpoints programmatically

2. Setup Jest: Make sure `jest.config.ts` is ready (as in unit testing setup).

### Testing a Simple API Route

Suppose we have an API route: `app/api/hello/route.ts`

```ts
import { NextRequest, NextResponse } from "next/server";

export async function GET(req: NextRequest) {
  return NextResponse.json({ message: "Hello World" });
}
```

Test: `__tests__/api/hello.test.js`

```ts
import { GET } from "@/app/api/hello/route";
import { NextRequest } from "next/server";

describe("/api/hello App Router API Endpoint", () => {
  test("returns 200 and a message on GET", async () => {
    const request = new NextRequest("http://localhost/api/hello"); // must use NextRequest
    const response = await GET(request);

    expect(response.status).toBe(200);
    const data = await response.json();
    expect(data).toEqual({ message: "Hello World" });
  });

  test("response has JSON content-type header", async () => {
    const request = new NextRequest("http://localhost/api/hello");
    const response = await GET(request);

    expect(response.headers.get("content-type")).toMatch(/application\/json/);
  });

  test("response body has a 'message' key of type string", async () => {
    const request = new NextRequest("http://localhost/api/hello");
    const response = await GET(request);

    const data = await response.json();
    expect(data).toHaveProperty("message");
    expect(typeof data.message).toBe("string");
  });
});
```

- `node-mocks-http` or similar libraries allow us to mock `req` and `res` objects.
- `_getStatusCode()` returns the response status.
- `_getJSONData()` parses JSON response body.
- This test doesn’t need a running server, making it fast and isolated.

### Testing API Routes with `supertest`

If you want to test the API with a running server:

1. Install `supertest` if not already:

   ```bash
   npm install --save-dev supertest
   ```

2. Suppose you have a Next.js custom server (using Express) or use `next-connect`:

   ```ts
   // server.ts
   import express from "express";
   import { GET } from "./app/api/hello/route";

   const server = express();

   // Wrap App Router GET handler to work with Express
   server.get("/api/hello", async (req, res) => {
     try {
       // Convert Express req to a minimal NextRequest-like object
       const nextReq = new Request(`http://localhost${req.url}`, {
         method: req.method,
         headers: req.headers as any,
       });

       const response = await GET(nextReq as any); // cast for simplicity
       const data = await response.json();

       res.status(response.status).json(data);
     } catch (err) {
       res.status(500).json({ error: "Internal Server Error" });
     }
   });

   export default server;
   ```

Test: `__tests__/api/hello.supertest.test.js`

```ts
import request from "supertest";
import server from "../server"; // path to server.ts

describe("GET /api/hello", () => {
  it("returns 200 and a JSON message", async () => {
    const res = await request(server).get("/api/hello");

    expect(res.status).toBe(200);
    expect(res.body).toEqual({ message: "Hello World" });
  });

  it("response has JSON content-type header", async () => {
    const res = await request(server).get("/api/hello");
    expect(res.headers["content-type"]).toMatch(/application\/json/);
  });

  it("response body has a 'message' key of type string", async () => {
    const res = await request(server).get("/api/hello");
    expect(res.body).toHaveProperty("message");
    expect(typeof res.body.message).toBe("string");
  });
});
```

- `supertest` sends real HTTP requests to your server.
- Useful for integration testing, e.g., when testing middleware, authentication, or database interaction.
- The test mimics a real user request.

### Best Practices for API Testing

1. Separate logic from the handler
   - Move core business logic to plain functions and call them in API routes.
   - Makes unit testing easier.
2. Use mocks for external services
   - Databases, APIs, authentication can be mocked to isolate tests.
3. Test status codes and payloads
   - Ensure correct HTTP status for all possible methods and errors.
4. Unit test first, E2E later
   - Unit tests catch most logic errors quickly.
   - E2E tests can verify full API flow.
