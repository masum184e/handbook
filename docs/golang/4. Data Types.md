
## Inferred

An inferred data type means Go figures out the variable’s type automatically from the value you give it — you don’t have to write the type yourself.

When you use the short declaration syntax:

```
name := "Alice"
```

- You didn’t say `string` anywhere.
- Go sees `"Alice"` is text in quotes → infers type = `string`.

**Why it’s possible**

- Go is statically typed (types are fixed at compile time), but the compiler is smart enough to detect the type from the value.
- This only works when you assign a value immediately.

**What happens if you don’t give a value?**

```go
x :=     // ❌ ERROR: missing value
```

- Go must have a value to infer the type.
- If you want an empty variable, you must use var and specify the type:

```go
var x int
```

**Once inferred, type is fixed**

Even if Go inferred the type for you, it’s still fixed:

```go
count := 10     // int
count = "ten"   // ❌ ERROR: cannot assign string to int
```

### Common values and the types Go infers for them when you use :=:

| Value                    | Inferred Type    | Explanation                         |
| ------------------------ | ---------------- | ----------------------------------- |
| `42`                     | `int`            | Whole number → integer type         |
| `3.14`                   | `float64`        | Decimal number → 64-bit float       |
| `"Hello"`                | `string`         | Text in quotes → string             |
| `true`                   | `bool`           | `true` or `false` → boolean         |
| `'a'`                    | `rune`           | Single quotes → rune (Unicode char) |
| `[]int{1, 2, 3}`         | `[]int`          | Slice (list) of integers            |
| `map[string]int{"a": 1}` | `map[string]int` | Map with string keys and int values |

### Example of inferred

```go
func main() {
    x := 42           // int
    y := 3.14         // float64
    s := "Hello"      // string
    b := true         // bool
}
```