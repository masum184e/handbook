## Stack

- Stores function call frames:
  - Local variables
  - Function parameters
  - Return addresses
- Automatically cleaned up after a function returns.
- Very fast because it works like a LIFO (Last In, First Out) structure.
- Limited in size (default goroutine stack starts small, grows automatically).

```go
func add(a, b int) int {
    result := a + b // 'result' stored on stack
    return result
}

func main() {
    sum := add(5, 3) // 'sum' stored on stack
    fmt.Println(sum)
}
```

- `a`, `b`, and `result` live in the stack frame of `add()`.
- `sum` lives in the stack frame of `main()`.

## Heap

- Stores dynamically allocated memory.
- Managed by Goâ€™s garbage collector.
- Slower than stack, but size is much bigger.
- Memory stays allocated until garbage collector removes it.

```go
func createSlice() *[]int {
    nums := []int{1, 2, 3} // allocated on heap
    return &nums
}

func main() {
    slicePtr := createSlice()
    fmt.Println(*slicePtr)
}
```

- `nums` escapes to the heap because we return a pointer to it.
- Even after `createSlice()` ends, `nums` stays in memory (heap) until GC clears it.

## Stack VS Heap

| Feature        | Stack                        | Heap                    |
| -------------- | ---------------------------- | ----------------------- |
| **Speed**      | Fast                         | Slower                  |
| **Size**       | Small, grows per goroutine   | Large                   |
| **Lifetime**   | Until function ends          | Until GC cleans it      |
| **Management** | Automatic (LIFO)             | Garbage Collector       |
| **Best for**   | Local, short-lived variables | Long-lived, shared data |
