

JavaScript has a single-threaded runtime — meaning only one operation runs at any moment.
However, JavaScript can handle asynchronous tasks efficiently by delegating work to the Web API and using the event loop to manage callbacks.

The execution model has three main parts:

1. **Call Stack** – Where synchronous code is executed line by line.
2. **Web APIs** – Provided by the browser (or Node.js APIs) for async tasks like timers, HTTP requests, file I/O, etc.
3. **Callback Queue / Microtask Queue** – Holds functions waiting to be executed when the stack is empty.
4. **Event Loop** – Constantly checks if the stack is empty, then moves queued functions into it.

## Synchronous Execution

- Code runs top to bottom.
- Each line blocks the next line until it finishes.
- Only the call stack is involved.

```js
console.log("1: Start");

function multiply(a, b) {
  return a * b;
}

console.log("2: Multiply result =", multiply(2, 5));

console.log("3: End");

console.log("2: Multiply result =", multiply(2, 5));

console.log("3: End");
```

### Step-by-step

1. `console.log("1: Start")` → pushed to call stack → executed → removed.
2. `multiply(2, 5)`:

   - Call `multiply` → push to stack.
   - Return `10` → remove `multiply` from stack.

3. `console.log("2: Multiply result =", 10)` → executed.
4. `console.log("3: End")` → executed.

**Output:**

```
1: Start
2: Multiply result = 10
3: End
```

Nothing waits in the background — one step must finish before the next starts.

## Asynchronous Execution

- **Web APIs** to do work in the background.
- **Callback Queue** to store functions when ready.
- **Event Loop** to insert them into the stack when it's free.

```js
console.log("1: Start");

setTimeout(() => {
  console.log("2: Timeout finished");
}, 2000);

console.log("3: End");
```

### Step-by-step:

1. `console.log("1: Start")` → executed immediately.
2. `setTimeout` is called:

   - The `setTimeout` function is pushed to the call stack.
   - The browser's Web API starts a 2-second timer in the background.
   - `setTimeout` finishes → removed from stack.

3. `console.log("3: End")` → executed.
4. Meanwhile, the timer counts down in Web API land.
5. After 2 seconds, the callback `() => console.log("2: Timeout finished")` is sent to the Callback Queue.
6. Event Loop checks: Is the call stack empty? Yes → moves callback into stack.
7. Callback executes → prints `"2: Timeout finished"`.

**Output:**

```
1: Start
3: End
2: Timeout finished
```

## Microtasks vs Macrotasks

JavaScript has two queues for async tasks:

1. Macrotask Queue – `setTimeout`, `setInterval`, I/O callbacks.
2. Microtask Queue – Promises, `queueMicrotask()`.

Microtasks always run before macrotasks when the call stack is free.

### Example – Promise vs Timeout

```js
console.log("1: Start");

setTimeout(() => {
  console.log("2: Timeout");
}, 0);

Promise.resolve().then(() => {
  console.log("3: Promise resolved");
});

console.log("4: End");
```

**Output:**

```
1: Start
4: End
3: Promise resolved
2: Timeout
```

### Step-by-step:

1. `"1: Start"` → executed.
2. `setTimeout` → sends task to macrotask queue (0ms delay, but still queued).
3. `Promise.then` → sends task to microtask queue.
4. `"4: End"` → executed.
5. Call stack empty → Event Loop checks microtasks first:
   - `"3: Promise resolved"` → executed.
6. Then moves to macrotasks:
   - `"2: Timeout"` → executed.

### Step-by-step

1. `console.log("1: Start")` → pushed to call stack → executed → removed.
2. `multiply(2, 5)`:

   - Call `multiply` → push to stack.
   - Return `10` → remove `multiply` from stack.

3. `console.log("2: Multiply result =", 10)` → executed.
4. `console.log("3: End")` → executed.

**Output:**

```
1: Start
2: Multiply result = 10
3: End
```

Nothing waits in the background — one step must finish before the next starts.

## Asynchronous Execution

- **Web APIs** to do work in the background.
- **Callback Queue** to store functions when ready.
- **Event Loop** to insert them into the stack when it's free.

```js
console.log("1: Start");

setTimeout(() => {
  console.log("2: Timeout finished");
}, 2000);

console.log("3: End");
```

### Step-by-step:

1. `console.log("1: Start")` → executed immediately.
2. `setTimeout` is called:

   - The `setTimeout` function is pushed to the call stack.
   - The browser's Web API starts a 2-second timer in the background.
   - `setTimeout` finishes → removed from stack.

3. `console.log("3: End")` → executed.
4. Meanwhile, the timer counts down in Web API land.
5. After 2 seconds, the callback `() => console.log("2: Timeout finished")` is sent to the Callback Queue.
6. Event Loop checks: Is the call stack empty? Yes → moves callback into stack.
7. Callback executes → prints `"2: Timeout finished"`.

**Output:**

```
1: Start
3: End
2: Timeout finished
```

## Microtasks vs Macrotasks

JavaScript has two queues for async tasks:

1. Macrotask Queue – `setTimeout`, `setInterval`, I/O callbacks.
2. Microtask Queue – Promises, `queueMicrotask()`.

Microtasks always run before macrotasks when the call stack is free.

### Example – Promise vs Timeout

```js
console.log("1: Start");

setTimeout(() => {
  console.log("2: Timeout");
}, 0);

Promise.resolve().then(() => {
  console.log("3: Promise resolved");
});

console.log("4: End");
```

**Output:**

```
1: Start
4: End
3: Promise resolved
2: Timeout
```

### Step-by-step:

1. `"1: Start"` → executed.
2. `setTimeout` → sends task to macrotask queue (0ms delay, but still queued).
3. `Promise.then` → sends task to microtask queue.
4. `"4: End"` → executed.
5. Call stack empty → Event Loop checks microtasks first:
   - `"3: Promise resolved"` → executed.
6. Then moves to macrotasks:
   - `"2: Timeout"` → executed.

## Synchronous vs Asynchronous

Most of the language work synchronously by default. Javascript is a synchronous programming language also but if we want to work with any remote server which is called ajax call, javascript behaves like asynchronous.

### Synchronous

It means each statement is executed one after the other, in order they appear in the code(Top to Bottom). Synchronous code `blocks`(whole browser, user can't even click any event) the execution of subsequent code until the current operation finishes. It's operations is slow and you can predict the order of execution as well.

```js
const processOrder = (orderNumber) => {
  console.log(`Processing Order ${orderNumber}`);

  let currentTime = new Date().getTime();
  while (currentTime + 3000 >= new Date().getTime());

  console.log(`Proceed Order ${orderNumber}`);
};
console.log("Take Order 1");
processOrder(1);
console.log("Completed Order 1");
console.log("Take Order 1");
processOrder(2);
console.log("Completed Order 1");
```

### Asynchronous

It allow to handle operations that take time to complete such as network request, file reading, timers erct `without blocking` the main thread.

```js
const processOrder = (orderNumber, requiredTime) => {
  console.log(`Proces Order Start ${orderNumber}`);

  setTimeout(() => {
    console.log(`Processing Order ${orderNumber}`);
  }, requiredTime);

  console.log(`Proceed Order ${orderNumber}`);
};
console.log("Take Order 1");
processOrder(1, 3000);
console.log("Completed Order 1");
console.log("Take Order 1");
processOrder(2, 5000);
console.log("Completed Order 1");
```

But if you look into the output sequence, this doesn't follow proper order, though it execute asynchronously.

```
Take Order 1
Proces Order Start 1
Proceed Order 1
Completed Order 1
Take Order 2
Proces Order Start 2
Proceed Order 2
Completed Order 2
Processing Order 1
Processing Order 2
```

See the output, order completion execute before processing order. But it should be execute sequentially, like take order, process order, complete order. Callback function solve this problem, with callback function we can execute function sequentially as well as asynchronously.

Look at this example, order 1 and order 2 execute sequentially and asynchroously.

```js
const takeOrder = (orderNumber, callback) => {
  console.log(`Take Order ${orderNumber}`);
  callback(orderNumber);
};
const processOrder = (orderNumber, callback) => {
  console.log(`Proces Order Start ${orderNumber}`);

  setTimeout(() => {
    console.log(`Proceed Order ${orderNumber}`);
    callback(orderNumber);
  }, 3000);
};
const completeOrder = (orderNumber, callback) => {
  console.log(`Completed Order ${orderNumber}`);
};

takeOrder(1, (orderNumber) => {
  processOrder(1, (orderNumber) => {
    completeOrder(1);
  });
});
takeOrder(2, (orderNumber) => {
  processOrder(2, (orderNumber) => {
    completeOrder(2);
  });
});
```
