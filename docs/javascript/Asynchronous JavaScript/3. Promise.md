A promise is an object that represent the eventual completion or failure of an `asynchronouse` operation and its resulting value.

## Structure of a Promise

It is created using the `Promise` constructor, which takes a function(called the executor function) with two parameter: `resolve` and `reject`.

```js
const promise = new Promise((resolve, reject) => {
  // ASYNCHRONOUS OPERATION
  const successful = true;

  successful ? resolve() : reject();
});
```

The value passed in resolve method catch in the callback function of `then()` method and the value passed in reject method catch in the callback function of `catch()` method

## Using Promise

Promises are used with `.then()` and `.catch()` method to handle the outcomes.

- `then()` is called when the promise is fulfilled
- `catch()` is called when promise is rejected

```js
const promise = new Promise((resolve, reject) => {
  // ASYNCHRONOUS OPERATION
  const successful = true;

  successful ? resolve("Resolve") : reject("Reject");
});

promise
  .then((resolve) => {
    console.log(resolve);
    console.log("Then");
  })
  .catch(() => {
    console.log("Catch");
  })
  .finally(() => {
    console.log("Finally");
  });
```

## Promise.all()

Promise is used to resolve callback hell which occur during multiple function call sequentially. What if there have multiple funtionality where multiple function called sequentialy. Then for each of the sequential call we need a promise. So, when there have multiple promise and this promises also have a sequence, we need to use `Promise.all()`

- `Promise.all` takes an array of promises and returns a single Promise.
- The returned promise resolves when all input promises resolve, with an array of their results.
- It rejects immediately if any one of the input promises rejects.

**Why use it?**

- Run multiple async tasks in parallel instead of sequentially â†’ faster.
- Wait for all tasks to complete before proceeding.

**Alternative for partial success: `Promise.allSettled`**

- Returns an array of objects indicating fulfilled or rejected.
- Useful when you want results even if some promises fail.

```js
const promise1 = new Promise((resolve, reject) => {
  const successful = true;
  successful ? resolve("Resolve 1") : reject("Reject 1");
});
const promise2 = new Promise((resolve, reject) => {
  const successful = true;
  successful ? resolve("Resolve 2") : reject("Reject 2");
});
Promise.all([promise1, promise2]).then((data) => {
  console.log(data);
});
```

## Promise Chain

Promises can be chained to run asynchronouse task sequenially which resolve callback hell.

1.  **Convert Functions to Return Promises**

    For each function that uses a callback, refactor it to return a Promise instead.

    ```js
    const takeOrder = (orderNumber) => {
      return new Promise((resolve) => {
        console.log(`Take Order ${orderNumber}`);
        resolve(orderNumber);
      });
    };
    const processOrder = (orderNumber) => {
      return new Promise((resolve) => {
        console.log(`Proces Order Start ${orderNumber}`);
        const takeOrder = (orderNumber) => {
          return new Promise((resolve) => {
            console.log(`Take Order ${orderNumber}`);
            resolve(orderNumber);
          });
        };
        const processOrder = (orderNumber) => {
          return new Promise((resolve) => {
            console.log(`Proces Order Start ${orderNumber}`);

            setTimeout(() => {
              console.log(`Proceed Order ${orderNumber}`);
              resolve(orderNumber);
            }, 3000);
          });
        };
        const completeOrder = (orderNumber) => {
          return new Promise((resolve) => {
            console.log(`Completed Order ${orderNumber}`);
            resolve(orderNumber);
          });
        };

        setTimeout(() => {
          console.log(`Proceed Order ${orderNumber}`);
          resolve(orderNumber);
        }, 3000);
      });
    };
    const completeOrder = (orderNumber) => {
      return new Promise((resolve) => {
        console.log(`Completed Order ${orderNumber}`);
        resolve(orderNumber);
      });
    };
    ```

2.  **Chain the Promises**

    Once the functions return Promises, chain them using `.then()` and `.catch()` method.

    ```js
    takeOrder(1)
      .then((orderNumber) => processOrder(orderNumber))
      .then((orderNumber) => completeOrder(orderNumber))
      .catch(() => console.log("Error Occurred"));
    takeOrder(2)
      .then((orderNumber) => processOrder(orderNumber))
      .then((orderNumber) => completeOrder(orderNumber))
      .catch(() => console.log("Error Occurred"));
    ```

    ```js
    takeOrder(1)
      .then((orderNumber) => processOrder(orderNumber))
      .then((orderNumber) => completeOrder(orderNumber))
      .catch(() => console.log("Error Occurred"));
    takeOrder(2)
      .then((orderNumber) => processOrder(orderNumber))
      .then((orderNumber) => completeOrder(orderNumber))
      .catch(() => console.log("Error Occurred"));
    ```

## Promise Methods

| Method                     | Resolves when...                        | Rejects when...                       | Use Case                                                                            |
| -------------------------- | --------------------------------------- | ------------------------------------- | ----------------------------------------------------------------------------------- |
| **`Promise.all()`**        | All promises resolve                    | Any promise rejects                   | When you need all promises to succeed                                               |
| **`Promise.race()`**       | The first promise resolves or rejects   | The first promise resolves or rejects | When you care about the fastest promise (first to settle)                           |
| **`Promise.any()`**        | The first promise resolves              | All promises reject (AggregateError)  | When you care about the first successful promise                                    |
| **`Promise.allSettled()`** | All promises settle (resolve or reject) | Never rejects                         | When you want to know the outcome of all promises, regardless of success or failure |
