---
sidebar_position: 24
---

`React.memo` is a higher-order component that helps improve performance by skipping unnecessary re-renders. It memoizes the rendered output of a functional component and only re-renders it when its props actually change.

> If a component receives the same props as last time, React can reuse the previous render instead of rendering again.

By default, when a parent re-renders, all its children re-render too—even if their props didn’t change. `React.memo` stops that behavior.

## How `React.memo` works

- React performs a shallow comparison of props
- If props are equal → no re-render
- If any prop reference changes → re-render

Shallow comparison means:

- Primitives (`number`, `string`, `boolean`) → compared by value
- Objects, arrays, functions → compared by reference

## Example without `React.memo` (Problem)

```jsx
function Parent() {
  const [count, setCount] = React.useState(0);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child title="Hello" />
    </>
  );
}

function Child({ title }) {
  console.log("Child rendered");
  return <h2>{title}</h2>;
}
```

- Clicking the button updates `count`
- `Parent` re-renders ✅
- `Child` re-renders ❌ (even though `title` never changes)

## Optimized version using `React.memo`

```jsx
const Child = React.memo(function Child({ title }) {
  console.log("Child rendered");
  return <h2>{title}</h2>;
});
```

- Initial render → `Child` rendered
- Clicking the button → `Parent` re-renders
- `Child` does not re-render
- Performance win

## Example with function props (common pitfall)

### This breaks memoization

```jsx
const Child = React.memo(function Child({ onClick }) {
  console.log("Child rendered");
  return <button onClick={onClick}>Click me</button>;
});

function Parent() {
  const [count, setCount] = React.useState(0);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child onClick={() => console.log("clicked")} />
    </>
  );
}
```

Why it still re-renders?

- The arrow function is re-created on every render
- New function reference ≠ previous one
- `React.memo` sees props as “changed”

### Fix: combine `React.memo` with `useCallback`

```jsx
function Parent() {
  const [count, setCount] = React.useState(0);

  const handleClick = React.useCallback(() => {
    console.log("clicked");
  }, []);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child onClick={handleClick} />
    </>
  );
}
```

- `handleClick` keeps the same reference
- `Child` skips re-rendering

### Custom comparison function (advanced)

You can control how props are compared:

```jsx
const Child = React.memo(
  function Child({ user }) {
    console.log("Child rendered");
    return <div>{user.name}</div>;
  },
  (prevProps, nextProps) => {
    return prevProps.user.id === nextProps.user.id;
  },
);
```

Use this sparingly—custom comparisons can be expensive and error-prone.

## When to use React.memo

- Good use cases
  - Pure functional components
  - Expensive UI (charts, tables, lists)
  - Components that re-render often with same props
- Avoid when
  - Component is cheap to render
  - Props change frequently anyway
  - Over-optimization hurts readability

## Key takeaway

- `React.memo` prevents re-renders when props don’t change
- It relies on reference equality
- Works best with `useCallback` and `useMemo`
- Measure before and after—don’t optimize blindly
