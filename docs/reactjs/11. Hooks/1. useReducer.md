The `useReducer` hook is a built-in React Hook used for state management in functional components. It is especially useful when state logic is complex, involves multiple sub-values, or when the next state depends on the previous state.

Think of `useReducer` as an alternative to useState, inspired by how Redux works, but used inside a component.

## What is `useReducer`

`useReducer` helps you manage state using a reducer function.

A reducer is a pure function that takes:

- the current state
- an action

and returns a new state.

```js
newState = reducer(currentState, action);
```

## When Should You Use `useReducer`

Use `useReducer` when:

- State logic is complex
- You have multiple related state variables
- State updates depend on previous state
- You want predictable and structured state updates
- You want Redux-like logic without Redux

### `useState` vs `useReducer`

| `useState`                | `useReducer`         |
| ----------------------- | ------------------ |
| Simple state            | Complex state      |
| Few updates             | Many update types  |
| Direct updates          | Centralized logic  |
| Hard to manage at scale | Easier to maintain |

## Syntax of useReducer

```ts
const [state, dispatch] = useReducer(reducer, initialState);
```

**Parameters**

1. `reducer` – A function `(state, action) => newState`
2. `initialState` – The initial value of the state

**Returns**

- `state` – Current state
- `dispatch` – Function used to send actions

## Structure of a Reducer Function

```js
function reducer(state, action) {
  switch (action.type) {
    case "ACTION_NAME":
      return newState;
    default:
      return state;
  }
}
```

**Action Object**

An action is a plain JavaScript object:

```json
{
  "type": "INCREMENT",
  "payload": 1
}
```

- `type` – Describes what happened
- `payload` – Optional data needed for the update


## Simple Example - Counter App
### 1. Reducer Function
```js
function counterReducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1;
    case 'DECREMENT':
      return state - 1;
    case 'RESET':
      return 0;
    default:
      return state;
  }
}
```
### 2. Component Using useReducer
```js
import React, { useReducer } from 'react';

function Counter() {
  const [count, dispatch] = useReducer(counterReducer, 0);

  return (
    <div>
      <h2>Count: {count}</h2>

      <button onClick={() => dispatch({ type: 'INCREMENT' })}>
        +
      </button>

      <button onClick={() => dispatch({ type: 'DECREMENT' })}>
        -
      </button>

      <button onClick={() => dispatch({ type: 'RESET' })}>
        Reset
      </button>
    </div>
  );
}

export default Counter;
```
- `count` → current state
- `dispatch()` → sends an action
- Reducer decides how state changes
- UI never directly modifies state

## Example with Payload (Dynamic Data)
Reducer
```js
function counterReducer(state, action) {
  switch (action.type) {
    case 'INCREMENT_BY':
      return state + action.payload;
    case 'DECREMENT_BY':
      return state - action.payload;
    default:
      return state;
  }
}
```
Component
```js
const [count, dispatch] = useReducer(counterReducer, 0);

dispatch({ type: 'INCREMENT_BY', payload: 5 });
```
- `payload` carries extra data
- Makes reducer more flexible

## Complex State Example (Object State)
Initial State
```js
const initialState = {
  count: 0,
  step: 1
};
```
Reducer
```js
function reducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + state.step };
    case 'DECREMENT':
      return { ...state, count: state.count - state.step };
    case 'SET_STEP':
      return { ...state, step: action.payload };
    default:
      return state;
  }
}
```
Component
```js
const [state, dispatch] = useReducer(reducer, initialState);

<input
  type="number"
  onChange={(e) =>
    dispatch({ type: 'SET_STEP', payload: Number(e.target.value) })
  }
/>

<button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>
```
- State is an object
- Spread operator prevents mutation
- Reducer keeps logic centralized
