The `useCallback` hook is a React Hook used for performance optimization. It helps you memoize a function, so the same function reference is reused between renders unless its dependencies change.

## What is `useCallback`

`useCallback` returns a cached version of a function that only changes if its dependencies change.

```js
const memoizedFn = useCallback(() => {
  // function logic
}, [dependencies]);
```

## Why Do We Need `useCallback`

In JavaScript:

- Functions are objects
- A new function is created on every render

In React:

- Passing a new function as a prop causes child components to re-render
- This can cause unnecessary renders and performance issues

`useCallback` solves this by keeping the same function reference.

## When Should You Use `useCallback`

Use `useCallback` when:

- Passing functions to memoized child components (`React.memo`)
- Functions are dependencies of `useEffect` or `useMemo`
- Preventing unnecessary re-renders
- Functions are expensive to recreate
- Large or complex component trees

Do not use it everywhere. It has overhead.

## Syntax of useCallback

```js
const memoizedFunction = useCallback(() => {
  // logic
}, [dependency1, dependency2]);
```

Parameters

- Callback function – the function to memoize
- Dependency array – controls when function is recreated

## How `useCallback` Works (Concept)

- React stores the function reference
- On re-render:
  - If dependencies are the same → reuse function
  - If dependencies change → create a new function

## Simple Example – Function Recreation Problem

Without `useCallback`

```js
function Parent() {
  const [count, setCount] = React.useState(0);

  const handleClick = () => {
    console.log("Clicked");
  };

  return <Child onClick={handleClick} />;
}
```

Problem

- `handleClick` is recreated on every render
- Child receives a new prop
- Child re-renders unnecessarily

## Example with `React.memo`

### Child Component

```js
const Child = React.memo(({ onClick }) => {
  console.log("Child rendered");
  return <button onClick={onClick}>Click</button>;
});
```

### Without `useCallback`

```js
function Parent() {
  const [count, setCount] = React.useState(0);

  const handleClick = () => {
    console.log("Clicked");
  };

  return (
    <>
      <h2>{count}</h2>
      <button onClick={() => setCount(count + 1)}>+</button>
      <Child onClick={handleClick} />
    </>
  );
}
```

**Result**

- Clicking `+` causes parent to re-render
- New `handleClick` is created
- Child re-renders every time

### With useCallback
```js
import { useCallback, useState } from 'react';

function Parent() {
const [count, setCount] = useState(0);

const handleClick = useCallback(() => {
console.log('Clicked');
}, []);

return (
<>
<h2>{count}</h2>
<button onClick={() => setCount(count + 1)}>+</button>
<Child onClick={handleClick} />
</>
);
}
```
**Explanation**

- `handleClick` reference stays the same
- Child does not re-render
- Better performance


## `useCallback` with Dependencies
```js
const handleAdd = useCallback(() => {
  setCount(count + 1);
}, [count]);
```
**Explanation**

- Function depends on `count`
- New function is created only when `count` changes

If dependency is missing, it may cause stale values.

## `useCallback` with `useEffect`
**Problem**
```js
useEffect(() => {
  doSomething();
}, [doSomething]);
```

If `doSomething` is recreated every render, effect runs repeatedly.

**Solution**
```
const doSomething = useCallback(() => {
  console.log('Doing something');
}, []);

useEffect(() => {
  doSomething();
}, [doSomething]);
```
**Explanation**

- Function is stable
- Effect runs only once

## useCallback with Parameters
```js
const handleDelete = useCallback((id) => {
  setItems(items.filter(item => item.id !== id));
}, [items]);
```

- Parameters are passed normally
- Dependency array still required

## `useCallback` vs `useMemo`

| useCallback           | useMemo               |
| --------------------- | --------------------- |
| Memoizes **function** | Memoizes **value**    |
| Returns function      | Returns result        |
| Used for handlers     | Used for calculations |

```js
useCallback(fn, deps) === useMemo(() => fn, deps);
```

## Common Mistakes

- Using useCallback without React.memo
- Missing dependencies
- Over-optimizing early
- Using it for simple components

## Real-World Use Cases

- Button click handlers
- List item actions
- Form submit handlers
- Callback props in large apps
