The `useState` hook is the most fundamental React Hook. It allows functional components to store, update, and manage state.

Before Hooks, state was available only in class components. `useState` made state management simple and powerful in function components.

## What is `useState`

`useState` is a React Hook that lets you add state variables to functional components.

## Why Do We Need `useState`

React components:

- Render UI based on data (state)
- Need to remember values between renders
- Must re-render when data changes

`useState` solves this by:

- Storing data across renders
- Triggering re-render when state updates

## Syntax of `useState`

```js
import { useState } from "react";

const [value, setValue] = useState(initialValue);
```

- `value` → current state
- `setValue` → function to update state
- `initialValue` → initial state (only used on first render)

## How useState Works Internally (Concept)

1. React stores the state
2. When setState is called:
   - React schedules a re-render
   - Component runs again
   - New state value is used

State updates are asynchronous and batched.

## Simple Example – Counter

```js
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h2>Count: {count}</h2>

      <button onClick={() => setCount(count + 1)}>+</button>
      <button onClick={() => setCount(count - 1)}>-</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}

export default Counter;
```

- `count` stores the current value
- `setCount` updates state
- Updating state causes re-render
- UI updates automatically

## Updating State Based on Previous State

Wrong way (can cause bugs)

```js
setCount(count + 1);
setCount(count + 1);
```

Correct way

```js
setCount((prevCount) => prevCount + 1);
```

- Uses previous state safely
- Avoids stale values
- Recommended for async updates

## `useState` with Objects

Initial State

```js
const [user, setUser] = useState({
  name: "John",
  age: 25,
});
```

Updating Object State

```js
setUser({ name: "Bob" }); // ❌ age is lost
setUser({
  ...user,
  name: "Bob",
}); // also work
setUser((prevUser) => ({
  ...prevUser,
  age: 26,
})); // Recommended
```

Explanation

- React does not merge objects automatically
- Spread operator prevents mutation

## useState with Arrays

Initial State

```js
const [items, setItems] = useState([]);
```

Add Item

```js
setItems((prevItems) => [...prevItems, newItem]);
```

Remove Item

```js
setItems((prevItems) => prevItems.filter((item) => item.id !== id));
```

Explanation

- Never mutate arrays directly
- Always return a new array

## Lazy Initialization (Performance Optimization)

```js
const [count, setCount] = useState(() => {
  return expensiveCalculation();
});
```

Explanation

- Function runs only once
- Improves performance for heavy initialization

## Common Mistakes

- Mutating state directly
- Expecting immediate state updates
- Forgetting to copy objects/arrays
- Overusing state

## ...

- When state changes → component re-renders, `useState` trigger re-render automatically

## State and Props together

```jsx
function Parent() {
  const [name, setName] = useState("Alice");

  return (
    <div>
      <Child name={name} />
      <button onClick={() => setName("Bob")}>Change Name</button>
    </div>
  );
}

function Child({ name }) {
  return <h2>Hello, {name}</h2>;
}
```

- `Parent` owns the state
- `Child` receives `name` as a prop
- When `setName("Bob")` runs:
  - Parent state updates
  - Parent re-renders
  - Child receives new props
  - Child re-renders automatically

Rule of thumb:

> The component that changes the data should own the state.

## Issues with prop drilling

Tight coupling: Intermediate components become tied to:

- The shape of props
- The data structure

Changing a prop means editing multiple files.

Harder to refactor, If you:

- Rename a prop
- Remove a state
- Add a new one

You must update every level in the chain.

## Questions

- Why directly modifying `setState` doesn't work.
