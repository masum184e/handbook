The `useState` hook is the most fundamental React Hook. It allows functional components to store, update, and manage state.

Before Hooks, state was available only in class components. `useState` made state management simple and powerful in function components.

## What is `useState`

`useState` is a React Hook that lets you add state variables to functional components.

## Why Do We Need `useState`

React components:

- Render UI based on data (state)
- Need to remember values between renders
- Must re-render when data changes

`useState` solves this by:

- Storing data across renders
- Triggering re-render when state updates

## Syntax of `useState`

```js
import { useState } from "react";

const [value, setValue] = useState(initialValue);
```

- `value` → current state
- `setValue` → function to update state
- `initialValue` → initial state (only used on first render)

## How useState Works Internally (Concept)

1. React stores the state
2. When setState is called:
   - React schedules a re-render
   - Component runs again
   - New state value is used

State updates are asynchronous and batched.

## Simple Example – Counter

```js
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h2>Count: {count}</h2>

      <button onClick={() => setCount(count + 1)}>+</button>
      <button onClick={() => setCount(count - 1)}>-</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}

export default Counter;
```

- `count` stores the current value
- `setCount` updates state
- Updating state causes re-render
- UI updates automatically

## Updating State Based on Previous State

Wrong way (can cause bugs)

```js
setCount(count + 1);
setCount(count + 1);
```

Correct way

```js
setCount((prevCount) => prevCount + 1);
```

- Uses previous state safely
- Avoids stale values
- Recommended for async updates

## `useState` with Objects

Initial State

```js
const [user, setUser] = useState({
  name: "John",
  age: 25,
});
```

Updating Object State

```js
setUser((prevUser) => ({
  ...prevUser,
  age: 26,
}));
```

Explanation

- React does not merge objects automatically
- Spread operator prevents mutation

## useState with Arrays

Initial State

```js
const [items, setItems] = useState([]);
```

Add Item

```js
setItems((prevItems) => [...prevItems, newItem]);
```

Remove Item

```js
setItems((prevItems) => prevItems.filter((item) => item.id !== id));
```

Explanation

- Never mutate arrays directly
- Always return a new array

## Lazy Initialization (Performance Optimization)

```js
const [count, setCount] = useState(() => {
  return expensiveCalculation();
});
```

Explanation

- Function runs only once
- Improves performance for heavy initialization

## Common Mistakes

- Mutating state directly
- Expecting immediate state updates
- Forgetting to copy objects/arrays
- Overusing state
