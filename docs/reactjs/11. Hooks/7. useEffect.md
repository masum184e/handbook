The `useEffect` hook is one of the most important and commonly used React Hooks. It lets you perform side effects in functional components.

Side effects include: Data fetching, DOM manipulation, Subscriptions, Timers, Logging, Updating document title

## Why Do We Need `useEffect`

React components should be pure during rendering:

- No API calls
- No subscriptions
- No DOM manipulation

`useEffect` runs after rendering, so itâ€™s safe to perform these operations.

## Basic Syntax of useEffect

```js
import { useEffect } from "react";

useEffect(() => {
  // effect logic

  return () => {
    // cleanup logic (optional)
  };
}, [dependencies]);
```

## When Does useEffect Run?

This depends on the dependency array.

### No Dependency Array

```js
useEffect(() => {
  console.log("Runs on every render");
});
```

Runs after every render

### Empty Dependency Array `[]`

```js
useEffect(() => {
  console.log("Runs once");
}, []);
```

Runs once after first render (componentDidMount)

### With Dependencies

```js
useEffect(() => {
  console.log("Runs when count changes");
}, [count]);
```

Runs on first render, Whenever `count` changes

## Data Fetching Example

```js
import { useEffect, useState } from "react";

function Users() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch("https://jsonplaceholder.typicode.com/users")
      .then((res) => res.json())
      .then((data) => {
        setUsers(data);
        setLoading(false);
      });
  }, []);

  if (loading) return <p>Loading...</p>;

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

- Runs once when component mounts
- Fetches data
- Updates state
- Triggers re-render

## Cleanup Function (Very Important)

Some effects need cleanup to prevent memory leaks.

### Example: Event Listener

```js
useEffect(() => {
  const handleResize = () => {
    console.log(window.innerWidth);
  };

  window.addEventListener("resize", handleResize);

  return () => {
    window.removeEventListener("resize", handleResize);
  };
}, []);
```

- Cleanup runs when component unmounts
- Also runs before effect re-runs
- Prevents duplicate listeners

### `useEffect` with Timer (`setInterval`)

```js
useEffect(() => {
  const interval = setInterval(() => {
    console.log("Tick");
  }, 1000);

  return () => clearInterval(interval);
}, []);
```

- Interval created once
- Cleared on unmount
- Prevents memory leak

## Infinite Loop Problem (Common Mistake)

Wrong Code

```js
useEffect(() => {
  setCount(count + 1);
}, [count]);
```

Causes infinite loop

Correct Approach

```js
useEffect(() => {
  setCount((prev) => prev + 1);
}, []);
```

## `useEffect` vs Lifecycle Methods (Class Components)

| Class Lifecycle      | useEffect Equivalent        |
| -------------------- | --------------------------- |
| componentDidMount    | useEffect(() => {}, [])     |
| componentDidUpdate   | useEffect(() => {}, [deps]) |
| componentWillUnmount | Cleanup function            |

## `useEffect` vs `useLayoutEffect`

| useEffect          | useLayoutEffect    |
| ------------------ | ------------------ |
| Async after paint  | Sync before paint  |
| Better performance | Can block UI       |
| Preferred          | Use only if needed |

## Best Practices

- Keep effects small
- Separate concerns (multiple effects)
- Always add dependencies
- Use cleanup when needed
- Avoid heavy logic inside effects

## Common Mistakes

- Missing dependency array
- Ignoring cleanup
- Putting business logic in render
- Overusing effects

## Real-World Use Cases

- API calls
- WebSocket connections
- Analytics tracking
- Timers & intervals
- DOM updates

## Summary

- `useEffect` handles side effects
- Runs after render
- Dependency array controls execution
- Cleanup prevents memory leaks
- Replaces lifecycle methods
