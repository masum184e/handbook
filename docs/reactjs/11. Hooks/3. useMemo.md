The `useMemo` hook is a React Hook used for performance optimization. It helps you avoid expensive recalculations by memoizing a computed value and recomputing it only when its dependencies change.

## What is `useMemo`

`useMemo` memorizes the result of a function. It returns a cached value and recalculates it only when its dependencies change.

```js
const memoizedValue = useMemo(() => computeExpensiveValue(), [dependencies]);
```

## Why Do We Need `useMemo`

In React:

- Components re-render frequently
- All functions inside a component run again on every render

If you have:

- Heavy calculations
- Large loops
- Expensive filtering or sorting

`useMemo` prevents unnecessary recalculations and improves performance.

## When Should You Use useMemo?

Use `useMemo` when:

- A calculation is expensive
- The same value is recalculated on every render
- Performance issues are noticeable
- A derived value depends on props or state
- You want referential equality for objects or arrays

Do not overuse `useMemo`. It also has a cost.

## Syntax of useMemo

```js
const memoizedValue = useMemo(() => {
  return someCalculation;
}, [dependency1, dependency2]);
```

Parameters

1. Callback function – returns the computed value
2. Dependency array – controls when recalculation happens

## How useMemo Works Internally (Concept)

- React stores the computed value
- On re-render:
  - If dependencies did not change → return cached value
  - If dependencies changed → recompute value

## Simple Example – Basic Calculation

### Without useMemo (Inefficient)

```js
function App() {
  const [count, setCount] = React.useState(0);

  const double = count * 2;

  return (
    <>
      <h2>{double}</h2>
      <button onClick={() => setCount(count + 1)}>+</button>
    </>
  );
}
```

This is fine for simple calculations.

## Expensive Calculation Example

### Slow Function

```js
function slowFunction(num) {
  console.log("Calculating...");
  for (let i = 0; i < 1e9; i++) {}
  return num * 2;
}
```

### Without `useMemo`

```js
function App() {
  const [count, setCount] = React.useState(0);
  const [text, setText] = React.useState("");

  const result = slowFunction(count);

  return (
    <>
      <h2>Result: {result}</h2>
      <input onChange={(e) => setText(e.target.value)} />
      <button onClick={() => setCount(count + 1)}>+</button>
    </>
  );
}
```

- Typing in the input causes re-render
- `slowFunction` runs every time
- App becomes slow

### With `useMemo`

```js
import { useMemo, useState } from "react";

function App() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  const result = useMemo(() => {
    return slowFunction(count);
  }, [count]);

  return (
    <>
      <h2>Result: {result}</h2>
      <input onChange={(e) => setText(e.target.value)} />
      <button onClick={() => setCount(count + 1)}>+</button>
    </>
  );
}
```

- `slowFunction` runs only when `count` changes
- Typing in input no longer triggers heavy computation
- Performance improves significantly

## `useMemo` with Arrays (Filtering Example)

Without `useMemo`

```js
const filteredUsers = users.filter((user) => user.age > 18);
```

Runs on every render.

With `useMemo`

```js
const filteredUsers = useMemo(() => {
  return users.filter((user) => user.age > 18);
}, [users]);
```

- Filter runs only when `users` changes
- Useful for large lists

## useMemo with Objects & Referential Equality

**Problem**

```js
const options = { mode: "dark" };

<ChildComponent options={options} />;
```

- New object created on every render
- Child re-renders unnecessarily

**Solution with `useMemo`**

```js
const options = useMemo(() => {
  return { mode: "dark" };
}, []);
```

**Explanation**

- Same object reference is reused
- Prevents unnecessary child re-renders

## `useMemo` vs `useCallback`

| useMemo               | useCallback             |
| --------------------- | ----------------------- |
| Memoizes a **value**  | Memoizes a **function** |
| Returns result        | Returns function        |
| Used for calculations | Used for event handlers |

```js
useCallback(fn, deps) === useMemo(() => fn, deps);
```

## Common Mistakes

- Overusing useMemo
- Using it for cheap calculations
- Missing dependencies
- Using it to fix logic bugs
