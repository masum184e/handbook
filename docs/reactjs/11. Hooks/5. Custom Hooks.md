Custom Hooks are a powerful React pattern that lets you extract, reuse, and share logic between components using React Hooks.

If you see a function that starts with `use`, uses other hooks, and returns reusable logic — that’s a custom hook.

## What is Custom Hook

A custom hook is a JavaScript function that starts with `use` and reuses stateful logic using built-in React hooks.

## Why Do We Need Custom Hooks?

Before custom hooks:

- Logic duplication across components
- Hard-to-maintain code
- Large components

Custom hooks solve this by:

- Reusing logic (DRY principle)
- Improving readability
- Separating concerns
- Making code testable

## Rules of Custom Hooks

Custom hooks follow React Hook rules:

1. Name must start with `use`
2. Can call other hooks (`useState`, `useEffect`, etc.)
3. Must not be called conditionally
4. Must be called at top level

## Basic Structure of a Custom Hook

```js
import { useState, useEffect } from "react";

function useExample() {
  const [value, setValue] = useState(null);

  useEffect(() => {
    // logic
  }, []);

  return value;
}
```

## Simple Example – useCounter

Custom Hook

```js
import { useState } from "react";

function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);

  const increment = () => setCount((c) => c + 1);
  const decrement = () => setCount((c) => c - 1);
  const reset = () => setCount(initialValue);

  return { count, increment, decrement, reset };
}
```

Using the Custom Hook

```js
function CounterComponent() {
  const { count, increment, decrement, reset } = useCounter(10);

  return (
    <div>
      <h2>{count}</h2>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}
```

## Custom Hook with `useEffect` – `useFetch`

Custom Hook

```js
import { useState, useEffect } from "react";

function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    let isMounted = true;

    setLoading(true);
    fetch(url)
      .then((res) => res.json())
      .then((data) => {
        if (isMounted) {
          setData(data);
          setLoading(false);
        }
      })
      .catch((err) => {
        if (isMounted) {
          setError(err);
          setLoading(false);
        }
      });

    return () => {
      isMounted = false;
    };
  }, [url]);

  return { data, loading, error };
}
```

Using `useFetch`

```js
function Users() {
  const { data, loading, error } = useFetch(
    "https://jsonplaceholder.typicode.com/users",
  );

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error occurred</p>;

  return (
    <ul>
      {data.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

## Custom Hook Using `useRef` – `usePrevious`

```js
import { useRef, useEffect } from "react";

function usePrevious(value) {
  const ref = useRef();

  useEffect(() => {
    ref.current = value;
  }, [value]);

  return ref.current;
}
```

Usage

```js
const prevCount = usePrevious(count);
```

## Custom Hook with Event Listener – `useWindowSize`

```js
import { useState, useEffect } from "react";

function useWindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  useEffect(() => {
    const handleResize = () => {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    };

    window.addEventListener("resize", handleResize);

    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return size;
}
```

Usage

```js
const { width, height } = useWindowSize();
```

## Custom Hook vs Component vs Utility Function

| Custom Hook            | Component   | Utility Function |
| ---------------------- | ----------- | ---------------- |
| Reuses state logic     | Reuses UI   | Pure logic       |
| Uses hooks             | Returns JSX | No hooks         |
| Returns data/functions | Renders UI  | Returns values   |

## Interview Questions

<details>
<summary>What is a custom hook</summary>
<p>
A <strong>custom hook</strong> is a JavaScript function in React that:
</p>
<ul>
  <li>Starts with the keyword <code>use</code></li>
  <li>Uses one or more built-in React hooks</li>
  <li>Encapsulates reusable stateful logic</li>
</ul>
<p>
Custom hooks allow developers to <strong>share logic</strong> between components
without duplicating code or using higher-order components.
</p>

</details>

<details>
<summary> Why must hooks start with use?</summary>
<p>
Hooks must start with <code>use</code> because:
</p>

<ul>
  <li>React uses the name to identify hook functions</li>
  <li>The Rules of Hooks rely on this naming convention</li>
  <li>Lint tools (<code>eslint-plugin-react-hooks</code>) detect incorrect usage</li>
</ul>

<p>
If a function does not start with <code>use</code>, React will treat it as a normal
function and will not enforce hook rules.
</p>
</details>

<details>
<summary>Can custom hooks return JSX?</summary>
<p>
Custom hooks are designed to:
</p>
<ul>
  <li>Share logic</li>
  <li>Manage state and side effects</li>
</ul>

<p>
They <strong>must not return JSX</strong>. Rendering UI is the responsibility of
components, not hooks.
</p>
</details>

<details>
<summary>Can hooks call other hooks?</summary>
<p>
Custom hooks can call:
</p>
<ul>
  <li><code>useState</code></li>
  <li><code>useEffect</code></li>
  <li><code>useRef</code></li>
  <li>Other custom hooks</li>
</ul>

<p>
This works because custom hooks follow the same <strong>Rules of Hooks</strong>.
</p>
</details>
