The `useRef` hook is a powerful React Hook used to persist values across renders without causing re-renders and to directly access DOM elements.

Unlike `useState`, updating a `useRef` value does not trigger a re-render.

## What is `useRef`

`useRef` returns a mutable object with a `.current` property that persists for the lifetime of the component.

```js
const ref = useRef(initialValue);
```

## Why Do We Need `useRef`

`useRef` is mainly used for:

- Accessing DOM elements directly
- Storing mutable values that should not cause re-renders
- Keeping previous values
- Storing timers, intervals, or IDs
- Avoiding re-render loops

## Syntax of useRef

```js
import { useRef } from "react";

const myRef = useRef(initialValue);
```

What It Returns

```js
{
  current: initialValue;
}
```

- `.current` is mutable
- Value persists across renders

## `useRef` vs `useState`

| useRef                   | useState         |
| ------------------------ | ---------------- |
| Does NOT cause re-render | Causes re-render |
| Mutable                  | Immutable update |
| Stores non-UI data       | Stores UI data   |
| Direct DOM access        | No DOM access    |

## Accessing DOM Elements (Most Common Use Case)

### Example: Auto Focus Input

```js
import { useRef, useEffect } from "react";

function InputFocus() {
  const inputRef = useRef(null);

  useEffect(() => {
    inputRef.current.focus();
  }, []);

  return <input ref={inputRef} />;
}

export default InputFocus;
```

- `inputRef.current` points to the input DOM element
- `.focus()` is a DOM method
- Runs once on mount

## Storing Mutable Values (Without Re-render)

Example: Render Count

```js
import { useRef } from "react";

function RenderCounter() {
  const renderCount = useRef(0);

  renderCount.current++;

  return <h2>Rendered: {renderCount.current} times</h2>;
}
```

- `renderCount.current` updates
- Component does NOT re-render due to ref change
- Value persists

### Storing Previous State Value

Example: Track Previous Count

```js
import { useRef, useEffect, useState } from "react";

function PreviousValue() {
  const [count, setCount] = useState(0);
  const prevCount = useRef(null);

  useEffect(() => {
    prevCount.current = count;
  }, [count]);

  return (
    <div>
      <h2>Current: {count}</h2>
      <h3>Previous: {prevCount.current}</h3>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}
```

- `prevCount.current` stores last value
- Updated after render
- Does not cause re-render

## Avoiding Re-render Loops

Bad Approach with `useState`

```js
const [value, setValue] = useState(0);
setValue(value + 1); // infinite loop
```

Safe with `useRef`

```js
const valueRef = useRef(0);
valueRef.current++;
```

Explanation

- Updating ref does not trigger render
- Useful for counters, flags

## Forwarding Refs (Advanced Use)

```js
const Input = React.forwardRef((props, ref) => <input ref={ref} />);
```

Explanation

- Allows parent to control child DOM
- Common in UI libraries

## useRef with Event Handlers (Avoid Stale Closures)

```js
const latestValue = useRef(value);

useEffect(() => {
  latestValue.current = value;
}, [value]);
```

Explanation

- Always holds latest value
- Useful in async callbacks

## Common Mistakes

- Expecting UI updates from useRef
- Mutating DOM unnecessarily
- Using ref instead of state
- Reading ref during render for UI logic

## Real-World Use Cases

- Focus management
- Scroll position
- Form validations
- Animations
- Measuring DOM elements
