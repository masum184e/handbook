---
sidebar_position: 23
---

Why unnecessary re-renders happen

A React component re-renders when:

- Its state changes
- Its props change
- Its parent re-renders (even if the props are logically the same)

The last point is where many performance issues sneak in.

If the data a component depends on hasn’t changed, React shouldn’t re-render it.

> To achieve this, React gives us tools like:

- `React.memo`
- `useCallback`
- `useMemo`
- Proper state placement

## Unnecessary re-renders in action

### Problematic version (unoptimized)

```jsx
function Parent() {
  const [count, setCount] = React.useState(0);

  const handleClick = () => {
    console.log("Button clicked");
  };

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child onClick={handleClick} />
    </>
  );
}

function Child({ onClick }) {
  console.log("Child rendered");
  return <button onClick={onClick}>Child Button</button>;
}
```

- Clicking the Count button updates `count`
- `Parent` re-renders (expected)
- `Child` also re-renders
- Why? Because `handleClick` is re-created on every render
- From React’s perspective, `onClick` is a new prop

### Preventing the re-render

#### 1. Memoize the child component

```jsx
const Child = React.memo(function Child({ onClick }) {
  console.log("Child rendered");
  return <button onClick={onClick}>Child Button</button>;
});
```

`React.memo` tells React:

> “Only re-render this component if its props change.”

#### 2. Stabilize the function prop with `useCallback`

```jsx
function Parent() {
  const [count, setCount] = React.useState(0);

  const handleClick = React.useCallback(() => {
    console.log("Button clicked");
  }, []);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child onClick={handleClick} />
    </>
  );
}
```
- Clicking Count updates the parent
- `handleClick` keeps the same reference
- `Child` does not re-render
- Console output confirms it

**Why this works**

- `React.memo` → skips re-render if props are shallowly equal
- `useCallback` → prevents new function instances on every render
- Together → stable props + memoized component = fewer renders
