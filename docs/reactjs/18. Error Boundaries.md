---
sidebar_position: 19
---

An Error Boundary is a React component that catches JavaScript errors in its child component tree and prevents the entire app from crashing.

> Error boundaries catch errors during rendering, lifecycle methods, and constructors of child components.

Instead of a blank screen, you can show:

- A fallback UI
- An error message
- A recovery option

**Why Do We Need Error Boundaries?**

Without error boundaries:

- A single component error crashes the whole app
- Users see a white screen
- Debugging is harder

With error boundaries:

- Errors are isolated
- App continues to work
- UX is much better

## What Error Boundaries Can and Cannot Catch

### They CAN catch:

- Errors in rendering
- Errors in lifecycle methods
- Errors in constructors of child components

### They CANNOT catch:

- Event handler errors (`onClick`, `onChange`)
- Errors in async code (`setTimeout`, `fetch`, `async/await`)
- Errors in the error boundary itself
- Server-side rendering errors

Event handlers must use `try/catch`.

> Error boundaries handle render-time errors.  
`try...catch` handles runtime async errors.

## Error Boundaries Must Be Class Components

As of now, error boundaries cannot be written with hooks.
They must be class components.

React provides two lifecycle methods for this:

- `static getDerivedStateFromError()`
- `componentDidCatch()`

1. Create an Error Boundary

```jsx
import React from "react";

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error("Error caught:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h2>Something went wrong.</h2>;
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
```

- `hasError` tracks whether an error occurred
- `getDerivedStateFromError()` updates UI state
- `componentDidCatch()` logs error details
- `children` renders wrapped components

2. Component That Throws an Error

```jsx
function BuggyComponent({ crash }) {
  if (crash) {
    throw new Error("Boom! Component crashed");
  }

  return <h3>Component is working fine</h3>;
}
```

3. Using the Error Boundary

```jsx
function App() {
  return (
    <ErrorBoundary>
      <BuggyComponent crash={true} />
    </ErrorBoundary>
  );
}
```

- `BuggyComponent` throws an error
- Error boundary catches it
- React stops rendering the broken subtree
- Fallback UI is shown instead of crashing the app

## Error Boundary Scope (Very Important)

Error boundaries only catch errors in their children, not siblings or parents.

```jsx
<ErrorBoundary>
  <ComponentA />
  <ComponentB />
</ErrorBoundary>
```

If `ComponentA` crashes:

- `ComponentB` is also replaced by fallback UI

To isolate errors, use multiple boundaries.

**Fine-Grained Error Handling**

```jsx
<ErrorBoundary>
  <Sidebar />
</ErrorBoundary>

<ErrorBoundary>
  <MainContent />
</ErrorBoundary>
```

- Sidebar errors don’t break main content
- Better fault isolation

## Handling Errors in Event Handlers

Error boundaries do not catch event handler errors.

```jsx
function ClickError() {
  function handleClick() {
    throw new Error("Click error");
  }

  return <button onClick={handleClick}>Click</button>;
}
```

Correct Way

```jsx
function ClickError() {
  function handleClick() {
    try {
      throw new Error("Click error");
    } catch (error) {
      console.error(error);
    }
  }

  return <button onClick={handleClick}>Click</button>;
}
```

## Resetting an Error Boundary

You can reset error state when props change.

```jsx
componentDidUpdate(prevProps) {
  if (prevProps.resetKey !== this.props.resetKey) {
    this.setState({ hasError: false });
  }
}
```

- Retry buttons
- Navigation changes

## Error Boundaries vs `try/catch`

| Feature        | Error Boundary | try/catch |
| -------------- | -------------- | --------- |
| Render errors  | ✅             | ❌        |
| Event handlers | ❌             | ✅        |
| Async code     | ❌             | ✅        |
| UI fallback    | ✅             | ❌        |

## Why Hooks Cannot Catch Render Errors

Hooks like `useEffect`, `useState`, and `try/catch`:

- Do NOT catch rendering errors
- Do NOT catch errors in JSX
- Do NOT replace error boundaries

Example that does NOT work:

```jsx
function BadErrorHandling() {
  try {
    throw new Error("Crash");
  } catch (e) {
    return <p>Error</p>;
  }
}
```

Why?

- React errors happen during rendering
- Rendering happens before hooks logic finishes


## Why the Async Function Is Inside useEffect

- `useEffect` callback cannot be `async`
- We define and call an async function inside it
