---
sidebar_position: 26
---

`useCallback` is a React hook used to memoize functions (including event handlers) so their reference stays the same between renders—unless their dependencies change. This helps prevent unnecessary re-renders, especially when functions are passed as props to child components.

> Functions are objects in JavaScript.  
> Every render creates a new function reference.

Even if a function’s logic doesn’t change, React sees it as “new,” which can cause:

- Memoized children (`React.memo`) to re-render
- Unnecessary updates in deeply nested components

`useCallback` solves this by caching the function.

## Example without `useCallback` (problem)

```jsx
function Parent() {
  const [count, setCount] = React.useState(0);

  const handleClick = () => {
    console.log("Clicked!");
  };

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child onClick={handleClick} />
    </>
  );
}

const Child = React.memo(function Child({ onClick }) {
  console.log("Child rendered");
  return <button onClick={onClick}>Child Button</button>;
});
```

- Clicking Count updates state
- `Parent` re-renders (expected)
- `handleClick` is re-created ❌
- `Child` re-renders even though behavior didn’t change

## Optimized version using `useCallback`

```jsx
function Parent() {
  const [count, setCount] = React.useState(0);

  const handleClick = React.useCallback(() => {
    console.log("Clicked!");
  }, []);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child onClick={handleClick} />
    </>
  );
}
```

- `useCallback` returns the same function reference
- `React.memo` sees unchanged props
- `Child` skips re-rendering
- Cleaner, faster UI updates

## Example with dependencies (realistic case)

```jsx
function Parent() {
  const [count, setCount] = React.useState(0);

  const handleClick = React.useCallback(() => {
    console.log(`Count is ${count}`);
  }, [count]);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child onClick={handleClick} />
    </>
  );
}
```

- When `count` changes, `handleClick` must change
- React re-creates the function intentionally
- This is correct behavior, not a performance issue

## Common real-world use case: list items

```jsx
const handleDelete = React.useCallback((id) => {
  setItems((items) => items.filter((item) => item.id !== id));
}, []);

return items.map((item) => (
  <Item key={item.id} item={item} onDelete={handleDelete} />
));
```

## `useCallback` vs `useMemo`

`useCallback(fn, deps)` ≈ `useMemo(() => fn, deps)`

```jsx
const memoizedFn = useCallback(() => doSomething(), []);
```

Memoizes the function reference, not the result.

## When to use `useCallback`

- Use it when
  - Passing handlers to memoized components
  - Components render frequently
  - Large component trees
- Avoid it when
  - Function is local only
  - Component is simple
  - No measurable performance gain

