---
sidebar_position: 25
---

`useMemo` is a React hook used to cache the result of an expensive computation so that it doesn’t run again on every render unless its dependencies change.

> Recalculate values only when the inputs change, not on every render.

By default, React re-runs all code inside a component every time it re-renders—even if the calculation result would be the same. `useMemo` prevents that waste.

## When computations become “expensive”

A computation is expensive when it:

- Iterates over large arrays (filtering, sorting, reducing)
- Performs complex math
- Runs frequently due to unrelated state changes

## Example without `useMemo` (problem)

```jsx
function ExpensiveComponent({ items }) {
  const [count, setCount] = React.useState(0);

  const total = items.reduce((sum, item) => {
    console.log("Calculating total...");
    return sum + item.price;
  }, 0);

  return (
    <>
      <h2>Total: {total}</h2>
      <button onClick={() => setCount(count + 1)}>Re-render ({count})</button>
    </>
  );
}
```

What’s happening?

- Clicking the button updates `count`
- Component re-renders
- `reduce` runs again ❌
- Even though `items` never changed

## Optimized version using `useMemo`

```jsx
function ExpensiveComponent({ items }) {
  const [count, setCount] = React.useState(0);

  const total = React.useMemo(() => {
    console.log("Calculating total...");
    return items.reduce((sum, item) => sum + item.price, 0);
  }, [items]);

  return (
    <>
      <h2>Total: {total}</h2>
      <button onClick={() => setCount(count + 1)}>Re-render ({count})</button>
    </>
  );
}
```

Why this works

- `useMemo` remembers the computed value
- The function runs only when `items` changes
- Updating `count` no longer triggers recalculation
- Faster renders, less CPU usage

## How `useMemo` works internally (simplified)

```jsx
useMemo(() => computeValue(), [dep1, dep2]);
```

- If `dep1` or `dep2` changed → recompute
- Otherwise → return cached value

## Common real-world example: filtering a large list

Without `useMemo`

```jsx
const filteredUsers = users.filter((user) => user.active);
```

With `useMemo`

```jsx
const filteredUsers = React.useMemo(() => {
  return users.filter((user) => user.active);
}, [users]);
```

Only recalculates when users changes.

## `useMemo` vs `useCallback`

- `useMemo` → memoizes a value
- `useCallback` → memoizes a function

```jsx
const value = useMemo(() => compute(), [deps]);
const fn = useCallback(() => doSomething(), [deps]);
```
