---
sidebar_position: 27
---

Code-splitting and lazy loading are techniques that reduce the initial JavaScript bundle size by loading code only when it’s needed. In React, this is done using `React.lazy` and `Suspense`.

The core idea

> Don’t load everything upfront.  
> Load components on demand.

Large apps often have:

- Routes users may never visit
- Heavy components (charts, editors, dashboards)

Loading all of this at once slows down the first page load. Lazy loading fixes that.

## What is `React.lazy`

`React.lazy` lets you dynamically import a component:

```jsx
const Component = React.lazy(() => import("./Component"));
```

- The component is split into a separate chunk
- It’s downloaded only when rendered

## What is `Suspense`

`Suspense` handles the loading state while the lazy component is being fetched.

```jsx
<Suspense fallback={<Loading />}>
  <LazyComponent />
</Suspense>
```

- `fallback` → UI shown during loading
- Required whenever you use `React.lazy`

## Example without code-splitting

```jsx
import Dashboard from "./Dashboard";
import Settings from "./Settings";

function App() {
  return (
    <>
      <Dashboard />
      <Settings />
    </>
  );
}
```

- Both components are bundled together
- Even if the user never opens Settings
- Slower initial load

## Optimized version with `React.lazy`

```jsx
import React, { Suspense } from "react";

const Dashboard = React.lazy(() => import("./Dashboard"));
const Settings = React.lazy(() => import("./Settings"));

function App() {
  return (
    <Suspense fallback={<p>Loading...</p>}>
      <Dashboard />
      <Settings />
    </Suspense>
  );
}
```

- Each component becomes its own bundle
- Loaded only when rendered
- Faster initial page load

## Real-world example: Route-based lazy loading

```jsx
import { BrowserRouter, Routes, Route } from "react-router-dom";
import React, { Suspense } from "react";

const Home = React.lazy(() => import("./Home"));
const Profile = React.lazy(() => import("./Profile"));
const Settings = React.lazy(() => import("./Settings"));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<h2>Loading page...</h2>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/profile" element={<Profile />} />
          <Route path="/settings" element={<Settings />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

- Home loads immediately
- Profile and Settings load only when visited
- Smaller initial bundle = faster startup

### Behind the scenes

When React sees:

```jsx
import("./Settings");
```

- Webpack/Vite creates a separate JS chunk
- Browser downloads it on demand
- Component renders once loaded

### Handling loading states gracefully

```jsx
<Suspense fallback={<Spinner />}>
  <HeavyChart />
</Suspense>
```

Best practices:

- Use skeletons or spinners
- Match fallback UI to component size
- Avoid blocking the whole app unnecessarily

## Error handling (important)

Lazy loading can fail (network issues). Use an Error Boundary:

```jsx
<ErrorBoundary>
  <Suspense fallback={<Loading />}>
    <LazyComponent />
  </Suspense>
</ErrorBoundary>
```
