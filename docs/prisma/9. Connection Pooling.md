---
sidebar_position: 9
---

A database connection is a link between your application and the database.

- Creating and tearing down a connection is expensive (it takes time and resources).
- Instead of creating a new connection for every query, a connection pool keeps a set of database connections open and reuses them.

This ensures:

- Lower latency (faster queries since no need to re-establish connections).
- Efficient resource usage (database and app aren’t overloaded with connection churn).
- Scalability (can handle many simultaneous requests).

Prisma relies on an underlying database driver (like `node-postgres` for PostgreSQL, `mysql2` for MySQL) and usually uses a pool to manage connections.

## Why Do We Need Connection Pooling

Without pooling:

- Each request to your app = opens a new database connection.
- Under load (e.g., 1000 requests/sec), this causes connection storms → database crashes or slows down.

With pooling:

- A fixed number of connections are maintained.
- Requests share these connections.
- Idle connections are reused instead of destroyed.

## Prisma and Connection Pooling

Prisma supports connection pooling through the database driver or an external pooler like PgBouncer for PostgreSQL.

There are two main strategies:

### Driver-level pooling (default)

- Prisma’s underlying database drivers (Postgres/MySQL) already manage a pool.
- Pool size can be configured via the connection string.

### External poolers (recommended for serverless)

- In serverless environments (e.g., AWS Lambda, Vercel), every function execution may create a new Prisma client, causing too many database connections.
- Solution: Use PgBouncer (for PostgreSQL) or ProxySQL (for MySQL) as an external pooler.

## Configuring Connection Pooling

You can configure pooling via the connection string:

```env
# Basic connection string
DATABASE_URL="postgresql://user:password@localhost:5432/mydb"

# With pooling options
DATABASE_URL="postgresql://user:password@localhost:5432/mydb?connection_limit=10&pool_timeout=30"
```

- `connection_limit=10` → max 10 connections in pool.
- `pool_timeout=30` → wait 30s for a free connection before erroring.

## Example of Connection Pooling

### Query without pooling (serverless issue)

```ts
// ❌ Not using pooling correctly in serverless
export default async function handler(req, res) {
  const prisma = new PrismaClient();
  const users = await prisma.user.findMany();
  res.json(users);
}
```

- Each request creates a new PrismaClient.
- Each client opens multiple DB connections.
- In high traffic, DB can exceed its max connections and crash.

### Optimized Example with Pooling

```ts
// ✅ Correct: Reuse PrismaClient instance
import { PrismaClient } from "@prisma/client";

let prisma: PrismaClient;

declare global {
  var prisma: PrismaClient | undefined;
}

if (!global.prisma) {
  global.prisma = new PrismaClient();
}
prisma = global.prisma;

export default async function handler(req, res) {
  const users = await prisma.user.findMany();
  res.json(users);
}
```

- Only one PrismaClient instance is reused.
- Prevents connection storming.
- Database connections are pooled and reused.

## Connection Pooling with PgBouncer (PostgreSQL Example)

In serverless or multi-instance apps, you should use PgBouncer for more stable pooling.

Connection string via PgBouncer:

```env
DATABASE_URL="postgresql://user:password@pgbouncer-host:6432/mydb"
```

- Instead of connecting directly to PostgreSQL, Prisma connects through PgBouncer.
- PgBouncer maintains a stable pool of connections.

## Monitoring Connection Pool

You should monitor pool usage to avoid bottlenecks.

For PostgreSQL:

```sl
SELECT * FROM pg_stat_activity;
```

For MySQL:

```sql
SHOW PROCESSLIST;
```

You can check:

- How many connections are active.
- Whether connections are waiting (indicating pool size too small).
