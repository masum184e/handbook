---
sidebar_position: 6
---

## Aggregations

These are typically used with:

- `prisma.model.aggregate()` → For overall aggregation.
- `prisma.model.groupBy()` → For grouped aggregation.

**Basic Aggregations**

```ts
const stats = await prisma.order.aggregate({
  _count: true, // counts all rows
  _avg: {
    quantity: true, // average quantity
    price: true, // average price
  },
  _sum: {
    quantity: true, // total quantity ordered
    price: true, // total sales (sum of price)
  },
  _min: {
    price: true, // minimum price in orders
  },
  _max: {
    price: true, // maximum price in orders
  },
});
```

**Filtering Aggregations**

You can add `where` conditions to aggregate only a subset.

```ts
const electronicsStats = await prisma.order.aggregate({
  where: {
    product: { contains: "Laptop" },
  },
  _count: true,
  _sum: { price: true },
  _avg: { price: true },
});
```

## Grouped Aggregations

Prisma’s `groupBy` feature is very similar to SQL’s `GROUP BY`. It allows you to group records by one or more fields and then perform aggregations (`count`, `avg`, `sum`, `min`, `max`) within each group.

The general structure is:

```ts
const result = await prisma.model.groupBy({
  by: [
    /* fields to group by */
  ],
  _count: {
    /* fields or _all */
  },
  _avg: {
    /* numeric fields */
  },
  _sum: {
    /* numeric fields */
  },
  _min: {
    /* fields */
  },
  _max: {
    /* fields */
  },
  where: {
    /* optional filters */
  },
  orderBy: {
    /* optional sorting */
  },
  having: {
    /* optional conditions after aggregation */
  },
  take: 10, // optional limit
  skip: 5, // optional offset
});
```

**Group by multiple fields**

```ts
const grouped = await prisma.order.groupBy({
  by: ["product", "createdAt"],
  _count: { _all: true },
  _sum: { price: true },
});
```

## Distinct Queries

The `distinct` option is available in the `findMany` query.

```ts
const result = await prisma.model.findMany({
  distinct: ['field1', 'field2'],
  where: { ... },     // optional filter
  orderBy: { ... },   // optional sorting
  take: 10,           // optional limit
  skip: 5             // optional offset
});
```

- `distinct: ['field']` → removes duplicate rows based on a single field.
- `distinct: ['field1', 'field2']` → removes duplicates based on the combination of multiple fields.
- Duplicates are removed at the query level, not after fetching.

## Raw Database Queries

Prisma provides `$queryRaw` and `$executeRaw` for cases where the Prisma Client API is not enough. These methods allow you to run raw SQL queries directly against the database, while still benefiting from Prisma’s type-safety (when used safely).

### Raw Queries

Although Prisma’s query engine covers most use cases (CRUD, filtering, aggregations, groupBy), sometimes you need:

- Complex SQL joins not supported in Prisma.
- Database-specific functions (e.g., `ILIKE`, `JSONB` in Postgres).
- Optimized queries for performance.
- Running migrations, stored procedures, or advanced reporting.

### Raw Query Methods

1. `$queryRaw`
   - Used for SELECT queries (reading data).
   - Returns rows from the database.
2. `$executeRaw`
   - Used for non-SELECT queries (INSERT, UPDATE, DELETE).
   - Returns the number of affected rows.

### Safe vs Unsafe Raw Queries

Prisma has two forms:

- Safe (Tagged Template) → Prevents SQL injection.

  ```ts
  await prisma.$queryRaw`SELECT * FROM "Order" WHERE id = ${orderId}`;
  ```

  Prisma automatically escapes variables.

- Unsafe (Function form) → Use only when necessary.
  ```ts
  await prisma.$queryRawUnsafe('SELECT * FROM "Order" WHERE id = ' + orderId);
  ```
  Vulnerable if user input is concatenated.Safe vs Unsafe Raw Queries
