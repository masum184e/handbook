---
sidebar_position: 5
---

Prisma Client is the auto-generated database client that Prisma creates based on your `schema.prisma`.

- It lets you interact with your database using JavaScript/TypeScript methods (instead of raw SQL).
- It’s type-safe: if you use TypeScript, Prisma knows your schema and will catch mistakes at compile time.
- It supports all CRUD (Create, Read, Update, Delete) operations.
- It’s database-agnostic → works with PostgreSQL, MySQL, SQLite, MongoDB, etc.

You don’t write Prisma Client code by hand. Instead, you define your schema → Prisma generates the client for you → then you import and use it.

## How Prisma Client is Generated

When you run:

```bash
npx prisma generate
```

Prisma:

1. Reads your `schema.prisma` file.
2. Generates the Prisma Client in `node_modules/.prisma/client`.
3. Makes it available as `@prisma/client` for you to use.
4. You can now use Prisma Client in your code

## Using Prisma Client

First, import and initialize:

```ts
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();
```

Now you can access your models as methods:

- `prisma.user` → for the `User` model.
- `prisma.post` → for the `Post` model.

Each model automatically gets CRUD functions like: `.create()`, `.findMany()`, `.findUnique()`, `.update()`, `.delete()`

- Keep `datasource` and `generator` at the top of `schema.prisma` (before `model`s).
- Use one `datasource` per project (Prisma currently doesn’t support multiple DBs in one schema).
- You can have multiple `generator`s (e.g., one for Prisma Client, one for GraphQL schema).

## CRUD

### Create

The `create` method requires you to pass a `data` object that matches your Prisma schema model fields. Only required fields must be provided; optional fields can be omitted or set to `null` if allowed.

```ts
const createdRecord = await prisma.modelName.create({
  data: {
    field1: value1,
    field2: value2,
    // ... other fields
  },
});
```

- `prisma.modelName` → Replace `modelName` with your Prisma model (e.g., `user`, `post`).
- `data` → Object containing the data for the new record.
- Returns the newly created record.

**Nested Writes:**

Prisma supports creating related records in one query

```prisma
model Post {
  id      Int    @id @default(autoincrement())
  title   String
  content String?
  author  User   @relation(fields: [authorId], references: [id])
  authorId Int
}
```

Create a user with a post

```ts
const newUserWithPost = await prisma.user.create({
  data: {
    name: "Charlie",
    email: "charlie@example.com",
    posts: {
      create: { title: "My first post", content: "Hello World!" },
    },
  },
  include: {
    posts: true, // return posts as well
  },
});
```

### Read

| Method       | Purpose                                                                      |
| ------------ | ---------------------------------------------------------------------------- |
| `findUnique` | Fetch **one record** by a **unique field** (like `id` or unique column).     |
| `findMany`   | Fetch **multiple records**, optionally filtered, sorted, or paginated.       |
| `findFirst`  | Fetch the **first record** that matches a filter, if multiple records match. |

#### `findUnique`

- Retrieve a single record by a unique field.
- Returns `null` if no record matches.

```ts
const user = await prisma.user.findUnique({
  where: {
    email: "alice@example.com", // must be a unique field
  },
});
```

#### `findMany`

Retrieve multiple records, with optional filters, sorting, and pagination.

```ts
const users = await prisma.user.findMany({
  where: {
    age: {
      gte: 18, // users with age >= 18
    },
  },
  orderBy: {
    name: "asc", // sort by name ascending
  },
  skip: 0, // skip first N records
  take: 10, // limit number of records
});
```

#### `findFirst`

- Retrieve the first record that matches a filter.
- Returns a single record or `null`.

```ts
const firstAdult = await prisma.user.findFirst({
  where: { age: { gte: 18 } },
  orderBy: { age: "asc" }, // the "first" one according to this order
});
```

#### Nested Reads

```ts
const userWithPosts = await prisma.user.findUnique({
  where: { id: 1 },
  include: { posts: true }, // include related posts
});

console.log(userWithPosts);
```

If you don’t need all fields, use `select` for fine-grained control.

```ts
const posts = await prisma.post.findMany({
  select: {
    title: true,
    author: {
      select: { name: true }, // only get author's name
    },
    comments: {
      select: { text: true }, // only get comment text
    },
  },
});

console.log(posts);
```

This is similar to SQL joins or ORM features like `populate` (Mongoose) or `include` (Sequelize/TypeORM).

If you want:

- A user’s details
- AND all of their posts

You have two options:

1. Lazy Loading (multiple queries):

- Query the user
- Then separately query the posts

2. Eager Loading (include):

- Fetch user with posts in one Prisma query

### Update

The `update` operation is used to modify existing records in the database. Prisma Client provides:

- `update` → Update a single record identified by a unique field.
- `updateMany` → Update multiple records at once (optional, returns count of updated records).

Key points:

- You must provide a unique identifier (`where`) for `update`.
- The `data` object contains the fields you want to modify.
- Prisma automatically validates field types and constraints.

**Single Records Update**

```ts
const updatedRecord = await prisma.modelName.update({
  where: {
    uniqueField: value, // e.g., id or email
  },
  data: {
    field1: newValue1,
    field2: newValue2,
    // ...other fields
  },
});
```

**Multiple Record Update**

```ts
const result = await prisma.modelName.updateMany({
  where: { age: { lt: 18 } }, // filter records to update
  data: { isMinor: true },
});

console.log(result.count); // number of records updated
```

- Returns `{ count: number }` indicating how many records were updated.
- Cannot return the updated records themselves (use `findMany` afterwards if needed).

**Nested Record Updated:**

Update a post and change its author name in a nested update

```ts
const updatedPost = await prisma.post.update({
  where: { id: 1 },
  data: {
    title: "Updated Post Title",
    author: {
      update: { name: "Updated Author Name" }, // nested update
    },
  },
});

console.log(updatedPost);
```

- Prisma allows nested updates if relations are defined.
- Both the record and its related records can be updated in one query.

### Delete

| Method       | Purpose                                                                    |
| ------------ | -------------------------------------------------------------------------- |
| `delete`     | Delete a **single record** by a unique field (like `id` or unique column). |
| `deleteMany` | Delete **multiple records** that match a filter.                           |

- `delete` requires a unique identifier (`where`) to locate the record.
- `deleteMany` allows filtering multiple records.

**Single Record Delete**

```ts
const deletedRecord = await prisma.modelName.delete({
  where: {
    uniqueField: value, // e.g., id or email
  },
});
```

- Prisma returns the deleted record.
- If no record matches, Prisma throws an error.

**Multiple Record Delete**

```ts
const result = await prisma.modelName.deleteMany({
  where: { age: { lt: 18 } }, // delete users under 18
});

console.log(result.count); // number of records deleted
```

- Returns `{ count: number }` indicating the number of records deleted.
- If no records match, `count` is 0.

**Cascading Deletes**

Assume a `Post` model related to `User`:

```prisma
model Post {
  id       Int    @id @default(autoincrement())
  title    String
  content  String?
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId Int
}
```

If `onDelete: Cascade` is set, deleting a user automatically deletes all their posts:

```ts
const deletedUser = await prisma.user.delete({
  where: { id: 2 },
});

console.log("Deleted user and their posts:", deletedUser);
```

- Cascading deletes are controlled by the schema relation.
- Without `Cascade`, deleting a parent may fail if child records exist.
## Upsert
**Upsert = Update + Insert**

It’s a single database operation that:

- Updates a record if it already exists.
- Creates a new record if it doesn’t exist.

This is super useful when you don’t know whether the record is already in the database, and you want to ensure that either way, you end up with a record in the right state — without having to run multiple queries (`find → update/create`).

```prisma
prisma.modelName.upsert({
  where: { uniqueField: value },
  update: { ...fieldsToUpdate },
  create: { ...fieldsToCreate },
})
```
- `where`: Defines the unique identifier to check if the record exists. It must be a unique field (like id or a field with a unique constraint).
- `update`: What to update if the record already exists.
- `create`: What to insert if the record doesn’t exist.

## Pagination
### Offset-based Pagination
This is the most common (and simple) type of pagination.

- `skip`: number of records to skip.
- `take`: number of records to return (positive = forward, negative = backward).

```ts
const users = await prisma.user.findMany({
  skip: 5,   // skip the first 5
  take: 5,   // get the next 5
})
```
### Cursor-based Pagination
Instead of skipping records (which can get slow on large datasets), cursor pagination starts from a specific record.

- `cursor`: defines the starting point (requires a unique field).
- `skip`: often used with cursor to move past the cursor item.
- `take`: how many to fetch from that point.

```ts
const users = await prisma.user.findMany({
  cursor: { id: 10 }, // start at user with id=10
  skip: 1,            // skip that cursor item itself
  take: 5,            // fetch 5 after it
})
```
## Lazy Loading

In traditional ORMs, lazy loading means related records are only fetched when you explicitly access them, often through a proxy object.

Example (in Sequelize/TypeORM-like systems):

```ts
const user = await User.findOne({ where: { id: 1 } });
const posts = await user.posts; // triggers a new SQL query on access
```

But Prisma does not support true lazy loading.

Why?

Because Prisma returns plain JavaScript objects (not “live” model instances with proxies). Once the query is executed, Prisma doesn’t keep a connection between objects and the database.

### Prisma’s Alternatives to Lazy Loading

Since Prisma doesn’t provide automatic lazy loading, you have two main alternatives:

#### Eager Loading with `include`

Fetch related records together with the parent in one query.

```ts
const userWithPosts = await prisma.user.findUnique({
  where: { id: 1 },
  include: {
    posts: true, // eager load relation
  },
});

console.log(userWithPosts);
```

#### Explicit Separate Queries (Manual Lazy Loading)

Instead of Prisma automatically lazy loading, you can explicitly query related data when you need it. This mimics lazy loading.

```ts
// Step 1: Load user only
const user = await prisma.user.findUnique({
  where: { id: 1 },
});

console.log(user);

// Step 2: Later, only when needed, load posts
const posts = await prisma.post.findMany({
  where: { authorId: user?.id },
});

console.log(posts);
```

- Avoids over-fetching unnecessary data.
- Two queries (can lead to N+1 problem if repeated in loops).

#### Batching with `Prisma.$transaction`

If you want to mimic lazy loading but avoid multiple round-trips, you can batch queries.

```ts
const [user, posts] = await prisma.$transaction([
  prisma.user.findUnique({ where: { id: 1 } }),
  prisma.post.findMany({ where: { authorId: 1 } }),
]);

console.log(user, posts);
```

- Still two queries, but batched together → fewer network round trips.
- Better performance than doing them separately.

### Dataloader Pattern (N+1 Solution)

If you need lazy-like loading for many records, you can integrate Prisma with DataLoader.

Example use case: In GraphQL resolvers, instead of fetching posts per user individually (N+1 problem), batch them.

```ts
import DataLoader from "dataloader";

// Create a DataLoader for posts by userId
const postsLoader = new DataLoader(async (userIds: number[]) => {
  const posts = await prisma.post.findMany({
    where: { authorId: { in: userIds } },
  });

  // group by authorId
  return userIds.map((id) => posts.filter((p) => p.authorId === id));
});

// Usage
const user = await prisma.user.findUnique({ where: { id: 1 } });
const posts = await postsLoader.load(user.id);

console.log(user, posts);
```
