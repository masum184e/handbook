---
sidebar_position: 8
---

## Atomic Operations

Atomic operations in Prisma refer to operations that are executed as a single, indivisible action inside the database. This means either the whole operation succeeds, or it fails without partially applying changes.

They are particularly useful when you want to update a field relative to its current value (like increment, decrement, multiply, divide, push, etc.) instead of overwriting it manually.

Atomic operations ensure that these updates are safe even under concurrent database access (no race conditions).

### Why use Atomic Operations?

- **Prevent race conditions:** Two users incrementing a likes counter at the same time won’t overwrite each other’s update.
- **Cleaner & safer code:** You don’t have to read → modify → write, Prisma does it in one atomic step.
- **Performance:** Saves extra queries because the modification happens directly in the database.

### Common Atomic Operations

These are used mostly in `update` and `updateMany` queries:

- `increment` → Adds a value to a number field
- `decrement` → Subtracts a value from a number field
- `multiply` → Multiplies a number field
- `divide` → Divides a number field
- `set` → Sets the value directly
- `push` → Appends values to an array field (PostgreSQL, MongoDB, etc.)

### Incrementing a counter safely

Suppose we have a `Post` model:

```prisma
model Post {
  id        Int    @id @default(autoincrement())
  title     String
  views     Int    @default(0)
}
```

Now, if you want to increment the `views` count every time someone reads the post:

```prisma
await prisma.post.update({
  where: { id: 1 },
  data: {
    views: {
      increment: 1, // increases by 1 atomically
    },
  },
});
```

### Batch Operations

In Prisma, batch operations mean executing multiple database queries together in a single transaction.

This is done with `prisma.$transaction()`, where you can pass an array of queries.

Key property:

- Either all queries succeed (commit)
- Or if one fails, everything rolls back (no partial changes).

This is critical when you want to maintain data consistency.

**Syntax**

```prisma
await prisma.$transaction([
  prisma.model1.create(...),
  prisma.model2.update(...),
  prisma.model3.delete(...),
]);
```

**Important Notes**

1. `prisma.$transaction()` can accept:
   - An array of queries (batch mode).
   - A callback function (interactive transactions, for more complex logic).
2. Batch transactions are atomic → all queries succeed or none.
3. Useful for:
   - Bulk inserts
   - Multi-table consistency
   - Money transfers / stock updates
   - Running multiple reads efficiently

## Interactive transactions

So far, we’ve seen batch transactions (where you pass an array of queries to `prisma.$transaction([])`).
But sometimes you need more control:

- Run conditional logic inside a transaction
- Perform multiple dependent queries (where later queries depend on earlier results)
- Ensure all-or-nothing execution even with complex application logic

That’s where Interactive Transactions come in.

They use a callback form of `prisma.$transaction()`.
Prisma gives you a special `tx` client that you must use inside the transaction.

**Syntax**

```ts
await prisma.$transaction(async (tx) => {
  // use tx instead of prisma
  const user = await tx.user.create(...);
  const post = await tx.post.create(...);
  return { user, post };
});
```

- The callback runs in a single database transaction.
- If any query fails (or you throw an error), the whole transaction rolls back.
- If everything succeeds, Prisma commits the transaction.

**Why Interactive Transactions**

- Conditional logic: e.g., only create a record if a check passes.
- Dependent queries: e.g., create a user, then use their ID for a post.
- Business rules: e.g., don’t let someone overspend.
- Complex workflows: more than just independent queries.

**Key Notes**

- Always use the `tx` client inside the callback, not the global `prisma`.
- If an error is thrown, Prisma rolls back automatically.
- You can add custom logic (loops, conditionals, validations) inside the transaction.
- Transactions are time-limited → by default, Prisma sets a timeout (usually 5s), but you can configure it.
- Not all databases handle interactive transactions identically — e.g., in MongoDB, only replica sets/sharded clusters support transactions.
