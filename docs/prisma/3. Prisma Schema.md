---
sidebar_position: 3
---

## Datasource Block

The `datasource` block defines the connection between Prisma and your database.
It tells Prisma:

- Which database provider you’re using (PostgreSQL, MySQL, SQLite, MongoDB, etc.)
- Where the database is located (connection URL)

```prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
```

- `db` → the name of the datasource (commonly just `db`).
- `provider` → which database engine Prisma should use. Options include: `"postgresql"`,`"mysql"`,`"sqlite"`,`"mongodb"`,`"cockroachdb"`
- `url` → tells Prisma where to connect. Usually `env("DATABASE_URL")` is used to load it from `.env`.

MongoDB support in Prisma is different — relations work differently since MongoDB is NoSQL.

## Generator Block

The `generator` block defines what Prisma should generate based on your schema.

Most common generator:

```prisma
generator client {
  provider = "prisma-client-js"
}
```

This generates the Prisma Client → a type-safe database client you can import in your code (`import { PrismaClient } from '@prisma/client'`).

- `client` → the name of the generator.
- `provider` → the tool to generate. Options:
  - `"prisma-client-js"` → generates Prisma Client (JS/TS API).
  - `"prisma-client-go"` (community) → generates Prisma Client for Go.
  - Other community generators: GraphQL schema, JSON schema, etc.

Optional configs:

- `previewFeatures` → enable experimental features.
- `binaryTargets` → specify environments to generate for (useful in deployment).

## Model

- A model in Prisma describes the structure of a table in your database.
- Each model becomes:
  - A table in SQL databases (PostgreSQL, MySQL, SQLite).
  - A collection in MongoDB.
- Each field inside the model becomes a column (SQL) or a document property (MongoDB).

```prisma
model User {
  id    Int     @id @default(autoincrement())
  name  String
  email String  @unique
}
```

- `model User {}` → defines a table called User.
- `id Int @id @default(autoincrement())`
  - `id` → field name
  - `Int` → data type
  - `@id` → marks this as primary key
  - `@default(autoincrement())` → automatically increases for each new row
- `name String` → required string column
- `email String @unique` → column must be unique (like an email should be)

## Scalar Types

Prisma supports common scalar types:

| Prisma Type | Maps To (SQL)      | Example              |
| ----------- | ------------------ | -------------------- |
| `Int`       | INTEGER            | `id Int`             |
| `String`    | VARCHAR/TEXT       | `name String`        |
| `Boolean`   | BOOLEAN            | `isActive Boolean`   |
| `DateTime`  | TIMESTAMP/DateTime | `createdAt DateTime` |
| `Float`     | FLOAT/DOUBLE       | `price Float`        |
| `Decimal`   | DECIMAL (exact)    | `amount Decimal`     |
| `Json`      | JSON column        | `meta Json`          |
| `Bytes`     | BLOB/BYTEA         | `file Bytes`         |

Prisma also supports lists (`String[]`, `Int[]`) for multi-value fields and for optional field `?`.

- Scalar = primitive type (like `String`, `Int`, `Boolean`).
- They describe the shape of a single field in your Prisma model.
- Prisma maps these scalars to the closest database-native column types depending on your provider (PostgreSQL, MySQL, SQLite, MongoDB).

## Attributes with Scalars

Attributes add extra rules to fields.

| Attribute                | Meaning                                  |
| ------------------------ | ---------------------------------------- |
| `@id`                    | Primary key                              |
| `@unique`                | Unique constraint                        |
| `@default(value)`        | Default value (e.g. `@default("Guest")`) |
| `@default(now())`        | Default timestamp                        |
| `@updatedAt`             | Auto-update timestamp on update          |
| `@map("db_column_name")` | Map to different DB column name          |
| `@relation(...)`         | Define foreign keys/relations            |

## Relations Between Models

### One-to-One

```prisma
model User {
  id     Int     @id @default(autoincrement())
  email  String  @unique
  profile Profile?
}

model Profile {
  id     Int    @id @default(autoincrement())
  bio    String?
  user   User   @relation(fields: [userId], references: [id])
  userId Int    @unique
}
```

- `User` has one Profile (not required, so `Profile?`).
- `Profile` belongs to one User (`userId Int`).
- `@unique` on `userId` ensures 1:1 (each profile can only link to one user).
- Foreign key: `Profile.userId → User.id`.

SQL result:

- `User` table → has no direct profileId.
- `Profile` table → has userId foreign key pointing to User.id.

### One to Many

```prisma
model User {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[]
}

model Post {
  id       Int   @id @default(autoincrement())
  title    String
  content  String?
  author   User  @relation(fields: [authorId], references: [id])
  authorId Int
}
```

- `User` has many `posts` → (`posts Post[]`).
- Each `Post` belongs to one `User` → (`authorId Int`).
- `@relation(fields: [authorId], references: [id])` defines the foreign key.

SQL result:

- `User` table → normal table with user info.
- `Post` table → includes `authorId` foreign key.

### Many to Many

Prisma creates a join table automatically (if not customized).

```prisma
model Student {
  id      Int      @id @default(autoincrement())
  name    String
  courses Course[] @relation("Enrollments")
}

model Course {
  id       Int       @id @default(autoincrement())
  title    String
  students Student[] @relation("Enrollments")
}
```

- Each `Student` can enroll in many Courses.
- Each `Course` can have many Students.
- Prisma automatically creates a join table:
  ```
  _StudentToCourse
  ----------------
  studentId
  courseId
  ```
- The `@relation("Enrollments")` is optional, but naming helps when multiple relations exist between same models.

### Optional vs Required Relations

- Optional relation → `fieldName?` → can be null.
- Required relation → `fieldName` → must exist.

## Model-Level Attributes

Applied to the whole model.

| Attribute         | Meaning                     |
| ----------------- | --------------------------- |
| `@@map("table")`  | Map to custom table name    |
| `@@unique([a,b])` | Composite unique constraint |
| `@@index([a,b])`  | Index on fields             |
| `@@id([a,b])`     | Composite primary key       |

```prisma
model Order {
  orderId   Int
  productId Int
  quantity  Int
  @@id([orderId, productId])   // composite primary key
}
```

## Enum

- An enum defines a set of constant values.
- Prisma generates a TypeScript enum when you use Prisma Client, so you get type-safety in your queries.

In `schema.prisma`:

```prisma
enum Role {
  USER
  ADMIN
  MODERATOR
}
```

- `enum Role {}` → defines an enum called `Role`.
- Possible values: `USER`, `ADMIN`, `MODERATOR`.
- These values are stored as strings in the DB (depending on the provider).

**Using Enums in a Model**

```prisma
model User {
  id    Int   @id @default(autoincrement())
  name  String
  role  Role  @default(USER)
}
```

**Querying Enums with Prisma Client**

```ts
await prisma.user.create({
  data: {
    name: "Alice",
    role: Role.ADMIN,
  },
});
```

## Indexes

- Index: A database structure that speeds up queries for specific columns.
  - Does not enforce uniqueness by default.
  - Useful for searching, filtering, and sorting.

**Single-field Index**

```prisma
model Post {
  id        Int      @id @default(autoincrement())
  title     String
  createdAt DateTime

  @@index([title])
}
```

**Multi-field Index (Composite Index)**

```prisma
model Post {
  id        Int      @id @default(autoincrement())
  title     String
  published Boolean
  createdAt DateTime

  @@index([title, published])
}
```

## Unique Constraints

- Unique Constraint: Ensures that the column (or combination of columns) cannot have duplicate values.
  - Automatically creates an index.
  - Ensures data integrity (e.g., emails, usernames).

**Single-field Unique Constraint**

```prisma
model User {
  id    Int    @id @default(autoincrement())
  email String @unique
  name  String
}
```

**Multi-field Unique Constraint (Composite Unique)**

```prisma
model Order {
  orderId   Int
  productId Int
  quantity  Int
  @@unique([orderId, productId])
}
```

- Unique constraints automatically create an index.
- Indexes are for performance, uniqueness is for data integrity.
- You can have multiple indexes on a table without affecting uniqueness.

## Primary Key

### Single-field

- `@id` marks a field as the primary key.
- The primary key uniquely identifies each row in a table.
- Automatically indexed by the database.

### Compound (Multi-field)

- `@@id` defines a primary key consisting of multiple fields.
- Useful when no single field is unique, but a combination of fields is.
- Prisma supports this using model-level attributes.

```prisma
model Order {
  orderId   Int
  productId Int
  quantity  Int

  @@id([orderId, productId])   // compound primary key
}
```

- Primary key is both `orderId` and `productId` together.
- A single `orderId` or `productId` can repeat, but the combination must be unique.
- No need for `@id` on individual fields when using `@@id`.

### Best Practices

- Use `@id` for auto-increment numeric IDs → simpler and recommended for most tables.
- Use `@@id` for join tables or when no single field is unique.
- Always consider querying patterns — compound keys may require multiple columns in `WHERE` clauses.
