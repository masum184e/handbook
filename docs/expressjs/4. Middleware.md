---
title: Middleware
sidebar_position: 4
---

In Express.js, middleware are functions that run during the request-response lifecycle.

These functions can:

- Modify the `request` and resp`onse objects
- Execute code or perform operations
- End the request-response cycle
- Pass control to the next middleware function in the stack

In short, middleware process incoming requests before they reach your route handlers, allowing you to handle tasks like logging, authentication, or data parsing in a centralized way.

## Key Features

1. **Function Signature:**

   ```ts
   function middleware(req, res, next) {
     // Your custom logic here
     next(); // Call the next middleware in the stack
   }
   ```

   - `req`: The request object.
   - `res`: The response object.
   - `next()` → A function that calls the next middleware.
     - If you don’t call `next()`, the request will hang (no response).

2. **Stacking:**

   - Middleware functions are stacked and executed in the order they are defined in the application.

3. **Tasks Middleware Can Perform:**

   - Execute any code.
   - Modify the request (`req`) or response (`res`) objects.
   - End the request-response cycle (e.g., sending a response).
   - Call the `next()` function to pass control to the next middleware.

## Types of Middleware in Express

Middleware functions are executed in the order they are defined. They can run for every request, specific routes, or handle errors.

### 1. Application-level middleware

Defined globally with `app.use()`, runs for every request.

```ts
import express, { Request, Response, NextFunction } from "express";
const app = express();

app.use((req: Request, res: Response, next: NextFunction) => {
  console.log(`${req.method} request → ${req.url}`);
  next(); // Continue to the next middleware or route handler
});
```

### 2. Built-in middleware

Express provides ready-to-use middleware like `express.json()` and `express.static()`.

```ts
// Parses incoming JSON request bodies
app.use(express.json());
```

### 3. Router-level middleware

Runs only on specific routes or routers.

```ts
app.get(
  "/about",
  (req: Request, res: Response, next: NextFunction) => {
    console.log("Middleware specific to /about");
    next();
  },
  (req: Request, res: Response) => {
    res.send("About Page");
  }
);
```

### 4. Third-party middleware

Installed via npm, e.g., `cookie-parser`, `morgan`, `cors`.

```ts
import morgan from "morgan";
app.use(morgan("dev")); // Logs HTTP requests
```

### 5. Error-handling middleware

Special middleware with 4 parameters. Must be placed after all routes.

```ts
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  console.error("Error:", err.message);
  res.status(500).send("Something went wrong!");
});
```

### Middleware Flow

1. Incoming request → application-level middleware
2. Passes through built-in/third-party middleware
3. Runs router-level middleware (if any)
4. Executes route handler
5. If errors occur → handled by error-handling middleware
6. Sends response back to client

## How Middleware Works

When a request is sent to the server, Express processes it through the middleware stack. Middleware functions are executed sequentially in the order they are defined. If a middleware function calls `next()`, the next function in the stack is executed. If a middleware function doesn’t call `next()`, the request-response cycle is terminated.

## Built-In Middleware

- `express.json()`

  - Parses incoming JSON payloads and makes the data available in `req.body`.

    ```ts
    app.use(express.json());
    ```

- `express.urlencoded()`

  - Parses incoming requests with URL-encoded payloads (`Content-Type: application/x-www-form-urlencoded`) (like form submissions) and makes the data available in req.body.

    ```ts
    app.use(express.urlencoded({ extended: true })); // Parse URL-encoded form data
    ```

    - Takes an option:
      - `{ extended: true }` → allows nested objects using `qs` library.
      - `{ extended: false }` → only supports simple key-value pairs.

- `express.static()`

  - Serves static files like images, CSS, and JavaScript.

    ```ts
    app.use(express.static(path.join(__dirname, "public")));
    ```

- `express.text()`

  - Parses incoming requests with text payloads and makes the text available in `req.body`.

    ```ts
    app.use(express.text());
    ```

- `express.raw()`

  - Parses incoming requests with binary payloads and makes the raw buffer available in `req.body`.

    ```ts
    app.use(express.raw({ type: "application/octet-stream" }));
    ```

## Third-Party Middleware

### Morgan (HTTP request logger)

- Logs HTTP requests in the console (or a file).
- Useful for debugging and monitoring.

```ts
app.use(morgan("dev"));
```

Logs incoming HTTP requests in a short colored format.

```bash
GET /users 200 12ms
POST /login 201 25ms
```

**Format options**

When you call `morgan()`, you must provide a format argument.
This defines how logs are displayed.

- Built-in strings:
  - `"combined"` → Apache-style logs (with referrer & user-agent)
  - `"common"` → Shorter Apache-style logs
  - `"dev"` → Color-coded concise logs
  - `"short"` → Shorter than common
  - `"tiny"` → Minimal output
- Or, you can pass a formatting function: `(tokens, req, res) => string`

### CORS (Cross-Origin Resource Sharing)

- Controls which domains can access your API.
- By default, browsers block requests from different origins.
- `cors()` middleware allows you to enable or restrict access.

```ts
app.use(cors()); // Allow all origins
app.use(cors({ origin: "https://example.com" })); // Restrict to specific domain
```

### Helmet (Security)

- Sets HTTP headers to secure your app from common attacks.
- Examples of headers it sets:
  - `X-DNS-Prefetch-Control`
  - `X-Frame-Options`
  - `Strict-Transport-Security`
- Simple way to improve security best practices.

```ts
app.use(helmet());
```

- Adds multiple security-related HTTP headers automatically.
- Helps prevent common attacks like clickjacking, XSS, and MIME-sniffing.

## Middleware Execution Order

- Middleware functions in Express execute in the order they are added in your code.
- The request flows top to bottom until:
  1. A response is sent (`res.send`, `res.json`, etc.), or
  2. `next()` is called to pass control to the next middleware.
