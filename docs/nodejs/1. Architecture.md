Node.js is a runtime environment that allows you to run JavaScript outside the browser, mainly on the server.

Before Node.js

- JavaScript was mostly used only in browsers
- Servers were written in languages like Java, PHP, Python, or C#
- JS handled UI interactions, not backend logic

After Node.js

- JavaScript can run on the server
- You can build: Web servers, APIs, Real-time apps (chat, streaming), Command-line tools
- Same language for frontend + backend (JavaScript)

Node.js is built on Google’s V8 JavaScript engine, which makes it very fast.

## Key Characteristics of Node.js

1. Single-threaded
2. Asynchronous
3. Event-driven
4. Non-blocking I/O
5. Highly scalable

The most important concept here is event-driven architecture, so let’s dive deep into that.

## What is Event-Driven Architecture?

In an event-driven system, the program waits for events and responds to them when they occur, instead of executing tasks one by one and waiting for each to finish.

### What is an Event?

An event is an action or occurrence, such as:

- A user sends a request
- A file finishes reading
- A database query completes
- A timer expires

## Traditional (Blocking) vs Node.js (Non-Blocking)

### Traditional Blocking Model

Imagine a restaurant with one waiter:

1. Customer A orders food
2. Waiter waits in the kitchen until food is ready
3. Customer B must wait
4. Slow and inefficient

### Node.js Non-Blocking Model

Still one waiter, but smarter:

1. Customer A orders food
2. Waiter sends order to kitchen and doesn’t wait
3. Takes order from Customer B
4. When food is ready, kitchen notifies the waiter
5. Efficient and fast

This is event-driven architecture in action.

## Core Components of Node.js Event-Driven Architecture

### Event Loop

The event loop is the heart of Node.js.

- Continuously checks for completed tasks
- Executes their callback functions
- Keeps the application running

### Callback Queue

- Stores functions waiting to be executed
- Example: “File read finished → run this function”

### Events & Callbacks

- An event happens (file read completed)
- A callback function is executed in response

## How the Event Loop Works (Step-by-Step)

1. Client sends a request
2. Node.js receives it
3. Long tasks (file I/O, DB calls) are delegated to the system
4. Node.js continues handling other requests
5. When a task completes, an event is triggered
6. The callback is pushed into the queue
7. Event loop executes it

## Simple Event-Driven Example (Basic)

setTimeout (Event + Callback)

```
console.log("Start");

setTimeout(() => {
  console.log("This runs after 2 seconds");
}, 2000);

console.log("End");
```

Output:

```
Start
End
This runs after 2 seconds
```

- `setTimeout` registers an event
- Node.js doesn’t wait for 2 seconds
- The callback is executed later by the event loop

## Real Event-Driven Example: HTTP Server

Simple Node.js Server

```
const http = require("http");

const server = http.createServer((req, res) => {
  // This function runs when a request event occurs
  res.writeHead(200, { "Content-Type": "text/plain" });
  res.end("Hello from Node.js!");
});

server.listen(3000, () => {
  console.log("Server running on port 3000");
});
```

- `createServer` listens for request events
- Each request triggers the callback
- Node.js handles many requests without blocking

## EventEmitter: Core of Event-Driven Design

Node.js has a built-in EventEmitter class.

Example 3: Custom Events

```
const EventEmitter = require("events");

const myEmitter = new EventEmitter();

// Register event listener
myEmitter.on("order", () => {
  console.log("Order received!");
});

// Emit event
myEmitter.emit("order");
```

1. `on()` → listens for an event
2. `emit()` → triggers the event
3. Callback runs when event occurs

## Why Event-Driven Architecture is Powerful

Advantages

- Handles many users efficiently
- High performance
- Ideal for real-time apps
- Uses fewer system resources

Disadvantages

- Not ideal for CPU-heavy tasks
- Harder to debug async code
