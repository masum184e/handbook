The `events` module is a core Node.js module that provides the `EventEmitter` class.

It lets you build systems based on events instead of direct function calls.

In simple words

> “When something happens, notify whoever is listening.”

This is the backbone of:

- HTTP servers
- Streams
- File system
- Process events
- Many libraries

## Event-Driven Programming (Big Picture)

Instead of this (tight coupling):

```
doSomething();
doAnotherThing();
```

You do this (loose coupling):

```
emitter.emit("done");
```

And multiple listeners can react independently.

```
Event emitted ──▶ Listener 1
               ──▶ Listener 2
               ──▶ Listener 3
```

## Creating an EventEmitter

Basic Example

```
const EventEmitter = require("events");

const emitter = new EventEmitter();
```

- `emitter` can emit events
- Other parts of your app can listen to them

## Listening to Events (on)

```
emitter.on("greet", () => {
  console.log("Hello there!");
});
```

- `"greet"` is the event name
- Callback runs every time the event is emitted

## Emitting Events (`emit`)

```
emitter.emit("greet");
```

Output

```
Hello there!
```

Event names are just strings — but consistency matters.

## Passing Data with Events

```
emitter.on("order", (item, quantity) => {
  console.log(`Order received: ${quantity} ${item}`);
});

emitter.emit("order", "Pizza", 2);
```

- Arguments passed to `emit()` go directly to listeners
- No return values (fire-and-forget)

## Multiple Listeners for One Event

```
emitter.on("login", user => {
  console.log(`User logged in: ${user}`);
});

emitter.on("login", user => {
  console.log(`Audit log created for ${user}`);
});

emitter.emit("login", "Alice");
```

Output

```
User logged in: Alice
Audit log created for Alice
```

This is decoupling in action.

## One-Time Events (`once`)

```
emitter.once("init", () => {
  console.log("Initialized only once");
});

emitter.emit("init");
emitter.emit("init");
```

Output

```
Initialized only once
```

Use cases

- Startup logic
- One-time cleanup
- Initialization events

## Removing Event Listeners

Remove a specific listener

```
function handler() {
  console.log("This will be removed");
}

emitter.on("test", handler);
emitter.off("test", handler);

emitter.emit("test"); // nothing happens
```

Remove all listeners

```
emitter.removeAllListeners("test");
```

## Error Events (VERY IMPORTANT)

```
emitter.on("error", err => {
  console.error("Error caught:", err.message);
});

emitter.emit("error", new Error("Something broke"));
```

Critical Rule

- If an `"error"` event is emitted without a listener, Node crashes.
- This is why streams and servers always handle `"error"`.

## Extending EventEmitter (Real-World Pattern)

This is how many Node APIs are built.

Custom Class with Events

```
const EventEmitter = require("events");

class OrderSystem extends EventEmitter {
  placeOrder(item) {
    console.log("Order placed");
    this.emit("orderPlaced", item);
  }
}

const order = new OrderSystem();

order.on("orderPlaced", item => {
  console.log(`Preparing ${item}`);
});

order.placeOrder("Burger");
```

Output

```
Order placed
Preparing Burger
```

## Real Example: File Download Simulation

```
const EventEmitter = require("events");

class Downloader extends EventEmitter {
  start() {
    console.log("Download started");
    setTimeout(() => this.emit("progress", 50), 1000);
    setTimeout(() => this.emit("progress", 100), 2000);
    setTimeout(() => this.emit("done"), 2500);
  }
}

const download = new Downloader();

download.on("progress", percent => {
  console.log(`Progress: ${percent}%`);
});

download.on("done", () => {
  console.log("Download complete!");
});

download.start();
```

## Events in Core Node APIs (Hidden in Plain Sight)

You already use EventEmitter without realizing it:

HTTP Server

```
server.on("request", (req, res) => {});
```

Streams

```
stream.on("data", chunk => {});
stream.on("end", () => {});
```

Process

```
process.on("exit", code => {});
process.on("uncaughtException", err => {});
```

All of these extend `EventEmitter`.

## Event Loop & Async Nature

- `emit()` is synchronous
- Listeners run in order of registration
- But events are often triggered by async operations

```
emitter.emit("event"); // listeners run immediately
```

## Common Mistakes

Memory Leaks

- Adding listeners repeatedly without removing them

```
emitter.setMaxListeners(20);
```

Overusing Events

- Events are great for signals, not complex data flows.

## When Should You Use Events?

- Use when:
  - Multiple parts need to react
  - Loose coupling is desired
  - You’re modeling real-world signals
- Avoid when:
  - Simple function calls suffice
  - Data flow becomes hard to trace

## Summary Cheat Sheet

| Feature        | Description       |
| -------------- | ----------------- |
| `EventEmitter` | Base class        |
| `on()`         | Listen repeatedly |
| `once()`       | Listen once       |
| `emit()`       | Trigger event     |
| `off()`        | Remove listener   |
| `"error"`      | Must be handled   |
| Extend class   | Real-world usage  |
