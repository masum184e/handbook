The `fs` module is a core Node.js module (no installation needed) that allows you to:

- Read files
- Write files
- Update file
- Delete files
- Create & remove directories
- Check file stats (size, permissions, timestamps)

You import it like: `import fs from 'fs'`

Node.js provides three styles of file system methods:

1. Synchronous (Blocking)
2. Asynchronous – Callback-based
3. Asynchronous – Promise-based (`fs/promises`) modern & recommended

## Reading Files

### Asynchronous Reading (Callback-based)

```js
const fs = require("fs");

fs.readFile("example.txt", "utf8", (err, data) => {
  if (err) {
    console.error(err);
    return;
  }
  console.log(data);
});
```

- `readFile()` reads the entire file
- `"utf8"` converts the file buffer into readable text
- The callback runs after the file is read
- Non-blocking (other code can run meanwhile)

This returns a Buffer, which is useful for binary files (images, videos).

### Synchronous Reading (Blocking)

```js
const fs = require("fs");

const data = fs.readFileSync("example.txt", "utf8");
console.log(data);
```

- Blocks the event loop until reading finishes
- Easy to write but bad for performance in servers
- Mostly used in scripts or startup code

### Promise-based Reading (Modern Way)

```js
const fs = require("fs/promises");

async function readFile() {
  try {
    const data = await fs.readFile("example.txt", "utf8");
    console.log(data);
  } catch (err) {
    console.error(err);
  }
}

readFile();
```

## Writing Files

### Write (Overwrite) a File

```js
const fs = require("fs/promises");

async function writeFile() {
  await fs.writeFile("output.txt", "Hello Node.js!");
  console.log("File written successfully");
}

writeFile();
```

- Creates the file if it doesn’t exist
- Overwrites existing content by default

### Append to a File

```
const fs = require("fs/promises");

async function appendFile() {
  await fs.appendFile("output.txt", "\nNew line added");
}

appendFile();
```

- Adds content to the end of the file
- Does not erase existing data

## Manipulating Files

### Rename a File

```
const fs = require("fs/promises");

async function renameFile() {
  await fs.rename("output.txt", "renamed.txt");
}

renameFile();
```

### Delete a File

```jsx
const fs = require("fs/promises");

async function deleteFile() {
  await fs.unlink("renamed.txt");
}

deleteFile();
```

## Working with Directories

### Create a Directory

```
const fs = require("fs/promises");

async function createDir() {
  await fs.mkdir("logs");
}

createDir();
```

To create nested directories:

```js
await fs.mkdir("parent/child", { recursive: true });
```

### Read Directory Contents

```
const fs = require("fs/promises");

async function readDir() {
  const files = await fs.readdir(".");
  console.log(files);
}

readDir();
```

- Lists all files and folders in the directory

### Remove a Directory

```
await fs.rmdir("logs");
```

For non-empty folders:

```
await fs.rm("logs", { recursive: true, force: true });
```

## File Information (Stats)

```
const fs = require("fs/promises");

async function fileStats() {
  const stats = await fs.stat("example.txt");

  console.log(stats.size);        // File size in bytes
  console.log(stats.isFile());    // true
  console.log(stats.isDirectory());
}

fileStats();
```

## Streams (For Large Files)
- Read/write files in small chunks
- Use buffers internally
- Process data piece-by-piece
- Use much less memory

Reading large files efficiently:

```js
const fs = require("fs");

const readStream = fs.createReadStream("largeFile.txt", {
  encoding: "utf8",
  highWaterMark: 64 * 1024, // 64 KB chunks
});

readStream.on("data", (chunk) => {
  console.log("Received chunk:\n", chunk);
});

readStream.on("end", () => {
  console.log("Finished reading file.");
});

readStream.on("error", (err) => {
  console.error("Error reading file:", err);
});
```

- `fs.createReadStream()` creates a readable stream.
- `highWaterMark` controls the chunk size (default ~64KB for text).
- The `'data'` event fires each time a chunk is read.
- `'end'` fires when the entire file is read.
- `'error'` handles read errors.

### Writting Streams

```js
const fs = require("fs");

const writeStream = fs.createWriteStream("output.txt", {
  encoding: "utf8",
});

writeStream.write("Hello,\n");
writeStream.write("This is written using streams.\n");
writeStream.end("Done!\n");

writeStream.on("finish", () => {
  console.log("Finished writing file.");
});

writeStream.on("error", (err) => {
  console.error("Error writing file:", err);
});
```

- `'finish'` fires when all data is flushed to disk.

### Copy Large Files

```js
const fs = require("fs");

const source = fs.createReadStream("bigVideo.mp4");
const destination = fs.createWriteStream("copyVideo.mp4");

source.pipe(destination);

destination.on("finish", () => {
  console.log("File copied successfully!");
});

source.on("error", (err) => console.error("Read error:", err));
destination.on("error", (err) => console.error("Write error:", err));
```

- Reads chunks from source
- Automatically writes them to destination
- Handles backpressure automatically
- This avoids loading the entire file into memory.

### Handling backpressure manually

Backpressure happens when the writable stream can’t keep up with the readable stream.

```js
const fs = require("fs");

const readable = fs.createReadStream("largeFile.txt");
const writable = fs.createWriteStream("copy.txt");

readable.on("data", (chunk) => {
  const canContinue = writable.write(chunk);
  if (!canContinue) {
    readable.pause();
  }
});

writable.on("drain", () => {
  readable.resume();
});

readable.on("end", () => {
  writable.end();
});
```

- `writable.write()` returns `false` if its buffer is full.
- When that happens:
  - Pause the readable stream
  - Resume once `'drain'` fires
  - This gives fine-grained control but is usually unnecessary when using `.pipe()`

### Binary Files

Streams work equally well for binary data.

```js
const fs = require("fs");

fs.createReadStream("photo.jpg")
  .pipe(fs.createWriteStream("photo-copy.jpg"))
  .on("finish", () => {
    console.log("Image copied!");
  });
```

No encoding is needed because binary data is handled as Buffers.

### Streams vs `fs.readFile()` / `fs.writeFile()`

| Feature      | Streams               | fs.readFile / fs.writeFile |
| ------------ | --------------------- | -------------------------- |
| Memory usage | Low (chunk-based)     | High (loads full file)     |
| Best for     | Large files           | Small files                |
| Performance  | Better for large I/O  | Simpler but less efficient |
| Use case     | Videos, backups, logs | Config files, JSON         |

### Stream a file to the browser

```js
const http = require("http");
const fs = require("fs");
const path = require("path");

http
  .createServer((req, res) => {
    const filePath = path.join(__dirname, "files", "report.pdf");

    const readStream = fs.createReadStream(filePath);

    res.writeHead(200, {
      "Content-Type": "application/pdf",
    });

    readStream.pipe(res);

    readStream.on("error", (err) => {
      res.writeHead(500);
      res.end("Error reading file.");
    });
  })
  .listen(3000, () => {
    console.log("Server running on http://localhost:3000");
  });
```

**Force download**

```js
res.writeHead(200, {
  "Content-Type": "application/pdf",
  "Content-Disposition": 'attachment; filename="report.pdf"',
});
```

**Using Express helper methods:**

```js
app.get("/download", (req, res) => {
  const filePath = path.join(__dirname, "files", "report.pdf");
  res.download(filePath, "report.pdf");
});
```

- Sets correct headers
- Streams the file
- Handles errors internally

```js
app.get("/view", (req, res) => {
  const filePath = path.join(__dirname, "files", "report.pdf");
  res.sendFile(filePath);
});
```

This streams the file but does not force download.

## When to Use What

| Task          | Recommended Method    |
| ------------- | --------------------- |
| Server apps   | Async / Promise-based |
| Large files   | Streams               |
| Small scripts | Sync                  |
| Modern code   | `fs/promises`         |

## Common Errors

| Error Code | Meaning             |
| ---------- | ------------------- |
| `ENOENT`   | File not found      |
| `EACCES`   | Permission denied   |
| `EISDIR`   | Path is a directory |

Always handle errors in callbacks or `try...catch` for sync code.
