Node.js uses a single-threaded, non-blocking, asynchronous architecture built on top of libuv.
The Event Loop is the mechanism that:

- Receives tasks (callbacks, promises, I/O)
- Queues them
- Executes them in specific phases

This allows Node.js to handle thousands of concurrent connections efficiently without spawning new threads for each request.

## Event Loop Phases (In Order)

1. Timers – Executes callbacks from `setTimeout()` and `setInterval()`
2. I/O callbacks – Executes I/O-related callbacks
3. Idle, prepare – Internal use
4. Poll – Retrieves new I/O events, executes I/O callbacks
5. Check – Executes `setImmediate()` callbacks
6. Close callbacks – Cleanup callbacks (e.g., `socket.on('close')`)

Additionally:

- Microtasks queue runs after every phase:
  - `process.nextTick()`
  - Promise callbacks (`.then()` / `await`)

## Why Event Loop Understanding Is Critical for Performance

Poor usage can cause:

- Event loop blocking
- High latency
- Low throughput
- Unresponsive servers

Proper usage ensures:

- Fast I/O
- High concurrency
- Smooth handling of large workloads

## Key Performance Principles

### Never Block the Event Loop

Bad:

```js
while (true) {}
```

Bad:

```js
for (let i = 0; i < 1e9; i++) {}
```

Good:

- Break work into chunks
- Use async I/O
- Offload heavy tasks

### Use Asynchronous APIs

Bad:

```js
const data = fs.readFileSync("file.txt");
```

Good:

```js
fs.readFile("file.txt", (err, data) => {
  console.log(data.toString());
});
```

Or modern:

```js
const data = await fs.promises.readFile("file.txt");
```

### Understand Microtasks vs Macrotasks

```js
console.log("Start");

setTimeout(() => console.log("Timeout"), 0);
setImmediate(() => console.log("Immediate"));

Promise.resolve().then(() => console.log("Promise"));
process.nextTick(() => console.log("NextTick"));

console.log("End");
```

Output order:

```
Start
End
NextTick
Promise
Timeout
Immediate
```

Why?

- `process.nextTick()` runs before promises.
- Promises run before timers.
- Timers usually run before setImmediate().

Misusing `process.nextTick()` can starve the event loop.

### Warning: `process.nextTick()` Can Break Performance

Bad:

```js
function recurse() {
  process.nextTick(recurse);
}
recurse();
```

This causes event loop starvation — no I/O or timers can run.

## Example: Blocking vs Non-Blocking Server

Blocking Version (Bad Performance)

```js
const http = require("http");

http
  .createServer((req, res) => {
    // Simulate heavy computation
    let sum = 0;
    for (let i = 0; i < 1e9; i++) sum += i;

    res.end("Done\n");
  })
  .listen(3000);
```

One request blocks all others.

Non-Blocking Version (Better Performance)

```js
const http = require("http");

function heavyTaskAsync(callback) {
  let sum = 0;
  let i = 0;

  function chunk() {
    const start = Date.now();
    while (i < 1e9 && Date.now() - start < 10) {
      sum += i++;
    }

    if (i < 1e9) {
      setImmediate(chunk); // Yield to event loop
    } else {
      callback(sum);
    }
  }

  chunk();
}

http
  .createServer((req, res) => {
    heavyTaskAsync((result) => {
      res.end("Done\n");
    });
  })
  .listen(3000);
```

✔️ Work is broken into chunks, allowing I/O to continue.

## Example: Using `setImmediate()` vs `setTimeout()`

```js
setTimeout(() => console.log("timeout"), 0);
setImmediate(() => console.log("immediate"));
```

Inside an I/O callback, `setImmediate()` runs before `setTimeout(0)`, making it better for deferring execution after I/O:

```js
fs.readFile("file.txt", () => {
  setImmediate(() => console.log("Immediate after I/O"));
  setTimeout(() => console.log("Timeout after I/O"), 0);
});
```

Output:

```
Immediate after I/O
Timeout after I/O
```

## Example: Preventing Event Loop Blocking with Worker Threads

For heavy CPU work:

```
const { Worker } = require('worker_threads');

function runHeavyTask() {
  return new Promise((resolve, reject) => {
    const worker = new Worker('./worker.js');
    worker.on('message', resolve);
    worker.on('error', reject);
  });
}
```

This offloads CPU work, keeping the event loop responsive.

## Measuring Event Loop Lag

```js
setInterval(() => {
  const start = Date.now();
  setImmediate(() => {
    const lag = Date.now() - start;
    console.log(`Event loop lag: ${lag}ms`);
  });
}, 1000);
```

High lag indicates blocking code.

## Best Practices Summary

| Practice                     | Why It Helps               |
| ---------------------------- | -------------------------- |
| Avoid sync APIs              | Prevents blocking          |
| Chunk heavy work             | Keeps loop responsive      |
| Use promises/async           | Improves I/O throughput    |
| Avoid excessive `nextTick()` | Prevents starvation        |
| Use workers for CPU tasks    | Maintains responsiveness   |
| Monitor event loop lag       | Detects performance issues |
