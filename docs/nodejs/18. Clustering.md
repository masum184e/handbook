Node.js runs on a single-threaded event loop, meaning:

- One Node.js process can only use one CPU core.
- On a machine with 4, 8, or more cores, the rest stay unused by a single Node app.

Clustering allows you to:

- Run multiple Node.js processes (workers).
- Each worker uses a separate CPU core.
- All workers share the same server port.
- This greatly improves throughput, resilience, and scalability.

## How Clustering Works

Node.js provides a built-in `cluster` module:

- Master process:
  - Manages workers.
  - Distributes incoming connections.
- Worker processes:
  - Each runs its own event loop.
  - Handles incoming requests independently.

The OS load-balances requests across workers.

## When to Use Clustering

Use clustering when:

- You have a CPU-bound or high-traffic Node.js server.
- You are deploying on a multi-core machine.
- You want better fault tolerance (workers can restart if they crash).

## HTTP Server Using Cluster

```js
const cluster = require("cluster");
const http = require("http");
const os = require("os");

const numCPUs = os.cpus().length;

if (cluster.isMaster) {
  console.log(`Master process ${process.pid} is running`);

  // Fork workers (one per CPU core)
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  // Restart worker if it dies
  cluster.on("exit", (worker, code, signal) => {
    console.log(`Worker ${worker.process.pid} died. Restarting...`);
    cluster.fork();
  });
} else {
  // Workers share the TCP connection
  http
    .createServer((req, res) => {
      res.writeHead(200);
      res.end(`Handled by worker ${process.pid}\n`);
    })
    .listen(3000);

  console.log(`Worker ${process.pid} started`);
}
```

- Detect master vs worker: `if (cluster.isMaster) {`
  - Runs only once.
  - Responsible for creating workers.
- Fork workers

  ```js
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  ```

  - Creates one worker process per CPU core.
  - Each worker runs the same script.

- Auto-restart crashed workers

  ```js
  cluster.on("exit", (worker) => {
    cluster.fork();
  });
  ```

  - Improves reliability.
  - Keeps the cluster at full capacity.

- Worker creates the server

  ```js
  http.createServer(...).listen(3000);
  ```

  - All workers listen on the same port.
  - The master handles connection distribution automatically.

## Performance Benefits

| Without Cluster         | With Cluster           |
| ----------------------- | ---------------------- |
| 1 CPU core used         | All CPU cores used     |
| Lower throughput        | Higher throughput      |
| Single point of failure | Fault-tolerant workers |

## Example with CPU-Intensive Task

Suppose your server performs heavy computation:

```js
function heavyTask() {
  let sum = 0;
  for (let i = 0; i < 1e9; i++) {
    sum += i;
  }
  return sum;
}
```

Without clustering:

- One request blocks the event loop.

With clustering:

- Requests are distributed across multiple workers.
- Other workers remain responsive.
