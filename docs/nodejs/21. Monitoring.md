## CPU Profiling

- Using Node.js built-in profiler: `node --prof app.js`
  - This generates a log file (e.g., isolate-0xnnnn-v8.log).
- Process it: `node --prof-process isolate-0xnnnn-v8.log > processed.txt`
  This shows:
  - Which functions consume the most CPU
  - Where time is being spent

Useful for finding CPU-heavy functions.

## Memory Profiling

- Using Heap Snapshots
  Start Node.js with: `node --inspect app.js`
  Open Chrome DevTools → Memory → Take Heap Snapshot.

You can:

- Compare snapshots
- Find memory leaks
- Detect detached objects

Programmatic Heap Snapshot

```js
const v8 = require("v8");
const fs = require("fs");

const snapshot = v8.getHeapSnapshot();
const file = fs.createWriteStream("heap.heapsnapshot");
snapshot.pipe(file);
```

## Event Loop Profiling

Measure Event Loop Lag

```js
setInterval(() => {
  const start = Date.now();
  setImmediate(() => {
    const lag = Date.now() - start;
    console.log(`Event loop lag: ${lag}ms`);
  });
}, 1000);
```

High lag indicates blocking code.

## Async Stack Traces & Tracing

Enable async stack traces:

```js
node --async-stack-traces app.js
```

Use `async_hooks` for tracing async behavior:

```
const async_hooks = require('async_hooks');
const fs = require('fs');

const hook = async_hooks.createHook({
  init(asyncId, type, triggerAsyncId) {
    fs.writeSync(1, `Init: ${type} (${asyncId})\n`);
  }
});

hook.enable();
```

## Monitoring in Production

Key Metrics to Monitor

| Metric           | Why It Matters          |
| ---------------- | ----------------------- |
| CPU usage        | Detects heavy workloads |
| Memory usage     | Detects leaks           |
| Event loop lag   | Detects blocking        |
| Request latency  | Detects slow endpoints  |
| Error rates      | Detects failures        |
| Throughput (RPS) | Measures load handling  |
| DB query time    | Finds bottlenecks       |

Basic Runtime Metrics

```js
setInterval(() => {
  const memory = process.memoryUsage();
  const cpu = process.cpuUsage();

  console.log({
    rss: memory.rss,
    heapUsed: memory.heapUsed,
    cpuUser: cpu.user,
    cpuSystem: cpu.system,
  });
}, 5000);
```

Monitoring Express App with Metrics Endpoint

```js
const express = require("express");
const app = express();

app.get("/metrics", (req, res) => {
  const memory = process.memoryUsage();
  const cpu = process.cpuUsage();

  res.json({
    uptime: process.uptime(),
    memory,
    cpu,
    eventLoopLag: process.hrtime.bigint().toString(),
  });
});

app.listen(3000);
```

## APM Tools

| Tool        | Features                      |
| ----------- | ----------------------------- |
| New Relic   | Full tracing, metrics, errors |
| Datadog     | Metrics, logs, tracing        |
| Elastic APM | Distributed tracing           |
| AppDynamics | Performance monitoring        |

Monitor with `pm2`: `pm2 monit`

**Measuring Request Duration Middleware**

```js
app.use((req, res, next) => {
  const start = process.hrtime.bigint();

  res.on("finish", () => {
    const duration = Number(process.hrtime.bigint() - start) / 1e6;
    console.log(`${req.method} ${req.url} - ${duration.toFixed(2)}ms`);
  });

  next();
});
```

**Detecting Memory Leaks**

```js
setInterval(() => {
  console.log(process.memoryUsage().heapUsed);
}, 10000);
```

If memory grows continuously and never drops → possible memory leak.
