## Streams

A stream is an object that lets you read or write data piece by piece, instead of loading everything into memory at once.

Think of it like drinking water through a straw instead of pouring the whole bottle into your mouth at once.

Why streams matter:

- Handle large files
- Work with real-time data
- Improve performance
- Reduce memory usage

## Buffers

A Buffer is a chunk of raw binary data stored in memory.

Streams often use Buffers internally to move data around.

Example:

```js
const buf = Buffer.from("Hello");
console.log(buf); // <Buffer 48 65 6c 6c 6f>
console.log(buf.toString()); // Hello
```

## Types of Streams

There are 4 main types:

| Stream Type | Can Read? | Can Write?           | Example                  |
| ----------- | --------- | -------------------- | ------------------------ |
| Readable    | ✅ Yes    | ❌ No                | `fs.createReadStream()`  |
| Writable    | ❌ No     | ✅ Yes               | `fs.createWriteStream()` |
| Duplex      | ✅ Yes    | ✅ Yes               | TCP socket               |
| Transform   | ✅ Yes    | ✅ Yes + modify data | Compression, encryption  |

## Readable Streams

Used to read data chunk by chunk.

### Reading a file

```js
const fs = require("fs");

const readStream = fs.createReadStream("example.txt", {
  encoding: "utf8",
  highWaterMark: 16, // bytes per chunk
});

readStream.on("data", (chunk) => {
  console.log("Received chunk:", chunk);
});

readStream.on("end", () => {
  console.log("Finished reading file.");
});
```

- `createReadStream()` creates a readable stream.
- `highWaterMark` controls chunk size.
- `"data"` event fires for each chunk.
- `"end"` fires when file is done.

### Writable Streams

Used to write data chunk by chunk.

```js
const fs = require("fs");

const writeStream = fs.createWriteStream("output.txt");

writeStream.write("Hello ");
writeStream.write("World!");
writeStream.end();

writeStream.on("finish", () => {
  console.log("Finished writing file.");
});
```

- `write()` sends chunks to the destination.
- `end()` closes the stream.
- `"finish"` fires when all data is written.


### Piping: Connecting Streams

You can directly connect streams using `.pipe()`.
```js
const fs = require("fs");

const readStream = fs.createReadStream("input.txt");
const writeStream = fs.createWriteStream("copy.txt");

readStream.pipe(writeStream);
```
- Data flows automatically from read stream → write stream.
- No manual chunk handling needed.
- This is memory efficient.
## Duplex Streams

A duplex stream can both read and write independently.

Example: TCP socket (client-server communication).

```js
// SImple duplex stream
const net = require("net");

const server = net.createServer((socket) => {
  socket.write("Hello client!");

  socket.on("data", (data) => {
    console.log("Client says:", data.toString());
  });
});

server.listen(3000);
```
- The socket can send and receive data.
- Reading and writing are independent.

## Transform Streams

A transform stream is a special duplex stream that modifies the data passing through it.

Example: Convert text to uppercase
```js
const { Transform } = require("stream");

const upperCaseTransform = new Transform({
  transform(chunk, encoding, callback) {
    const upper = chunk.toString().toUpperCase();
    callback(null, upper);
  }
});

// Usage:
process.stdin.pipe(upperCaseTransform).pipe(process.stdout);
```
- `transform()` receives each chunk.
- You modify it and pass it onward.
- Here, user input is transformed to uppercase.

## File Compression
```js
const fs = require("fs");
const zlib = require("zlib");

const readStream = fs.createReadStream("bigfile.txt");
const gzip = zlib.createGzip();
const writeStream = fs.createWriteStream("bigfile.txt.gz");

readStream.pipe(gzip).pipe(writeStream);
```
- Reads file → compresses → writes compressed file.
- No full file loaded into memory.

## How Streams Use Buffers

Internally:

- Streams move data in buffers (default ~64KB).
- Each `chunk` you receive is usually a `Buffer`.

```
readStream.on("data", (chunk) => {
  console.log(Buffer.isBuffer(chunk)); // true
});
```