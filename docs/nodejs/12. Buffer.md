A Buffer is a fixed-size chunk of memory that stores raw binary data.

JavaScript normally works with strings and objects, but many real-world tasks (files, images, network packets) require handling raw bytes — that’s where Buffers come in.

Think of a Buffer as:

> An array of bytes (numbers from 0–255).

**Why Buffers Are Important**

Buffers are used when:

- Reading/writing files
- Handling streams
- Working with TCP/UDP sockets
- Encoding/decoding binary formats (images, audio, video, protocols)

Without Buffers, Node.js couldn’t efficiently handle binary data.

## Creating Buffers

From a string

```js
const buf = Buffer.from("Hello", "utf8");
console.log(buf); // <Buffer 48 65 6c 6c 6f>
console.log(buf.toString()); // Hello
```

- `"Hello"` becomes bytes in UTF-8 encoding.
- Each hex value represents a character.

From an array of bytes

```js
const buf = Buffer.from([72, 101, 108, 108, 111]);
console.log(buf.toString()); // Hello
```

Allocating memory (fixed size)

```js
const buf = Buffer.alloc(10);
console.log(buf); // <Buffer 00 00 00 00 00 00 00 00 00 00>
```

Never use `Buffer.allocUnsafe()` unless you know what you’re doing — it may expose old memory.

## Reading and Writing Values in Buffers

Buffers allow you to read/write integers and floats at specific positions.

Writing value

```js
const buf = Buffer.alloc(4);
buf.writeUInt8(255, 0); // write 1 byte at index 0
buf.writeUInt16BE(500, 1); // write 2 bytes starting at index 1
console.log(buf); // <Buffer ff 01 f4 00>
```

- `writeUInt8`: writes 1 byte.
- `writeUInt16BE`: writes 2 bytes in Big Endian format.

Reading values

```js
console.log(buf.readUInt8(0)); // 255
console.log(buf.readUInt16BE(1)); // 500
```

## Encoding and Decoding Data

Buffers support encodings like: `utf8`, `ascii`, `hex`, `base64`

```js
const buf = Buffer.from("Node.js");

console.log(buf.toString("hex")); // 4e6f64652e6a73
console.log(buf.toString("base64")); // Tm9kZS5qcw==
```

## Writing Buffers to Streams

```js
const fs = require("fs");

const writeStream = fs.createWriteStream("output.bin");

const buf1 = Buffer.from("Hello ");
const buf2 = Buffer.from("World!");

writeStream.write(buf1);
writeStream.write(buf2);
writeStream.end();
```

- Buffers are written directly.
- Data remains binary-safe.

**Concatenating Buffers**

```js
const buf1 = Buffer.from("Hello ");
const buf2 = Buffer.from("World!");

const combined = Buffer.concat([buf1, buf2]);
console.log(combined.toString()); // Hello World!
```

**Slicing Buffers (No Copy!)**

```js
const buf = Buffer.from("Hello World");
const slice = buf.slice(0, 5);

console.log(slice.toString()); // Hello

slice[0] = 74; // Change 'H' to 'J'
console.log(buf.toString()); // Jello World
```

- `slice()` creates a view, not a copy.
- Modifying the slice affects the original buffer.

## Buffers vs Strings

| Feature           | Buffer | String    |
| ----------------- | ------ | --------- |
| Stores binary     | Yes    | No        |
| Fixed size        | Yes    | No        |
| Encoding required | No     | Yes       |
| Used in streams   | Yes    | Sometimes |
