"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[96104],{28453(e,n,r){r.d(n,{R:()=>t,x:()=>c});var s=r(96540);const l={},i=s.createContext(l);function t(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:t(e.components),s.createElement(i.Provider,{value:n},e.children)}},72673(e,n,r){r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>o,frontMatter:()=>t,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"rust/8_1. References","title":"8_1. References","description":"A reference lets you access a value without owning it.","source":"@site/docs/rust/8_1. References.md","sourceDirName":"rust","slug":"/rust/8_1. References","permalink":"/handbook/docs/rust/8_1. References","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"rustApiSidebar","previous":{"title":"5_1. Functions","permalink":"/handbook/docs/rust/5_1. Functions"},"next":{"title":"async_await","permalink":"/handbook/docs/rust/Asynchronous/async_await"}}');var l=r(74848),i=r(28453);const t={},c=void 0,d={},a=[{value:"Why References Exist",id:"why-references-exist",level:2},{value:"References and Ownership",id:"references-and-ownership",level:2},{value:"Ownership Rule",id:"ownership-rule",level:3},{value:"Immutable References (&amp;T)",id:"immutable-references-t",level:2},{value:"Mutable References (<code>&amp;mut T</code>)",id:"mutable-references-mut-t",level:2},{value:"Immutable vs Mutable Rule (Critical)",id:"immutable-vs-mutable-rule-critical",level:2},{value:"Reference Scope (Non-Lexical Lifetimes)",id:"reference-scope-non-lexical-lifetimes",level:2},{value:"References in Function Parameters",id:"references-in-function-parameters",level:2},{value:"Immutable reference",id:"immutable-reference",level:3},{value:"References vs Copy",id:"references-vs-copy",level:2},{value:"Dangling References (Prevented)",id:"dangling-references-prevented",level:2},{value:"References and the Heap",id:"references-and-the-heap",level:2},{value:"References and Structs",id:"references-and-structs",level:2},{value:"Struct Holding References",id:"struct-holding-references",level:3},{value:"References and Pattern Matching",id:"references-and-pattern-matching",level:2},{value:"Moving (bad)",id:"moving-bad",level:3},{value:"Borrowing (good)",id:"borrowing-good",level:3},{value:"Slices Are References",id:"slices-are-references",level:2},{value:"References vs Raw Pointers",id:"references-vs-raw-pointers",level:2},{value:"Mental Model That Works",id:"mental-model-that-works",level:2}];function h(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.p,{children:"A reference lets you access a value without owning it."}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Written as ",(0,l.jsx)(n.code,{children:"&T"})," or ",(0,l.jsx)(n.code,{children:"&mut T"})]}),"\n",(0,l.jsx)(n.li,{children:"Does not take ownership"}),"\n",(0,l.jsx)(n.li,{children:"Does not free memory"}),"\n",(0,l.jsx)(n.li,{children:"Must always be valid"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"References are Rust\u2019s safe alternative to raw pointers."}),"\n",(0,l.jsx)(n.h2,{id:"why-references-exist",children:"Why References Exist"}),"\n",(0,l.jsx)(n.p,{children:"Without references:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'fn print(s: String) {\r\n    println!("{}", s);\r\n}\r\n\r\nlet s = String::from("hello");\r\nprint(s);\r\n// s is now gone\n'})}),"\n",(0,l.jsx)(n.p,{children:"That\u2019s annoying and inefficient."}),"\n",(0,l.jsx)(n.p,{children:"With references:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'fn print(s: &String) {\r\n    println!("{}", s);\r\n}\r\n\r\nlet s = String::from("hello");\r\nprint(&s);\r\n// s still exists\n'})}),"\n",(0,l.jsx)(n.p,{children:"References enable safe sharing."}),"\n",(0,l.jsx)(n.h2,{id:"references-and-ownership",children:"References and Ownership"}),"\n",(0,l.jsx)(n.h3,{id:"ownership-rule",children:"Ownership Rule"}),"\n",(0,l.jsx)(n.p,{children:"References never own data."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'let s = String::from("hello");\r\nlet r = &s;\n'})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"s"})," owns the heap allocation"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"r"})," just points to it"]}),"\n",(0,l.jsxs)(n.li,{children:["When ",(0,l.jsx)(n.code,{children:"s"})," is dropped, ",(0,l.jsx)(n.code,{children:"r"})," becomes invalid (and Rust prevents this)"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"immutable-references-t",children:"Immutable References (&T)"}),"\n",(0,l.jsx)(n.p,{children:"What they allow"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Read access"}),"\n",(0,l.jsx)(n.li,{children:"Multiple references at the same time"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'let s = String::from("hello");\r\n\r\nlet r1 = &s;\r\nlet r2 = &s;\r\n\r\nprintln!("{} {}", r1, r2);\n'})}),"\n",(0,l.jsx)(n.p,{children:"Why this is safe"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["No one can modify ",(0,l.jsx)(n.code,{children:"s"})]}),"\n",(0,l.jsx)(n.li,{children:"No data races"}),"\n",(0,l.jsx)(n.li,{children:"No invalid memory access"}),"\n"]}),"\n",(0,l.jsxs)(n.h2,{id:"mutable-references-mut-t",children:["Mutable References (",(0,l.jsx)(n.code,{children:"&mut T"}),")"]}),"\n",(0,l.jsx)(n.p,{children:"What they allow"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Read + write access"}),"\n",(0,l.jsx)(n.li,{children:"Exactly one mutable reference at a time"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'let mut s = String::from("hello");\r\n\r\nlet r = &mut s;\r\nr.push_str(" world");\r\n\r\nprintln!("{}", r);\n'})}),"\n",(0,l.jsx)(n.p,{children:"Why this is restricted"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Two writers = race conditions"}),"\n",(0,l.jsx)(n.li,{children:"Writer + reader = inconsistent reads"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Rust blocks this at compile time."}),"\n",(0,l.jsx)(n.h2,{id:"immutable-vs-mutable-rule-critical",children:"Immutable vs Mutable Rule (Critical)"}),"\n",(0,l.jsx)(n.p,{children:"At any moment, either:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Many immutable references"}),"\n",(0,l.jsx)(n.li,{children:"One mutable reference"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Both at the same time"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"let r1 = &s;\r\nlet r2 = &mut s; // \u274c compile error\n"})}),"\n",(0,l.jsx)(n.p,{children:"This rule is the foundation of Rust\u2019s thread safety."}),"\n",(0,l.jsx)(n.h2,{id:"reference-scope-non-lexical-lifetimes",children:"Reference Scope (Non-Lexical Lifetimes)"}),"\n",(0,l.jsx)(n.p,{children:"Rust tracks actual usage, not just braces."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'let mut s = String::from("hello");\r\n\r\nlet r1 = &s;\r\nprintln!("{}", r1); // last use\r\n\r\nlet r2 = &mut s; // \u2705 allowed\r\nr2.push_str("!");\n'})}),"\n",(0,l.jsxs)(n.p,{children:["Even though ",(0,l.jsx)(n.code,{children:"r1"})," is still in scope textually, Rust knows it\u2019s no longer used."]}),"\n",(0,l.jsx)(n.h2,{id:"references-in-function-parameters",children:"References in Function Parameters"}),"\n",(0,l.jsx)(n.h3,{id:"immutable-reference",children:"Immutable reference"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"fn length(s: &String) -> usize {\r\n    s.len()\r\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"Mutable reference"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"fn append(s: &mut String) {\r\n    s.push('!');\r\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"Usage"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'let mut s = String::from("hello");\r\n\r\nlet len = length(&s);\r\nappend(&mut s);\r\n\r\nprintln!("{} ({})", s, len);\n'})}),"\n",(0,l.jsx)(n.h2,{id:"references-vs-copy",children:"References vs Copy"}),"\n",(0,l.jsx)(n.p,{children:"References themselves are Copy:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'let s = String::from("hello");\r\n\r\nlet r1 = &s;\r\nlet r2 = r1; // copy of reference\n'})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Both point to the same data"}),"\n",(0,l.jsx)(n.li,{children:"Borrowing rules still apply"}),"\n",(0,l.jsx)(n.li,{children:"Ownership does not change"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"dangling-references-prevented",children:"Dangling References (Prevented)"}),"\n",(0,l.jsx)(n.p,{children:"Rust forbids references that outlive data."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'let r: &String;\r\n\r\n{\r\n    let s = String::from("hello");\r\n    r = &s; // \u274c error\r\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"Why?"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"s"})," is dropped"]}),"\n",(0,l.jsx)(n.li,{children:"Heap memory freed"}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"r"})," would dangle"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Rust stops this at compile time."}),"\n",(0,l.jsx)(n.h2,{id:"references-and-the-heap",children:"References and the Heap"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'let s = String::from("hello");\r\nlet r = &s;\n'})}),"\n",(0,l.jsx)(n.p,{children:"Memory layout:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:'Stack:\r\nr \u2500\u2500\u2192 s \u2500\u2500\u2192 Heap("hello")\n'})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Reference points to stack value"}),"\n",(0,l.jsx)(n.li,{children:"Stack value points to heap"}),"\n",(0,l.jsx)(n.li,{children:"Lifetimes guarantee everything stays valid"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"references-and-structs",children:"References and Structs"}),"\n",(0,l.jsx)(n.h3,{id:"struct-holding-references",children:"Struct Holding References"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"struct Excerpt<'a> {\r\n    text: &'a str,\r\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"Excerpt"})," cannot outlive the data it references"]}),"\n",(0,l.jsx)(n.p,{children:"Usage:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'let s = String::from("hello world");\r\nlet e = Excerpt { text: &s[0..5] };\r\n\r\nprintln!("{}", e.text);\n'})}),"\n",(0,l.jsx)(n.h2,{id:"references-and-pattern-matching",children:"References and Pattern Matching"}),"\n",(0,l.jsx)(n.h3,{id:"moving-bad",children:"Moving (bad)"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'let opt = Some(String::from("hello"));\r\n\r\nmatch opt {\r\n    Some(s) => println!("{}", s), // move\r\n    None => {}\r\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"borrowing-good",children:"Borrowing (good)"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'match &opt {\r\n    Some(s) => println!("{}", s),\r\n    None => {}\r\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"slices-are-references",children:"Slices Are References"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'let s = String::from("hello world");\r\nlet slice = &s[0..5];\n'})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"&str"})," is a reference"]}),"\n",(0,l.jsx)(n.li,{children:"No allocation"}),"\n",(0,l.jsx)(n.li,{children:"No ownership transfer"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Same for arrays:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"let arr = [1, 2, 3];\r\nlet slice = &arr[..];\n"})}),"\n",(0,l.jsx)(n.h2,{id:"references-vs-raw-pointers",children:"References vs Raw Pointers"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Feature"}),(0,l.jsx)(n.th,{children:"Reference"}),(0,l.jsx)(n.th,{children:"Raw Pointer"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Always valid"}),(0,l.jsx)(n.td,{children:"\u2705"}),(0,l.jsx)(n.td,{children:"\u274c"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Null allowed"}),(0,l.jsx)(n.td,{children:"\u274c"}),(0,l.jsx)(n.td,{children:"\u2705"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Borrow checked"}),(0,l.jsx)(n.td,{children:"\u2705"}),(0,l.jsx)(n.td,{children:"\u274c"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Safe by default"}),(0,l.jsx)(n.td,{children:"\u2705"}),(0,l.jsx)(n.td,{children:"\u274c"})]})]})]}),"\n",(0,l.jsxs)(n.p,{children:["Raw pointers exist (",(0,l.jsx)(n.code,{children:"*const T"}),", ",(0,l.jsx)(n.code,{children:"*mut T"}),") but require unsafe."]}),"\n",(0,l.jsx)(n.h2,{id:"mental-model-that-works",children:"Mental Model That Works"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Ownership \u2192 who frees memory"}),"\n",(0,l.jsx)(n.li,{children:"References \u2192 who can access memory"}),"\n",(0,l.jsx)(n.li,{children:"Borrow checker \u2192 traffic cop"}),"\n",(0,l.jsx)(n.li,{children:"Lifetimes \u2192 how long access lasts"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"If the compiler allows it, the reference is guaranteed safe."})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(h,{...e})}):h(e)}}}]);