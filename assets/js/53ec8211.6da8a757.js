"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[8515],{28453(e,n,i){i.d(n,{R:()=>o,x:()=>l});var t=i(96540);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}},56112(e,n,i){i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"dsa/Concepts/Linked List","title":"Linked List","description":"\x3c!--","source":"@site/docs/dsa/1. Concepts/10. Linked List.md","sourceDirName":"dsa/1. Concepts","slug":"/dsa/Concepts/Linked List","permalink":"/handbook/docs/dsa/Concepts/Linked List","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"title":"Linked List","sidebar_position":10},"sidebar":"dsaSidebar","previous":{"title":"Searching","permalink":"/handbook/docs/dsa/Concepts/Searching"},"next":{"title":"Greedy","permalink":"/handbook/docs/dsa/Concepts/Greedy"}}');var s=i(74848),r=i(28453);const o={title:"Linked List",sidebar_position:10},l=void 0,d={},c=[{value:"Why Use Linked List Instead of Array?",id:"why-use-linked-list-instead-of-array",level:2},{value:"Types of Linked Lists",id:"types-of-linked-lists",level:2},{value:"Structure of a Node",id:"structure-of-a-node",level:2},{value:"C Programming",id:"c-programming",level:3},{value:"C++ Programming",id:"c-programming-1",level:3},{value:"Floyd&#39;s Cycle Finding Algorithm",id:"floyds-cycle-finding-algorithm",level:2},{value:"How It Works",id:"how-it-works",level:3},{value:"Loop",id:"loop",level:3},{value:"Start Point",id:"start-point",level:3}];function a(e){const n={blockquote:"blockquote",br:"br",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"A linked list is a linear data structure where elements (called nodes) are connected using pointers (or references).\r\nUnlike arrays, linked lists don\u2019t store elements in contiguous memory. Instead, each node contains:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Data \u2192 The actual value."}),"\n",(0,s.jsx)(n.li,{children:"Pointer (next) \u2192 A reference to the next node in the sequence."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Think of it like a chain of boxes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Each box has data + an arrow pointing to the next box."}),"\n",(0,s.jsx)(n.li,{children:"The last box points to NULL, meaning end of the list."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"why-use-linked-list-instead-of-array",children:"Why Use Linked List Instead of Array?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Dynamic size \u2192 No need to declare fixed size like arrays."}),"\n",(0,s.jsx)(n.li,{children:"Efficient insertion/deletion \u2192 Adding/removing elements doesn\u2019t require shifting."}),"\n",(0,s.jsx)(n.li,{children:"Memory utilization \u2192 Uses memory as needed (non-contiguous)."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"But:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Slower access \u2192 Unlike arrays, you can\u2019t access by index directly. You must traverse from the head."}),"\n",(0,s.jsx)(n.li,{children:"Extra memory \u2192 Each node needs extra space for a pointer."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"types-of-linked-lists",children:"Types of Linked Lists"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Singly Linked List \u2192 Each node points to the next node. (One direction only)"}),"\n",(0,s.jsxs)(n.li,{children:["Doubly Linked List \u2192 Each node has two pointers: ",(0,s.jsx)(n.code,{children:"next"})," (to next node) and ",(0,s.jsx)(n.code,{children:"prev"})," (to previous node). (Two directions)"]}),"\n",(0,s.jsx)(n.li,{children:"Circular Linked List \u2192 Last node points back to the head, forming a loop."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"structure-of-a-node",children:"Structure of a Node"}),"\n",(0,s.jsx)(n.h3,{id:"c-programming",children:"C Programming"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"struct Node {\r\n    int data;          // Value\r\n    struct Node* next; // Pointer to next node\r\n};\r\n\r\nstruct Node* createNode(int data) {\r\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\r\n    newNode->data = data;\r\n    newNode->next = NULL;\r\n    return newNode;\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"c-programming-1",children:"C++ Programming"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class Node {\r\npublic:\r\n    int data;\r\n    Node* next;\r\n\r\n    Node(int value) {\r\n        data = value;\r\n        next = nullptr;\r\n    }\r\n};\r\n\r\nclass LinkedList {\r\nprivate:\r\n    Node* head;\r\n\r\npublic:\r\n    LinkedList() {\r\n        head = nullptr;\r\n    }\r\n\r\n    // Insert at end\r\n    void insertEnd(int value) {}\r\n}\r\n\r\nint main() {\r\n    LinkedList ll;\r\n\r\n    ll.insertEnd(10);\r\n    ll.insertEnd(20);\r\n    ll.insertEnd(30);\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"floyds-cycle-finding-algorithm",children:"Floyd's Cycle Finding Algorithm"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"It also called tortoise algorithm"}),"\n",(0,s.jsx)(n.li,{children:"Use two pointer to move through the sequence at different speed"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["slow pointer => move one step ahead ",(0,s.jsx)(n.br,{}),"\n","fast pointer => move two step ahead"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,s.jsx)(n.p,{children:"When slow pointer enter the loop, fast pointer must be inside loop"}),"\n",(0,s.jsx)(n.p,{children:"If we consider distance between slow and fast pointer. At begining, it will be 0, then 1, then 2 and eventually it well become n but the distance between fast and slow(reverse) gradually reduce and eventually they see each other and loop detected."}),"\n",(0,s.jsx)(n.h3,{id:"loop",children:"Loop"}),"\n",(0,s.jsxs)(n.p,{children:["A loop means the ",(0,s.jsx)(n.strong,{children:"last node"})," of the linked list connected back to a node in the same linke list."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"       Loop                     Not Loop\r\n------------------------------------------------\r\n1 \u2192 2 \u2192 3 \u2192 4 \u2192 5      1 \u2192 2 \u2192 3 \u2192 4 \u2192 5 \u2192 6 \u2192 7\r\n          \u2191     \u2502                \u2191     \u2502\r\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2518                \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(n.h3,{id:"start-point",children:"Start Point"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Distance covered by slow pointer: ",(0,s.jsx)(n.code,{children:"m + n*x + k"})]}),"\n",(0,s.jsxs)(n.li,{children:["Distance covered by fast pointer: ",(0,s.jsx)(n.code,{children:"m + n*y + k"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"m"}),": straight distance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"n"}),": length of the loop"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"x"}),", ",(0,s.jsx)(n.code,{children:"y"}),": number of time loop iterate"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"k"}),": distance between start point and collision point"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Distance Calcualtion"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fast        = 2 * slow\r\nm + n*y + k = 2 * (m + n*x + k)\r\n         ny = m + k + 2nx\r\n     ny-2nx = m + k\r\n    n(y-2x) = m + k\r\nn(y-2x) - k = m\r\n     ni - k = m\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"y-2x"})," times of extra iteration is used to detect the collison"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"m"})," is the distance of ",(0,s.jsx)(n.strong,{children:"head to start"})," which is ",(0,s.jsx)(n.code,{children:"ni-k"})," or ",(0,s.jsx)(n.code,{children:"ni+k"}),"(reverse)."]}),"\n",(0,s.jsxs)(n.li,{children:["So, to get start point, iterate the distance between head to start(",(0,s.jsx)(n.code,{children:"m"}),") evenutally equally with (",(0,s.jsx)(n.code,{children:"ni + k"}),")","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"That means we need to iterate the loop"}),"\n",(0,s.jsxs)(n.li,{children:["As well as the list from ",(0,s.jsx)(n.code,{children:"head"}),"."]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}}}]);