"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[98120],{28453(e,n,r){r.d(n,{R:()=>o,x:()=>t});var s=r(96540);const l={},i=s.createContext(l);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:o(e.components),s.createElement(i.Provider,{value:n},e.children)}},49527(e,n,r){r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"rust/Ownership Rules","title":"Ownership Rules","description":"Ownership is Rust\u2019s way of managing memory without a garbage collector and without runtime overhead.","source":"@site/docs/rust/6. Ownership Rules.md","sourceDirName":"rust","slug":"/rust/Ownership Rules","permalink":"/handbook/docs/rust/Ownership Rules","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{}}');var l=r(74848),i=r(28453);const o={},t=void 0,a={},c=[{value:"The Three Ownership Rules",id:"the-three-ownership-rules",level:2},{value:"Rule 1: Each value in Rust has a single owner",id:"rule-1-each-value-in-rust-has-a-single-owner",level:3},{value:"Rule 2: When the owner goes out of scope, the value is dropped",id:"rule-2-when-the-owner-goes-out-of-scope-the-value-is-dropped",level:3},{value:"Rule 3: A value can only have one owner at a time",id:"rule-3-a-value-can-only-have-one-owner-at-a-time",level:3},{value:"Move vs Copy",id:"move-vs-copy",level:2},{value:"Types that are moved",id:"types-that-are-moved",level:3},{value:"Types that are copied",id:"types-that-are-copied",level:3},{value:"Ownership and Functions",id:"ownership-and-functions",level:2},{value:"Passing ownership to a function",id:"passing-ownership-to-a-function",level:3},{value:"Returning ownership",id:"returning-ownership",level:3},{value:"Borrowing (References)",id:"borrowing-references",level:2},{value:"Mutable Borrowing",id:"mutable-borrowing",level:2},{value:"The Borrowing Rules (Very Important)",id:"the-borrowing-rules-very-important",level:2},{value:"Dangling References (Prevented by Ownership)",id:"dangling-references-prevented-by-ownership",level:2},{value:"A Complete Example: Ownership in Action",id:"a-complete-example-ownership-in-action",level:2},{value:"Why Ownership Matters",id:"why-ownership-matters",level:2}];function h(e){const n={br:"br",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.p,{children:"Ownership is Rust\u2019s way of managing memory without a garbage collector and without runtime overhead.\r\nThe compiler enforces a set of rules at compile time to guarantee:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No use-after-free"}),"\n",(0,l.jsx)(n.li,{children:"No double-free"}),"\n",(0,l.jsx)(n.li,{children:"No data races"}),"\n",(0,l.jsx)(n.li,{children:"No dangling pointers"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"All of that, before your program ever runs."}),"\n",(0,l.jsx)(n.h2,{id:"the-three-ownership-rules",children:"The Three Ownership Rules"}),"\n",(0,l.jsx)(n.h3,{id:"rule-1-each-value-in-rust-has-a-single-owner",children:"Rule 1: Each value in Rust has a single owner"}),"\n",(0,l.jsx)(n.p,{children:"Every value has exactly one variable that owns it."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'let s = String::from("hello");\n'})}),"\n",(0,l.jsx)(n.p,{children:"Here:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["The ",(0,l.jsx)(n.code,{children:"String"})," value ",(0,l.jsx)(n.code,{children:'"hello"'})," is owned by ",(0,l.jsx)(n.code,{children:"s"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"s"})," is responsible for freeing the memory when it goes out of scope"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"rule-2-when-the-owner-goes-out-of-scope-the-value-is-dropped",children:"Rule 2: When the owner goes out of scope, the value is dropped"}),"\n",(0,l.jsxs)(n.p,{children:["When a variable goes out of scope, Rust automatically calls ",(0,l.jsx)(n.code,{children:"drop"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'{\r\n    let s = String::from("hello");\r\n} // s goes out of scope \u2192 memory is freed\n'})}),"\n",(0,l.jsxs)(n.p,{children:["No ",(0,l.jsx)(n.code,{children:"free()"}),", no GC. Rust does this deterministically."]}),"\n",(0,l.jsx)(n.h3,{id:"rule-3-a-value-can-only-have-one-owner-at-a-time",children:"Rule 3: A value can only have one owner at a time"}),"\n",(0,l.jsx)(n.p,{children:"This is the rule that surprises most people."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'let s1 = String::from("hello");\r\nlet s2 = s1; // ownership moves\n'})}),"\n",(0,l.jsx)(n.p,{children:"After this:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"s2"})," owns the string"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"s1"})," is invalid"]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'println!("{}", s1); // \u274c compile-time error\n'})}),"\n",(0,l.jsxs)(n.p,{children:["Why?",(0,l.jsx)(n.br,{}),"\n","Because if both ",(0,l.jsx)(n.code,{children:"s1"})," and ",(0,l.jsx)(n.code,{children:"s2"})," could free the same memory, you\u2019d get a double free bug."]}),"\n",(0,l.jsx)(n.p,{children:"Rust prevents that by moving ownership instead of copying."}),"\n",(0,l.jsx)(n.h2,{id:"move-vs-copy",children:"Move vs Copy"}),"\n",(0,l.jsx)(n.h3,{id:"types-that-are-moved",children:"Types that are moved"}),"\n",(0,l.jsxs)(n.p,{children:["Heap-allocated types: ",(0,l.jsx)(n.code,{children:"String"}),", ",(0,l.jsx)(n.code,{children:"Vec<T>"}),", ",(0,l.jsx)(n.code,{children:"Box<T>"})]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"let v1 = vec![1, 2, 3];\r\nlet v2 = v1; // move\r\n// v1 is no longer usable\n"})}),"\n",(0,l.jsx)(n.h3,{id:"types-that-are-copied",children:"Types that are copied"}),"\n",(0,l.jsxs)(n.p,{children:["Simple stack-only types implement the ",(0,l.jsx)(n.code,{children:"Copy"})," trait:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"i32"}),", ",(0,l.jsx)(n.code,{children:"f64"})]}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"bool"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"char"})}),"\n",(0,l.jsxs)(n.li,{children:["Tuples of ",(0,l.jsx)(n.code,{children:"Copy"})," types"]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'let x = 5;\r\nlet y = x; // copy\r\nprintln!("{}", x); // \u2705 OK\n'})}),"\n",(0,l.jsx)(n.p,{children:"These are cheap to duplicate and don\u2019t manage heap memory."}),"\n",(0,l.jsx)(n.h2,{id:"ownership-and-functions",children:"Ownership and Functions"}),"\n",(0,l.jsx)(n.h3,{id:"passing-ownership-to-a-function",children:"Passing ownership to a function"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'fn take_ownership(s: String) {\r\n    println!("{}", s);\r\n} // s is dropped here\r\n\r\nlet s = String::from("hello");\r\ntake_ownership(s);\r\nprintln!("{}", s); // \u274c error\n'})}),"\n",(0,l.jsx)(n.p,{children:"Ownership moves into the function."}),"\n",(0,l.jsx)(n.h3,{id:"returning-ownership",children:"Returning ownership"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'fn give_back(s: String) -> String {\r\n    s\r\n}\r\n\r\nlet s1 = String::from("hello");\r\nlet s2 = give_back(s1);\r\n// s1 is invalid, s2 owns the string\n'})}),"\n",(0,l.jsx)(n.p,{children:"This works, but passing ownership back and forth gets annoying."}),"\n",(0,l.jsx)(n.p,{children:"That\u2019s where borrowing comes in."}),"\n",(0,l.jsx)(n.h2,{id:"borrowing-references",children:"Borrowing (References)"}),"\n",(0,l.jsx)(n.p,{children:"Instead of transferring ownership, you can borrow a value."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'fn print_length(s: &String) {\r\n    println!("{}", s.len());\r\n}\r\n\r\nlet s = String::from("hello");\r\nprint_length(&s);\r\nprintln!("{}", s); // \u2705 still valid\n'})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"&String"})," is an immutable reference"]}),"\n",(0,l.jsx)(n.li,{children:"The function can read but not modify"}),"\n",(0,l.jsx)(n.li,{children:"Ownership never changes"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"mutable-borrowing",children:"Mutable Borrowing"}),"\n",(0,l.jsx)(n.p,{children:"You can also borrow mutably\u2014but carefully."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'fn add_world(s: &mut String) {\r\n    s.push_str(" world");\r\n}\r\n\r\nlet mut s = String::from("hello");\r\nadd_world(&mut s);\r\nprintln!("{}", s); // "hello world"\n'})}),"\n",(0,l.jsx)(n.h2,{id:"the-borrowing-rules-very-important",children:"The Borrowing Rules (Very Important)"}),"\n",(0,l.jsx)(n.p,{children:"At any given time, either:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Any number of immutable references"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"let r1 = &s;\r\nlet r2 = &s;\n"})}),"\n",(0,l.jsx)(n.p,{children:"OR"}),"\n",(0,l.jsxs)(n.ol,{start:"2",children:["\n",(0,l.jsx)(n.li,{children:"Exactly one mutable reference"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"let r = &mut s;\n"})}),"\n",(0,l.jsx)(n.p,{children:"\u274c You cannot mix them."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"let r1 = &s;\r\nlet r2 = &mut s; // \u274c compile-time error\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Why?",(0,l.jsx)(n.br,{}),"\n","Because mixing mutable and immutable access could lead to data races."]}),"\n",(0,l.jsx)(n.p,{children:"Rust enforces this at compile time."}),"\n",(0,l.jsx)(n.h2,{id:"dangling-references-prevented-by-ownership",children:"Dangling References (Prevented by Ownership)"}),"\n",(0,l.jsx)(n.p,{children:"Rust won\u2019t let references outlive the data they point to."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'fn dangling() -> &String {\r\n    let s = String::from("hello");\r\n    &s // \u274c s is dropped at end of function\r\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"The compiler stops this entirely."}),"\n",(0,l.jsx)(n.h2,{id:"a-complete-example-ownership-in-action",children:"A Complete Example: Ownership in Action"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'fn main() {\r\n    let mut s = String::from("Rust");\r\n\r\n    let len = calculate_length(&s);\r\n    println!("Length: {}", len);\r\n\r\n    modify(&mut s);\r\n    println!("Modified: {}", s);\r\n}\r\n\r\nfn calculate_length(s: &String) -> usize {\r\n    s.len()\r\n}\r\n\r\nfn modify(s: &mut String) {\r\n    s.push_str(" is awesome");\r\n}\n'})}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"s"})," owns the ",(0,l.jsx)(n.code,{children:"String"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"calculate_length"})," borrows immutably"]}),"\n",(0,l.jsxs)(n.li,{children:["Ownership stays in ",(0,l.jsx)(n.code,{children:"main"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"modify"})," borrows mutably"]}),"\n",(0,l.jsx)(n.li,{children:"Only one mutable borrow exists at that time"}),"\n",(0,l.jsx)(n.li,{children:"Memory is freed automatically when main ends"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"why-ownership-matters",children:"Why Ownership Matters"}),"\n",(0,l.jsx)(n.p,{children:"Ownership lets Rust guarantee:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No null pointers"}),"\n",(0,l.jsx)(n.li,{children:"No use-after-free"}),"\n",(0,l.jsx)(n.li,{children:"No data races"}),"\n",(0,l.jsx)(n.li,{children:"No memory leaks (unless you explicitly opt in)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"All with zero runtime cost."})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(h,{...e})}):h(e)}}}]);