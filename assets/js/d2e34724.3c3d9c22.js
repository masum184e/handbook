"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[64952],{28453(e,n,i){i.d(n,{R:()=>a,x:()=>t});var s=i(96540);const r={},l=s.createContext(r);function a(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(l.Provider,{value:n},e.children)}},59402(e,n,i){i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"design-patterns/SOLID Principles/SRP","title":"SRP","description":"The Single Responsibility Principle (SRP) is one of the most crucial concepts in SOLID. It\'s deceptively simple but incredibly impactful in creating clean, maintainable, and flexible systems.","source":"@site/docs/design-patterns/2. SOLID Principles/1. SRP.md","sourceDirName":"design-patterns/2. SOLID Principles","slug":"/design-patterns/SOLID Principles/SRP","permalink":"/handbook/docs/design-patterns/SOLID Principles/SRP","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"designPatternsSidebar","previous":{"title":"Between Classes","permalink":"/handbook/docs/design-patterns/Code Smells/Between Classes"},"next":{"title":"OCP","permalink":"/handbook/docs/design-patterns/SOLID Principles/OCP"}}');var r=i(74848),l=i(28453);const a={},t=void 0,o={},c=[{value:"Why SRP Exists",id:"why-srp-exists",level:2},{value:"Violating SRP \u2014 Classic Example",id:"violating-srp--classic-example",level:2},{value:"Applying SRP Properly",id:"applying-srp-properly",level:2},{value:"Step 1: User Class for Data Management",id:"step-1-user-class-for-data-management",level:3},{value:"Step 2: EmailService Class for Email Notifications",id:"step-2-emailservice-class-for-email-notifications",level:3},{value:"Step 3: Dependency Injection (Optional for Flexibility)",id:"step-3-dependency-injection-optional-for-flexibility",level:3},{value:"Real-World Example: Reporting System",id:"real-world-example-reporting-system",level:2},{value:"Correct Design (SRP Compliant)",id:"correct-design-srp-compliant",level:2},{value:"Real-World Example: Logging",id:"real-world-example-logging",level:2},{value:"Apply SRP by Extracting Logging",id:"apply-srp-by-extracting-logging",level:2},{value:"Tradeoffs of SRP",id:"tradeoffs-of-srp",level:2},{value:"Increased Number of Classes",id:"increased-number-of-classes",level:3},{value:"Over-Engineering Risk",id:"over-engineering-risk",level:3},{value:"Maintenance Costs",id:"maintenance-costs",level:3},{value:"Dependency Injection Overhead",id:"dependency-injection-overhead",level:3},{value:"SRP vs Other SOLID Principles",id:"srp-vs-other-solid-principles",level:2},{value:"When SRP Should Be Used",id:"when-srp-should-be-used",level:2},{value:"Final Summary",id:"final-summary",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"The Single Responsibility Principle (SRP) is one of the most crucial concepts in SOLID. It's deceptively simple but incredibly impactful in creating clean, maintainable, and flexible systems."}),"\n",(0,r.jsx)(n.p,{children:"A class should have only one reason to change, meaning that it should have only one job or responsibility."}),"\n",(0,r.jsx)(n.p,{children:"In simpler terms:"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"A class should have one focus \u2014 and should not be burdened with unrelated responsibilities."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"why-srp-exists",children:"Why SRP Exists"}),"\n",(0,r.jsx)(n.p,{children:"Every time you change a class for a new reason, you risk:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Unexpected side effects in other parts of the system."}),"\n",(0,r.jsx)(n.li,{children:"Increased coupling between unrelated features."}),"\n",(0,r.jsx)(n.li,{children:"Harder-to-test and maintain code."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"If a class takes on multiple responsibilities:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A change in one responsibility forces you to modify the class, affecting other parts of the system."}),"\n",(0,r.jsx)(n.li,{children:"This creates a domino effect \u2014 changes spread unpredictably."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"violating-srp--classic-example",children:"Violating SRP \u2014 Classic Example"}),"\n",(0,r.jsx)(n.p,{children:"Imagine a User class that handles both user data management and email notifications:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class User {\r\n    private String name;\r\n    private String email;\r\n\r\n    public void save() {\r\n        // Save user to database\r\n    }\r\n\r\n    public void sendWelcomeEmail() {\r\n        // Send email to user\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Problems:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The User class has two responsibilities:","\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Managing user data (save)."}),"\n",(0,r.jsx)(n.li,{children:"Sending email notifications."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"When the email notification logic changes (e.g., change email provider), we must modify the User class. This creates a fragile class and a highly coupled system."}),"\n",(0,r.jsx)(n.h2,{id:"applying-srp-properly",children:"Applying SRP Properly"}),"\n",(0,r.jsx)(n.p,{children:"We split responsibilities into separate classes. Each class should have one reason to change."}),"\n",(0,r.jsx)(n.h3,{id:"step-1-user-class-for-data-management",children:"Step 1: User Class for Data Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class User {\r\n    private String name;\r\n    private String email;\r\n\r\n    public void save() {\r\n        // Save user to database\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-2-emailservice-class-for-email-notifications",children:"Step 2: EmailService Class for Email Notifications"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class EmailService {\r\n    public void sendWelcomeEmail(User user) {\r\n        // Send welcome email to user\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"User has only one responsibility: user data management."}),"\n",(0,r.jsx)(n.li,{children:"EmailService has only one responsibility: sending email notifications."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"step-3-dependency-injection-optional-for-flexibility",children:"Step 3: Dependency Injection (Optional for Flexibility)"}),"\n",(0,r.jsx)(n.p,{children:"We inject the email service into the User class, making it testable and flexible."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class User {\r\n    private String name;\r\n    private String email;\r\n    private EmailService emailService;\r\n\r\n    public User(EmailService emailService) {\r\n        this.emailService = emailService;\r\n    }\r\n\r\n    public void save() {\r\n        // Save user to database\r\n    }\r\n\r\n    public void sendWelcomeEmail() {\r\n        emailService.sendWelcomeEmail(this);\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"real-world-example-reporting-system",children:"Real-World Example: Reporting System"}),"\n",(0,r.jsx)(n.p,{children:"Imagine a system where you generate reports, and your class handles both the logic of creating reports and printing them."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class ReportGenerator {\r\n    private String data;\r\n\r\n    public void generateReport() {\r\n        // Logic to generate report\r\n    }\r\n\r\n    public void printReport() {\r\n        // Logic to print report\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This violates SRP because:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The class is responsible for generating reports."}),"\n",(0,r.jsx)(n.li,{children:"The class is responsible for printing reports."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"correct-design-srp-compliant",children:"Correct Design (SRP Compliant)"}),"\n",(0,r.jsx)(n.p,{children:"We split the responsibilities:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class ReportGenerator {\r\n    private String data;\r\n\r\n    public void generateReport() {\r\n        // Logic to generate report\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class ReportPrinter {\r\n    public void printReport(ReportGenerator reportGenerator) {\r\n        // Logic to print report\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"ReportGenerator only generates reports."}),"\n",(0,r.jsx)(n.li,{children:"ReportPrinter only handles printing."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Each class has a single responsibility and one reason to change."}),"\n",(0,r.jsx)(n.h2,{id:"real-world-example-logging",children:"Real-World Example: Logging"}),"\n",(0,r.jsx)(n.p,{children:"Imagine a UserService class that both manages users and logs every operation."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'class UserService {\r\n    private Logger logger = new Logger();\r\n\r\n    public void createUser(String name) {\r\n        // Logic to create user\r\n        logger.log("User created: " + name);\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Problems:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["UserService is now responsible for:","\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"User creation."}),"\n",(0,r.jsx)(n.li,{children:"Logging."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"When logging needs to change (e.g., switch to a different logging framework), we must modify UserService, breaking SRP."}),"\n",(0,r.jsx)(n.h2,{id:"apply-srp-by-extracting-logging",children:"Apply SRP by Extracting Logging"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class Logger {\r\n    public void log(String message) {\r\n        // Log the message to the console or file\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'class UserService {\r\n    private Logger logger;\r\n\r\n    public UserService(Logger logger) {\r\n        this.logger = logger;\r\n    }\r\n\r\n    public void createUser(String name) {\r\n        // Logic to create user\r\n        logger.log("User created: " + name);\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Now:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"UserService only manages user creation."}),"\n",(0,r.jsx)(n.li,{children:"Logger is responsible for logging."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"tradeoffs-of-srp",children:"Tradeoffs of SRP"}),"\n",(0,r.jsx)(n.p,{children:"The benefits of SRP are clear, but like all principles, there are tradeoffs."}),"\n",(0,r.jsx)(n.h3,{id:"increased-number-of-classes",children:"Increased Number of Classes"}),"\n",(0,r.jsx)(n.p,{children:"SRP often leads to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"More classes"})," in the system"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Smaller classes"}),", each with a specific responsibility"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"While this improves flexibility, it can also increase complexity if taken too far."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Small systems"})," might not need so much abstraction."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Larger systems"})," benefit significantly from SRP because it minimizes the ripple effect of changes."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"over-engineering-risk",children:"Over-Engineering Risk"}),"\n",(0,r.jsx)(n.p,{children:"In some cases, applying SRP too early might result in unnecessary splitting of functionality into multiple classes."}),"\n",(0,r.jsx)(n.p,{children:"For example, creating separate classes for trivial responsibilities that aren\u2019t likely to change or grow can:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Make the codebase harder to navigate."}),"\n",(0,r.jsx)(n.li,{children:"Increase cognitive load for new developers."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class OrderValidator { ... }\r\nclass OrderProcessor { ... }\r\nclass OrderEmailer { ... }\n"})}),"\n",(0,r.jsx)(n.p,{children:"If your order class is extremely simple and doesn\u2019t need to change in the near future, splitting every small responsibility can become an over-engineering issue."}),"\n",(0,r.jsx)(n.h3,{id:"maintenance-costs",children:"Maintenance Costs"}),"\n",(0,r.jsx)(n.p,{children:"Although SRP improves maintainability in the long term, the short-term cost of refactoring a monolithic class into smaller ones can sometimes be high."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"You need to ensure that dependencies are injected properly."}),"\n",(0,r.jsx)(n.li,{children:"You may need to reorganize the system to accommodate the new structure."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"However, once these changes are made, testing and extending the system become much easier."}),"\n",(0,r.jsx)(n.h3,{id:"dependency-injection-overhead",children:"Dependency Injection Overhead"}),"\n",(0,r.jsx)(n.p,{children:"With SRP, you're often forced to rely on dependency injection (DI) to decouple the responsibilities. While DI makes testing and swapping components easier, it can introduce complexity:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"More constructors or setters to inject dependencies."}),"\n",(0,r.jsx)(n.li,{children:"Sometimes harder to follow the flow of the program."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"srp-vs-other-solid-principles",children:"SRP vs Other SOLID Principles"}),"\n",(0,r.jsx)(n.p,{children:"SRP is foundational but interacts with other SOLID principles:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"OCP (Open/Closed Principle)"}),": SRP allows classes to remain closed for modification by breaking down responsibilities."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"LSP (Liskov Substitution Principle)"}),": SRP ensures that your class does one thing well, which makes it safer to substitute."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DIP (Dependency Inversion Principle)"}),": SRP often requires dependency injection, which is enhanced by DIP, allowing for cleaner architecture."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ISP (Interface Segregation Principle)"}),": SRP helps ensure that interfaces don\u2019t become too large because each class has a single responsibility and needs fewer methods."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"when-srp-should-be-used",children:"When SRP Should Be Used"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"For large and complex systems, SRP reduces the risk of tightly coupled code."}),"\n",(0,r.jsx)(n.li,{children:"When your system is growing and likely to require changes in the future. The more things a class is responsible for, the more it will break when any part changes."}),"\n",(0,r.jsx)(n.li,{children:"For code that's going to be reused. By isolating a class\u2019s responsibility, you increase its reusability."}),"\n",(0,r.jsx)(n.li,{children:"When your code needs to be easily testable, SRP helps you isolate each behavior."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Avoid applying SRP too rigidly when:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"You're working with a simple, small system."}),"\n",(0,r.jsx)(n.li,{children:"You don\u2019t expect much change or growth in certain features."}),"\n",(0,r.jsx)(n.li,{children:"You prioritize short-term speed over long-term maintainability."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"final-summary",children:"Final Summary"}),"\n",(0,r.jsx)(n.p,{children:"The Single Responsibility Principle encourages you to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Split classes based on their responsibilities."}),"\n",(0,r.jsx)(n.li,{children:"Ensure each class has one reason to change."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Benefits:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"More maintainable code."}),"\n",(0,r.jsx)(n.li,{children:"Easier to extend and test."}),"\n",(0,r.jsx)(n.li,{children:"Clearer separation of concerns."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Tradeoffs:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"More classes and interfaces."}),"\n",(0,r.jsx)(n.li,{children:"Over-engineering risk."}),"\n",(0,r.jsx)(n.li,{children:"Initial complexity from refactoring."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"SRP helps manage complexity by minimizing coupling and focusing each class on one responsibility, making the codebase easier to maintain and extend."})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);