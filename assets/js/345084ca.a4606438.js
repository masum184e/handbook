"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[8825],{28453(e,t,n){n.d(t,{R:()=>o,x:()=>i});var r=n(96540);const s={},a=r.createContext(s);function o(e){const t=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:t},e.children)}},31480(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"design-patterns/Design Patterns/Creational/Factory","title":"Factory","description":"Defines an interface for creating an object but lets subclasses alter the type of object that will be created. This pattern is useful when the creation process varies based on input conditions.","source":"@site/docs/design-patterns/3. Design Patterns/1. Creational/2. Factory.md","sourceDirName":"design-patterns/3. Design Patterns/1. Creational","slug":"/design-patterns/Design Patterns/Creational/Factory","permalink":"/handbook/docs/design-patterns/Design Patterns/Creational/Factory","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"designPatternsSidebar","previous":{"title":"Singleton","permalink":"/handbook/docs/design-patterns/Design Patterns/Creational/Singleton"},"next":{"title":"Abstract","permalink":"/handbook/docs/design-patterns/Design Patterns/Creational/Abstract"}}');var s=n(74848),a=n(28453);const o={},i=void 0,c={},l=[{value:"Structure",id:"structure",level:4},{value:"Example",id:"example",level:4}];function d(e){const t={code:"code",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"Defines an interface for creating an object but lets subclasses alter the type of object that will be created. This pattern is useful when the creation process varies based on input conditions."}),"\n",(0,s.jsx)(t.h4,{id:"structure",children:"Structure"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Product (interface)"}),": Defines the interface for objects created by the factory method."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Concrete Product"}),": Implements the product interface."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Factory"}),": Declares the factory method, which returns an object of type Product. It may also define the default implementation of the factory method."]}),"\n"]}),"\n",(0,s.jsx)(t.h4,{id:"example",children:"Example"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'// Product interface\r\ninterface Animal {\r\n    void speak();\r\n}\r\n\r\n// Concrete Products\r\nclass Dog implements Animal {\r\n    public void speak() {\r\n        System.out.println("Bark!");\r\n    }\r\n}\r\n\r\nclass Cat implements Animal {\r\n    public void speak() {\r\n        System.out.println("Meow!");\r\n    }\r\n}\r\n\r\n// Factory\r\nclass AnimalFactory {\r\n    public Animal getAnimal(String type) {\r\n        if ("Dog".equalsIgnoreCase(type)) {\r\n            return new Dog();\r\n        } else if ("Cat".equalsIgnoreCase(type)) {\r\n            return new Cat();\r\n        }\r\n        return null;\r\n    }\r\n}\n'})})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);