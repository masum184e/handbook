"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[96546],{28453(e,n,i){i.d(n,{R:()=>l,x:()=>o});var s=i(96540);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}},52461(e,n,i){i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>a,frontMatter:()=>l,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"dsa/Concepts/Sorting","title":"Sorting","description":"- GeeksforGeeks","source":"@site/docs/dsa/1. Concepts/18. Sorting.md","sourceDirName":"dsa/1. Concepts","slug":"/dsa/Concepts/Sorting","permalink":"/handbook/docs/dsa/Concepts/Sorting","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":18,"frontMatter":{},"sidebar":"dsaSidebar","previous":{"title":"Queue","permalink":"/handbook/docs/dsa/Concepts/Queue"},"next":{"title":"Sliding Window","permalink":"/handbook/docs/dsa/Concepts/Sliding Window"}}');var r=i(74848),t=i(28453);const l={},o=void 0,d={},h=[{value:"Bubble Sort",id:"bubble-sort",level:2},{value:"Implementation",id:"implementation",level:3},{value:"Outer Loop",id:"outer-loop",level:3},{value:"Inner Loop",id:"inner-loop",level:3},{value:"Optimization",id:"optimization",level:3},{value:"Charecterstics",id:"charecterstics",level:3},{value:"When to use",id:"when-to-use",level:3},{value:"Recursion Implementation",id:"recursion-implementation",level:3},{value:"Selection Sort",id:"selection-sort",level:2},{value:"Implementation",id:"implementation-1",level:3},{value:"Outer Loop",id:"outer-loop-1",level:3},{value:"Inner Loop",id:"inner-loop-1",level:3},{value:"Swap",id:"swap",level:3},{value:"Characteristics",id:"characteristics",level:3},{value:"When to use",id:"when-to-use-1",level:3},{value:"Insertion Sort",id:"insertion-sort",level:2},{value:"Implementation",id:"implementation-2",level:3},{value:"Outer Loop",id:"outer-loop-2",level:3},{value:"Inner Loop",id:"inner-loop-2",level:3},{value:"Shifting",id:"shifting",level:3},{value:"Charecterstics",id:"charecterstics-1",level:3},{value:"When to use",id:"when-to-use-2",level:3},{value:"Merge Sort",id:"merge-sort",level:2},{value:"Implementation",id:"implementation-3",level:3},{value:"Merge Sort",id:"merge-sort-1",level:4},{value:"Merge",id:"merge",level:4},{value:"Charecterstics",id:"charecterstics-2",level:3},{value:"When to use",id:"when-to-use-3",level:3},{value:"Practice",id:"practice",level:3},{value:"Quick Sort",id:"quick-sort",level:2},{value:"Implementation",id:"implementation-4",level:3},{value:"Pivot Selection",id:"pivot-selection",level:4},{value:"Partitioning",id:"partitioning",level:4},{value:"Recursion",id:"recursion",level:4},{value:"Charecterstics",id:"charecterstics-3",level:3},{value:"When to use",id:"when-to-use-4",level:3},{value:"Dutch National Flag",id:"dutch-national-flag",level:2},{value:"Implementation",id:"implementation-5",level:3},{value:"Charecterstics",id:"charecterstics-4",level:3},{value:"Count Sort",id:"count-sort",level:2},{value:"Implementation",id:"implementation-6",level:3},{value:"Find the count of every distinct element",id:"find-the-count-of-every-distinct-element",level:4},{value:"Charecterstics",id:"charecterstics-5",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.geeksforgeeks.org/sorting-algorithms/",children:"GeeksforGeeks"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://leetcode.com/problem-list/sorting/",children:"Leetcode"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"bubble-sort",children:"Bubble Sort"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["It works by repeatedly ",(0,r.jsx)(n.code,{children:"swapping adjacent elements"})," if they are in the wrong order."]}),"\n",(0,r.jsx)(n.li,{children:'This process "bubbles" the largest (or smallest) element to its correct position in each pass through the list.'}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Outer Loop"}),"\n",(0,r.jsx)(n.li,{children:"Inner Loop"}),"\n",(0,r.jsx)(n.li,{children:"Optimaztaion"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"outer-loop",children:"Outer Loop"}),"\n",(0,r.jsxs)(n.p,{children:["Traverse the array from first to second last(",(0,r.jsx)(n.code,{children:"size-1"}),') element and for each iteration assume the largest unsorted element "bubbles up" to its correct position.']}),"\n",(0,r.jsx)(n.h3,{id:"inner-loop",children:"Inner Loop"}),"\n",(0,r.jsx)(n.p,{children:"Compare adjacent elements. If the current element is greater than the next element, swap them."}),"\n",(0,r.jsxs)(n.p,{children:["It perform sorting from right to left, and in each iteration the from the last to last ",(0,r.jsx)(n.code,{children:"i"}),"th item has been sorted, so we don't need to iterate them so inner loop will continue at ",(0,r.jsx)(n.code,{children:"size-i-1"})," times."]}),"\n",(0,r.jsx)(n.h3,{id:"optimization",children:"Optimization"}),"\n",(0,r.jsx)(n.p,{children:"Outer loop doesnn't have anything with the element of the array. Inner loop compare and bubbles up the element. Outer loop is just counting the element means how much times the array needs to bubbles up(the number of time inner loop should run)"}),"\n",(0,r.jsx)(n.p,{children:"Inner loop is comparing adjacent element and bubbles up, if no perform in on outer loop iteration means the array is already sorted, so we don't need to run the outer loop again."}),"\n",(0,r.jsx)(n.h3,{id:"charecterstics",children:"Charecterstics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"In-Place Sorting"})})," - no extra memory required"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity:"})," ",(0,r.jsx)(n.code,{children:"O(1)"}),"\r\nno extra memory required"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Worst Case: O(n",(0,r.jsx)("sup",{children:"2"}),") - when the list is in reverse order and requires maximum comparisons and swaps"]}),"\n",(0,r.jsxs)(n.li,{children:["Best Case: O(n",(0,r.jsx)("sup",{children:"2"}),") - when the list is already sorted, and no swaps are needed in a single pass."]}),"\n",(0,r.jsxs)(n.li,{children:["Average Case: O(n",(0,r.jsx)("sup",{children:"2"}),")"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Number of Swaps:"})," - In the worst-case scenario, the number of swaps performed by Bubble Sort is equal to the maximum number of inversions in the list. An inversion is a pair of elements where the earlier element is greater than the later one. In the worst case, the list is sorted in reverse order, and every element needs to be swapped into its correct position. That means we need n*(n-1)/2 swaps"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Number of Comparisons:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"first iteration it compare n-1 items"}),"\n",(0,r.jsx)(n.li,{children:"secont iteration it compare n-2 items"}),"\n",(0,r.jsx)(n.li,{children:"so total comparison is n*(n-1)/2"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stability:"})," - It is not stable, meaning that it might change the relative order of equal elements if swapping places them differently."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use",children:"When to use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"small dataset"}),"\n",(0,r.jsx)(n.li,{children:"memory constraint"}),"\n",(0,r.jsx)(n.li,{children:"educational purpose"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"recursion-implementation",children:"Recursion Implementation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Outer loop iterate through ",(0,r.jsx)(n.code,{children:"0"})," to ",(0,r.jsx)(n.code,{children:"n-1"})]}),"\n",(0,r.jsx)(n.li,{children:"So make a recursion call that can iterate the whole array"}),"\n",(0,r.jsx)(n.li,{children:"Outer loop just count how much time the array should bubble up, so make a recursion call that simply count the number of time array should bubbles up"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"selection-sort",children:"Selection Sort"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"It is a simple comparison-based sorting algorithm."}),"\n",(0,r.jsxs)(n.li,{children:["It works by ",(0,r.jsx)(n.code,{children:"repeatedly selecting the smallest"})," (or largest, depending on sorting order) element from the unsorted portion of the list and ",(0,r.jsx)(n.code,{children:"swapping it with the first element"})," of the unsorted section. This process is repeated until the entire list is sorted."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"implementation-1",children:"Implementation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Outer Loop"}),"\n",(0,r.jsx)(n.li,{children:"Inner Loop"}),"\n",(0,r.jsx)(n.li,{children:"Swap"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"outer-loop-1",children:"Outer Loop"}),"\n",(0,r.jsxs)(n.p,{children:["Traverse the array from first to second last(",(0,r.jsx)(n.code,{children:"size-1"}),") element and for each iteration assume first unsorted element is the smallest"]}),"\n",(0,r.jsxs)(n.p,{children:["The array is divided into two equal parts initially sorted(left) have no element and unsorted(right) have all element, in each iteration ",(0,r.jsx)(n.code,{children:"i"}),"th item has been sorted as it's the first element of unsorted array"]}),"\n",(0,r.jsx)(n.h3,{id:"inner-loop-1",children:"Inner Loop"}),"\n",(0,r.jsx)(n.p,{children:"It is used to find the smallest element from the unsorted portion of the array"}),"\n",(0,r.jsx)(n.h3,{id:"swap",children:"Swap"}),"\n",(0,r.jsxs)(n.p,{children:["you have the first item from the unsorted portion of the array which is from the outer loop and indicates as ",(0,r.jsx)(n.code,{children:"min_index = i"})]}),"\n",(0,r.jsxs)(n.p,{children:["you also have the minimum item indexes from inner loop, so just ",(0,r.jsx)(n.code,{children:"swap the smallest item with first element"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["if first and smallest element are same no swap are required\r\n",(0,r.jsx)(n.code,{children:"if(min_index!=i) swap(arr[min_index], arr[i]);"})]}),"\n",(0,r.jsx)(n.h3,{id:"characteristics",children:"Characteristics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"In-Place Sorting"})})," - no extra memory required"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity:"})," ",(0,r.jsx)(n.code,{children:"O(1)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"no extra memory required"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Worst Case: O(n",(0,r.jsx)("sup",{children:"2"}),") - due to two nested loops"]}),"\n",(0,r.jsxs)(n.li,{children:["Best Case: O(n",(0,r.jsx)("sup",{children:"2"}),") - it still scans the unsorted portion even if the list is already sorted"]}),"\n",(0,r.jsxs)(n.li,{children:["Average Case: O(n",(0,r.jsx)("sup",{children:"2"}),")"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Number of Swaps:"})," - It performs at most n-1 swaps."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Number of Comparisons:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"first iteration it compare n-1 items"}),"\n",(0,r.jsx)(n.li,{children:"secont iteration it compare n-2 items"}),"\n",(0,r.jsx)(n.li,{children:"so total comparison is n*(n-1)/2"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stability:"})," - It is not stable, meaning that it might change the relative order of equal elements if swapping places them differently."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-1",children:"When to use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"minimum swaping requires"}),"\n",(0,r.jsx)(n.li,{children:"memory is constrained"}),"\n",(0,r.jsx)(n.li,{children:"small dataset"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"insertion-sort",children:"Insertion Sort"}),"\n",(0,r.jsx)(n.p,{children:"It mimics how we might sort playing cards in our hands."}),"\n",(0,r.jsx)(n.p,{children:"It works by dividing the array into a sorted and an unsorted portion. The algorithm progressively takes elements from the unsorted portion and inserts them into their correct position within the sorted portion."}),"\n",(0,r.jsx)(n.h3,{id:"implementation-2",children:"Implementation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Outer Loop"}),"\n",(0,r.jsx)(n.li,{children:"Inner Loop"}),"\n",(0,r.jsx)(n.li,{children:"Shifting"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"outer-loop-2",children:"Outer Loop"}),"\n",(0,r.jsx)(n.p,{children:"The first item is considered sorted by default. Outer loop iterates through the unsorted portion, pick one element at a time and placing it into the correct position in the sorted portion"}),"\n",(0,r.jsx)(n.h3,{id:"inner-loop-2",children:"Inner Loop"}),"\n",(0,r.jsx)(n.p,{children:"Inner loop is used to find out where the insertion should be performed. It iterate from the last element of sorted portion until lesser value of current element is not found. Until the lesser value is found the item from sorted portion shift one place right."}),"\n",(0,r.jsx)(n.h3,{id:"shifting",children:"Shifting"}),"\n",(0,r.jsxs)(n.p,{children:["It shifts elements instead of swapping. A variable ",(0,r.jsx)(n.code,{children:"j"})," is declared to track where to insert or the last index of the sorted portion after performing shifting operation."]}),"\n",(0,r.jsx)(n.h3,{id:"charecterstics-1",children:"Charecterstics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"In-Place Sorting"})})," - no extra memory required"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity"}),": ",(0,r.jsx)(n.code,{children:"O(1)"})," no extra memory required"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Worst Case: O(n",(0,r.jsx)("sup",{children:"2"}),") - the array is sorted in reverse order."]}),"\n",(0,r.jsx)(n.li,{children:"Best Case: O(n) - No shifting is required; each element is compared once and placed immediately."}),"\n",(0,r.jsxs)(n.li,{children:["Average Case: O(n",(0,r.jsx)("sup",{children:"2"}),")"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Number of Shift:"})," - in worst case at most n*(n-1)/2 shift is performed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Number of Comparisons:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"first iteration it compare n-1 items"}),"\n",(0,r.jsx)(n.li,{children:"secont iteration it compare n-2 items"}),"\n",(0,r.jsx)(n.li,{children:"so total comparison is n*(n-1)/2"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stability:"})," - It is stable, meaning that it keep the relative order of equal elements."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-2",children:"When to use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"small dataset"}),"\n",(0,r.jsx)(n.li,{children:"memory constraint"}),"\n",(0,r.jsx)(n.li,{children:"array is nearly sorted"}),"\n",(0,r.jsx)(n.li,{children:"minimum comparison required\\"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"merge-sort",children:"Merge Sort"}),"\n",(0,r.jsx)(n.p,{children:"Merge Sort is a divide-and-conquer sorting algorithm that splits an array into smaller subarrays, sorts those subarrays, and then merges them back together in a sorted manner."}),"\n",(0,r.jsx)(n.h3,{id:"implementation-3",children:"Implementation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Merge Sort"}),"\n",(0,r.jsx)(n.li,{children:"Merge"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"merge-sort-1",children:"Merge Sort"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["divide the array into two equal part(",(0,r.jsx)(n.code,{children:"int mid = left + (right - left) / 2;"}),")."]}),"\n",(0,r.jsx)(n.li,{children:"splitting the array should be continued until each subarray contains a single element or is empty."}),"\n",(0,r.jsx)(n.li,{children:"splitting occurs recursively untile the most left node is found, when the most left node is found, it traverse to right one, and it contues untill all element is splitted."}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"merge",children:"Merge"}),"\n",(0,r.jsx)(n.p,{children:"Combine the two sorted halves into a single sorted array by comparing elements from each half and inserting the smaller one into the final array."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"extract the size of both array."}),"\n",(0,r.jsx)(n.li,{children:"copy data from main array to temporary array."}),"\n",(0,r.jsx)(n.li,{children:"compare and merge same amount of item from both array."}),"\n",(0,r.jsx)(n.li,{children:"merge remaining item of left array."}),"\n",(0,r.jsx)(n.li,{children:"merge remaining item of right array."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"charecterstics-2",children:"Charecterstics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity"}),": ",(0,r.jsx)(n.code,{children:"O(n)"})," - due to the temporary arrays used during merging."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Worst Case: O(n log n)"}),"\n",(0,r.jsx)(n.li,{children:"Best Case: O(n log n)"}),"\n",(0,r.jsx)(n.li,{children:"Average Case: O(n log n)"}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"log n"})," factor comes from the division of the array, and the ",(0,r.jsx)(n.code,{children:"n"})," factor comes from the merging process."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Number of Comparisons:"})," in each step there will be ",(0,r.jsx)(n.code,{children:"n"})," number of comparison and there have total ",(0,r.jsx)(n.code,{children:"log n"})," step so total comparison is ",(0,r.jsx)(n.code,{children:"n log n"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stability:"})," - It is stable, meaning that it keep the relative order of equal elements."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-3",children:"When to use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"large dataset"}),"\n",(0,r.jsx)(n.li,{children:"suitable for linked lists because it avoids the overhead of random access."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"practice",children:"Practice"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Basic:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.geeksforgeeks.org/merge-sort/",children:"Merge Sort Implementation - GeeksforGeeks"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.geeksforgeeks.org/counting-inversions/",children:"Count Inversions in an Array - GeeksforGeeks"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.geeksforgeeks.org/sort-characters-string/",children:"Sorting Strings Using Merge Sort - GeeksforGeeks"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Intermediate Problems:"})}),"\n",(0,r.jsxs)(n.ol,{start:"4",children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/",children:"Kth Smallest Element in Sorted Matrix - LeetCode"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.geeksforgeeks.org/merge-k-sorted-arrays/",children:"Merge K Sorted Arrays - GeeksforGeeks"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/median-of-two-sorted-arrays/",children:"Median of Two Sorted Arrays - LeetCode"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.geeksforgeeks.org/check-two-arrays-equal-not/",children:"Check If Arrays Are Identical - GeeksforGeeks"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Advanced Problems:"})}),"\n",(0,r.jsxs)(n.ol,{start:"8",children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.geeksforgeeks.org/merge-sort-for-linked-list/",children:"Merge Sort for Linked List - GeeksforGeeks"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.geeksforgeeks.org/closest-pair-of-points-using-divide-and-conquer-algorithm/",children:"Closest Pair of Points Using Divide and Conquer - GeeksforGeeks"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/reverse-pairs/",children:"Reverse Pairs - LeetCode"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.geeksforgeeks.org/maximum-sum-of-k-non-overlapping-subarrays/",children:"Maximum Sum of Non-Overlapping Subarrays - GeeksforGeeks"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Platform:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://leetcode.com/problem-list/merge-sort/",children:"LeetCode"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.geeksforgeeks.org/merge-sort-based-practice-problems/",children:"GeeksforGeeks"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"quick-sort",children:"Quick Sort"}),"\n",(0,r.jsx)(n.p,{children:'Quick Sort is a divide-and-conquer sorting algorithm that works by selecting a "pivot" element and partitioning the array around the pivot.'}),"\n",(0,r.jsx)(n.p,{children:"The goal is to move smaller elements to the left of the pivot and larger elements to the right. The process is then recursively applied to the sub-arrays."}),"\n",(0,r.jsx)(n.h3,{id:"implementation-4",children:"Implementation"}),"\n",(0,r.jsx)(n.h4,{id:"pivot-selection",children:"Pivot Selection"}),"\n",(0,r.jsx)(n.p,{children:"The pivot is an element around which the array will be partitioned. Popular strategies include:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"First element - may lead to poor performancefor sorted/revers sorted arrays"}),"\n",(0,r.jsx)(n.li,{children:"Last element - similar limatations as first element"}),"\n",(0,r.jsx)(n.li,{children:"Random - helps by avoiding worst-case scenarios"}),"\n",(0,r.jsx)(n.li,{children:"Medeian of first, last, middle"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"partitioning",children:"Partitioning"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The array is rearranged such that:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"All elements smaller than the pivot are moved to its left."}),"\n",(0,r.jsx)(n.li,{children:"All elements larger than the pivot are moved to its right."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"This ensures the pivot is in its correct position in the sorted array."}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"swap(arr[i], arr[j]);"})," may swap itself."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"recursion",children:"Recursion"}),"\n",(0,r.jsx)(n.p,{children:"Apply the same steps to the left and right sub-arrays."}),"\n",(0,r.jsx)(n.h3,{id:"charecterstics-3",children:"Charecterstics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"In-Place Sorting"})}),' - no extra memory required during partitioning, recursive call use the function stack for managing sub-problems, but this space usage is not considered "external memory".']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity:"})," ",(0,r.jsx)(n.code,{children:"O(log n)"})," - due to recursive calls in the function stack."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Worst Case: O(n",(0,r.jsx)("sup",{children:"2"}),") - occurs when the pivot consistently produces unbalanced partitions(smallest/largest)"]}),"\n",(0,r.jsx)(n.li,{children:"Best Case: O(n log n) - occurs when the partition is balanced(equal element)"}),"\n",(0,r.jsx)(n.li,{children:"Average Case: O(n log n)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Number of Comparisons:"})," It depends on the pivot selection and how the array is partitioned at each step. in worst case n*(n+1)/2 comparison will occur such as pivot is largest/smalles element.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"first partion produces one sub array with n-1 item and another one is 0"}),"\n",(0,r.jsx)(n.li,{children:"second partion produces one sub array with n-2 item and another one is 1"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Number of Swaps:"})," after making a comparison swap has been performed. so max swap can be n*(n+1)/2"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stability:"})," - It is not stable, meaning that it might change the relative order of equal elements if swapping places them differently."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-4",children:"When to use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"large dataset"}),"\n",(0,r.jsx)(n.li,{children:"in-place sorting"}),"\n",(0,r.jsx)(n.li,{children:"Performs well with random inputs compared to already sorted or reverse-sorted arrays."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"dutch-national-flag",children:"Dutch National Flag"}),"\n",(0,r.jsx)(n.p,{children:"It is used for rearranging elements in an array based on multiple distinct categories. It is commonly used when elements need to be categorized into three groups."}),"\n",(0,r.jsx)(n.h3,{id:"implementation-5",children:"Implementation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use a three-pointer approach with ",(0,r.jsx)(n.code,{children:"low"}),", ",(0,r.jsx)(n.code,{children:"mid"}),", and ",(0,r.jsx)(n.code,{children:"high"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Initialize:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"low = 0"})," - track the first category."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"mid = 0"})," - scan the array."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"high = size - 1"})," - track the last category."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Traverse the array and swap elements into their correct positions:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"arr[mid] == 0"})," - swap with ",(0,r.jsx)(n.code,{children:"low"})," and increment both ",(0,r.jsx)(n.code,{children:"low"})," and ",(0,r.jsx)(n.code,{children:"mid"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"arr[mid] == 1"})," - increment the mid"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"arr[mid] == 2"})," - swap with ",(0,r.jsx)(n.code,{children:"high"})," and decerement ",(0,r.jsx)(n.code,{children:"high"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"charecterstics-4",children:"Charecterstics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity:"})," ",(0,r.jsx)(n.code,{children:"O(n)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity:"})," ",(0,r.jsx)(n.code,{children:"O(1)"})]}),"\n",(0,r.jsx)(n.li,{children:"It rearranges elements in a single pass"}),"\n",(0,r.jsx)(n.li,{children:"In-place Rearrangement"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"count-sort",children:"Count Sort"}),"\n",(0,r.jsxs)(n.p,{children:["It is a ",(0,r.jsx)(n.code,{children:"non-comparison-based"})," sorting algorithm that works well for sorting integers or items with a ",(0,r.jsx)(n.code,{children:"limited range"})," of discrete values. It is especially efficient when the range of input values is not significantly larger than the number of elements."]}),"\n",(0,r.jsx)(n.p,{children:"The algorithm works by counting the occurrences of each element and using this information to place elements in their correct position in the sorted array."}),"\n",(0,r.jsx)(n.h3,{id:"implementation-6",children:"Implementation"}),"\n",(0,r.jsx)(n.h4,{id:"find-the-count-of-every-distinct-element",children:"Find the count of every distinct element"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"size of count array will be the maximum value from the array."}),"\n",(0,r.jsx)(n.li,{children:"traverse the array and count all the distinct element"}),"\n",(0,r.jsx)(n.li,{children:"extract cumulative sum of counts which optimize extraction of position of each item."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"charecterstics-5",children:"Charecterstics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity:"})," ",(0,r.jsx)(n.code,{children:"O(n + k)"})," - n is the number of elements and k is the range of the input."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity:"})," ",(0,r.jsx)(n.code,{children:"O(n + k)"})," - n is the number of elements and k is the range of the input."]}),"\n"]}),"\n",(0,r.jsx)(n.h1,{id:"comparison-table",children:"Comparison Table"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Algorithm"}),(0,r.jsx)(n.th,{children:"Best Case"}),(0,r.jsx)(n.th,{children:"Average Case"}),(0,r.jsx)(n.th,{children:"Worst Case"}),(0,r.jsx)(n.th,{children:"Space Complexity"}),(0,r.jsx)(n.th,{children:"Stable"}),(0,r.jsx)(n.th,{children:"In-Place"}),(0,r.jsx)(n.th,{children:"Notes"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Bubble Sort"})}),(0,r.jsx)(n.td,{children:"O(n)"}),(0,r.jsx)(n.td,{children:"O(n\xb2)"}),(0,r.jsx)(n.td,{children:"O(n\xb2)"}),(0,r.jsx)(n.td,{children:"O(1)"}),(0,r.jsx)(n.td,{children:"\u2705 Yes"}),(0,r.jsx)(n.td,{children:"\u2705 Yes"}),(0,r.jsx)(n.td,{children:"Very simple, very slow"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Selection Sort"})}),(0,r.jsx)(n.td,{children:"O(n\xb2)"}),(0,r.jsx)(n.td,{children:"O(n\xb2)"}),(0,r.jsx)(n.td,{children:"O(n\xb2)"}),(0,r.jsx)(n.td,{children:"O(1)"}),(0,r.jsx)(n.td,{children:"\u274c No"}),(0,r.jsx)(n.td,{children:"\u2705 Yes"}),(0,r.jsx)(n.td,{children:"Fewer swaps, still slow"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Insertion Sort"})}),(0,r.jsx)(n.td,{children:"O(n)"}),(0,r.jsx)(n.td,{children:"O(n\xb2)"}),(0,r.jsx)(n.td,{children:"O(n\xb2)"}),(0,r.jsx)(n.td,{children:"O(1)"}),(0,r.jsx)(n.td,{children:"\u2705 Yes"}),(0,r.jsx)(n.td,{children:"\u2705 Yes"}),(0,r.jsx)(n.td,{children:"Great for small or nearly sorted data"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Merge Sort"})}),(0,r.jsx)(n.td,{children:"O(n log n)"}),(0,r.jsx)(n.td,{children:"O(n log n)"}),(0,r.jsx)(n.td,{children:"O(n log n)"}),(0,r.jsx)(n.td,{children:"O(n)"}),(0,r.jsx)(n.td,{children:"\u2705 Yes"}),(0,r.jsx)(n.td,{children:"\u274c No"}),(0,r.jsx)(n.td,{children:"Consistent performance, extra memory"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Quick Sort"})}),(0,r.jsx)(n.td,{children:"O(n log n)"}),(0,r.jsx)(n.td,{children:"O(n log n)"}),(0,r.jsx)(n.td,{children:"O(n\xb2)"}),(0,r.jsx)(n.td,{children:"O(log n)"}),(0,r.jsx)(n.td,{children:"\u274c No"}),(0,r.jsx)(n.td,{children:"\u2705 Yes"}),(0,r.jsx)(n.td,{children:"Very fast in practice"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Heap Sort"})}),(0,r.jsx)(n.td,{children:"O(n log n)"}),(0,r.jsx)(n.td,{children:"O(n log n)"}),(0,r.jsx)(n.td,{children:"O(n log n)"}),(0,r.jsx)(n.td,{children:"O(1)"}),(0,r.jsx)(n.td,{children:"\u274c No"}),(0,r.jsx)(n.td,{children:"\u2705 Yes"}),(0,r.jsx)(n.td,{children:"No worst-case slowdown"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Counting Sort"})}),(0,r.jsx)(n.td,{children:"O(n + k)"}),(0,r.jsx)(n.td,{children:"O(n + k)"}),(0,r.jsx)(n.td,{children:"O(n + k)"}),(0,r.jsx)(n.td,{children:"O(k)"}),(0,r.jsx)(n.td,{children:"\u2705 Yes"}),(0,r.jsx)(n.td,{children:"\u274c No"}),(0,r.jsx)(n.td,{children:"Works only with small integer ranges"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Radix Sort"})}),(0,r.jsx)(n.td,{children:"O(nk)"}),(0,r.jsx)(n.td,{children:"O(nk)"}),(0,r.jsx)(n.td,{children:"O(nk)"}),(0,r.jsx)(n.td,{children:"O(n + k)"}),(0,r.jsx)(n.td,{children:"\u2705 Yes"}),(0,r.jsx)(n.td,{children:"\u274c No"}),(0,r.jsx)(n.td,{children:"Uses digit-by-digit sorting"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Bucket Sort"})}),(0,r.jsx)(n.td,{children:"O(n + k)"}),(0,r.jsx)(n.td,{children:"O(n + k)"}),(0,r.jsx)(n.td,{children:"O(n\xb2)"}),(0,r.jsx)(n.td,{children:"O(n + k)"}),(0,r.jsx)(n.td,{children:"Depends"}),(0,r.jsx)(n.td,{children:"\u274c No"}),(0,r.jsx)(n.td,{children:"Best for uniformly distributed data"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Shell Sort"})}),(0,r.jsx)(n.td,{children:"O(n log n)"}),(0,r.jsx)(n.td,{children:"O(n^1.5)"}),(0,r.jsx)(n.td,{children:"O(n\xb2)"}),(0,r.jsx)(n.td,{children:"O(1)"}),(0,r.jsx)(n.td,{children:"\u274c No"}),(0,r.jsx)(n.td,{children:"\u2705 Yes"}),(0,r.jsx)(n.td,{children:"Improved insertion sort"})]})]})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stable"}),": Keeps the order of equal elements"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"In-Place"}),": Uses constant extra memory"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"k"}),": Range of input values or number of digits"]}),"\n"]})]})}function a(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);