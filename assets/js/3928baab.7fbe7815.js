"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[6975],{5095(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"dsa/Concepts/Linked List","title":"Linked List","description":"Floyd\'s Cycle Finding Algorithm","source":"@site/docs/dsa/1. Concepts/Linked List.md","sourceDirName":"dsa/1. Concepts","slug":"/dsa/Concepts/Linked List","permalink":"/handbook/docs/dsa/Concepts/Linked List","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"dsaSidebar","previous":{"title":"Greedy","permalink":"/handbook/docs/dsa/Concepts/Greedy"},"next":{"title":"Searching","permalink":"/handbook/docs/dsa/Concepts/Searching"}}');var o=t(4848),i=t(8453);const l={},r=void 0,d={},c=[{value:"Floyd&#39;s Cycle Finding Algorithm",id:"floyds-cycle-finding-algorithm",level:2},{value:"How It Works",id:"how-it-works",level:3},{value:"Loop",id:"loop",level:3},{value:"Start Point",id:"start-point",level:3}];function a(e){const n={blockquote:"blockquote",br:"br",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"floyds-cycle-finding-algorithm",children:"Floyd's Cycle Finding Algorithm"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"It also called tortoise algorithm"}),"\n",(0,o.jsx)(n.li,{children:"Use two pointer to move through the sequence at different speed"}),"\n"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["slow pointer => move one step ahead ",(0,o.jsx)(n.br,{}),"\n","fast pointer => move two step ahead"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,o.jsx)(n.p,{children:"When slow pointer enter the loop, fast pointer must be inside loop"}),"\n",(0,o.jsx)(n.p,{children:"If we consider distance between slow and fast pointer. At begining, it will be 0, then 1, then 2 and eventually it well become n but the distance between fast and slow(reverse) gradually reduce and eventually they see each other and loop detected."}),"\n",(0,o.jsx)(n.h3,{id:"loop",children:"Loop"}),"\n",(0,o.jsxs)(n.p,{children:["A loop means the ",(0,o.jsx)(n.strong,{children:"last node"})," of the linked list connected back to a node in the same linke list."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"       Loop                     Not Loop\r\n------------------------------------------------\r\n1 \u2192 2 \u2192 3 \u2192 4 \u2192 5      1 \u2192 2 \u2192 3 \u2192 4 \u2192 5 \u2192 6 \u2192 7\r\n          \u2191     \u2502                \u2191     \u2502\r\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2518                \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,o.jsx)(n.h3,{id:"start-point",children:"Start Point"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Distance covered by slow pointer: ",(0,o.jsx)(n.code,{children:"m + n*x + k"})]}),"\n",(0,o.jsxs)(n.li,{children:["Distance covered by fast pointer: ",(0,o.jsx)(n.code,{children:"m + n*y + k"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"m"}),": straight distance"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"n"}),": length of the loop"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"x"}),", ",(0,o.jsx)(n.code,{children:"y"}),": number of time loop iterate"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"k"}),": distance between start point and collision point"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Distance Calcualtion"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"fast        = 2 * slow\r\nm + n*y + k = 2 * (m + n*x + k)\r\n         ny = m + k + 2nx\r\n     ny-2nx = m + k\r\n    n(y-2x) = m + k\r\nn(y-2x) - k = m\r\n     ni - k = m\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"y-2x"})," times of extra iteration is used to detect the collison"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"m"})," is the distance of ",(0,o.jsx)(n.strong,{children:"head to start"})," which is ",(0,o.jsx)(n.code,{children:"ni-k"})," or ",(0,o.jsx)(n.code,{children:"ni+k"}),"(reverse)."]}),"\n",(0,o.jsxs)(n.li,{children:["So, to get start point, iterate the distance between head to start(",(0,o.jsx)(n.code,{children:"m"}),") evenutally equally with (",(0,o.jsx)(n.code,{children:"ni + k"}),")","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"That means we need to iterate the loop"}),"\n",(0,o.jsxs)(n.li,{children:["As well as the linst from ",(0,o.jsx)(n.code,{children:"head"}),"."]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}},8453(e,n,t){t.d(n,{R:()=>l,x:()=>r});var s=t(6540);const o={},i=s.createContext(o);function l(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);