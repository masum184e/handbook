"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[21998],{14346(r,e,n){n.r(e),n.d(e,{assets:()=>t,contentTitle:()=>d,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"rust/Error Handling.md/Custom Error Types","title":"Custom Error Types","description":"Using String or &str as errors is:","source":"@site/docs/rust/12. Error Handling.md/5. Custom Error Types.md","sourceDirName":"rust/12. Error Handling.md","slug":"/rust/Error Handling.md/Custom Error Types","permalink":"/handbook/docs/rust/Error Handling.md/Custom Error Types","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{}}');var i=n(74848),o=n(28453);const l={},d=void 0,t={},a=[{value:"Basic Custom Error Type with <code>enum</code>",id:"basic-custom-error-type-with-enum",level:2},{value:"Example 1: Simple calculator errors",id:"example-1-simple-calculator-errors",level:3},{value:"Adding underlying errors (wrapping errors)",id:"adding-underlying-errors-wrapping-errors",level:2},{value:"Example 2: Wrapping I/O and parsing errors",id:"example-2-wrapping-io-and-parsing-errors",level:3},{value:"Using <code>thiserror</code> (recommended for real projects)",id:"using-thiserror-recommended-for-real-projects",level:2},{value:"Example 3: Same error using <code>thiserror</code>",id:"example-3-same-error-using-thiserror",level:3},{value:"Designing good custom errors",id:"designing-good-custom-errors",level:2},{value:"Library vs Application Errors",id:"library-vs-application-errors",level:2},{value:"Summary",id:"summary",level:2}];function c(r){const e={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...r.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.p,{children:["Using ",(0,i.jsx)(e.code,{children:"String"})," or ",(0,i.jsx)(e.code,{children:"&str"})," as errors is:"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Hard to match on"}),"\n",(0,i.jsx)(e.li,{children:"Easy to misuse"}),"\n",(0,i.jsx)(e.li,{children:"Not expressive"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Custom error types let you:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Represent different failure cases clearly"}),"\n",(0,i.jsx)(e.li,{children:"Attach data to errors"}),"\n",(0,i.jsxs)(e.li,{children:["Use ",(0,i.jsx)(e.code,{children:"?"})," cleanly with multiple error sources"]}),"\n",(0,i.jsx)(e.li,{children:"Provide better debugging and user messages"}),"\n"]}),"\n",(0,i.jsxs)(e.h2,{id:"basic-custom-error-type-with-enum",children:["Basic Custom Error Type with ",(0,i.jsx)(e.code,{children:"enum"})]}),"\n",(0,i.jsx)(e.h3,{id:"example-1-simple-calculator-errors",children:"Example 1: Simple calculator errors"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-rust",children:'use std::fmt;\r\n\r\n#[derive(Debug)]\r\nenum CalcError {\r\n    DivisionByZero,\r\n    NegativeNumber,\r\n}\r\n\r\nimpl fmt::Display for CalcError {\r\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\r\n        match self {\r\n            CalcError::DivisionByZero => write!(f, "Cannot divide by zero"),\r\n            CalcError::NegativeNumber => write!(f, "Negative numbers are not allowed"),\r\n        }\r\n    }\r\n}\r\n\r\nimpl std::error::Error for CalcError {}\r\n\r\nfn divide(a: i32, b: i32) -> Result<i32, CalcError> {\r\n    if b == 0 {\r\n        Err(CalcError::DivisionByZero)\r\n    } else if a < 0 || b < 0 {\r\n        Err(CalcError::NegativeNumber)\r\n    } else {\r\n        Ok(a / b)\r\n    }\r\n}\r\n\r\nfn main() {\r\n    match divide(10, 0) {\r\n        Ok(result) => println!("Result: {}", result),\r\n        Err(e) => println!("Error: {}", e),\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"enum CalcError defines all possible error cases."}),"\n",(0,i.jsxs)(e.li,{children:["Implements:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"Debug"})," \u2192 for debugging output."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"Display"})," \u2192 for user-friendly messages."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"Error"})," \u2192 so it works with standard error handling tools."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["The function returns ",(0,i.jsx)(e.code,{children:"Result<i32, CalcError>"}),"."]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"adding-underlying-errors-wrapping-errors",children:"Adding underlying errors (wrapping errors)"}),"\n",(0,i.jsxs)(e.p,{children:["Often, your function calls other functions that already return errors (like ",(0,i.jsx)(e.code,{children:"io::Error"})," or ",(0,i.jsx)(e.code,{children:"ParseIntError"}),"). You want to wrap those instead of losing information."]}),"\n",(0,i.jsx)(e.h3,{id:"example-2-wrapping-io-and-parsing-errors",children:"Example 2: Wrapping I/O and parsing errors"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-rust",children:'use std::fs;\r\nuse std::io;\r\nuse std::num::ParseIntError;\r\nuse std::fmt;\r\n\r\n#[derive(Debug)]\r\nenum ReadNumberError {\r\n    Io(io::Error),\r\n    Parse(ParseIntError),\r\n}\r\n\r\nimpl fmt::Display for ReadNumberError {\r\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\r\n        match self {\r\n            ReadNumberError::Io(e) => write!(f, "I/O error: {}", e),\r\n            ReadNumberError::Parse(e) => write!(f, "Parse error: {}", e),\r\n        }\r\n    }\r\n}\r\n\r\nimpl std::error::Error for ReadNumberError {\r\n    fn source(&self) -> Option<&(dyn std::error::Error + \'static)> {\r\n        match self {\r\n            ReadNumberError::Io(e) => Some(e),\r\n            ReadNumberError::Parse(e) => Some(e),\r\n        }\r\n    }\r\n}\r\n\r\n// Enable automatic conversion using `?`\r\nimpl From<io::Error> for ReadNumberError {\r\n    fn from(err: io::Error) -> Self {\r\n        ReadNumberError::Io(err)\r\n    }\r\n}\r\n\r\nimpl From<ParseIntError> for ReadNumberError {\r\n    fn from(err: ParseIntError) -> Self {\r\n        ReadNumberError::Parse(err)\r\n    }\r\n}\r\n\r\nfn read_number(path: &str) -> Result<i32, ReadNumberError> {\r\n    let contents = fs::read_to_string(path)?;       // io::Error \u2192 ReadNumberError\r\n    let number = contents.trim().parse::<i32>()?;   // ParseIntError \u2192 ReadNumberError\r\n    Ok(number)\r\n}\r\n\r\nfn main() {\r\n    match read_number("number.txt") {\r\n        Ok(n) => println!("Number: {}", n),\r\n        Err(e) => {\r\n            println!("Error: {}", e);\r\n            if let Some(source) = e.source() {\r\n                println!("Caused by: {}", source);\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"The enum stores underlying errors."}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"From"})," implementations allow ",(0,i.jsx)(e.code,{children:"?"})," to work seamlessly."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"source()"})," enables error chaining (useful for logging)."]}),"\n"]}),"\n",(0,i.jsxs)(e.h2,{id:"using-thiserror-recommended-for-real-projects",children:["Using ",(0,i.jsx)(e.code,{children:"thiserror"})," (recommended for real projects)"]}),"\n",(0,i.jsxs)(e.p,{children:["Manually implementing ",(0,i.jsx)(e.code,{children:"Display"}),", ",(0,i.jsx)(e.code,{children:"Error"}),", and ",(0,i.jsx)(e.code,{children:"From"})," can get verbose. The ",(0,i.jsx)(e.code,{children:"thiserror"})," crate automates this."]}),"\n",(0,i.jsxs)(e.h3,{id:"example-3-same-error-using-thiserror",children:["Example 3: Same error using ",(0,i.jsx)(e.code,{children:"thiserror"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-rust",children:'use thiserror::Error;\r\nuse std::io;\r\nuse std::num::ParseIntError;\r\n\r\n#[derive(Debug, Error)]\r\nenum ReadNumberError {\r\n    #[error("I/O error: {0}")]\r\n    Io(#[from] io::Error),\r\n\r\n    #[error("Failed to parse number: {0}")]\r\n    Parse(#[from] ParseIntError),\r\n}\r\n\r\nfn read_number(path: &str) -> Result<i32, ReadNumberError> {\r\n    let contents = std::fs::read_to_string(path)?;\r\n    let number = contents.trim().parse::<i32>()?;\r\n    Ok(number)\r\n}\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"#[derive(Error)]"})," generates:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:"Display"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.code,{children:"Error"})}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"From"})," automatically."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.li,{children:"Much cleaner and more maintainable."}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"designing-good-custom-errors",children:"Designing good custom errors"}),"\n",(0,i.jsx)(e.p,{children:"Good error types:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Are specific (not just ",(0,i.jsx)(e.code,{children:"UnknownError"}),")"]}),"\n",(0,i.jsx)(e.li,{children:"Use enums for multiple cases"}),"\n",(0,i.jsx)(e.li,{children:"Wrap underlying errors instead of discarding them"}),"\n",(0,i.jsxs)(e.li,{children:["Provide helpful ",(0,i.jsx)(e.code,{children:"Display"})," messages"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"library-vs-application-errors",children:"Library vs Application Errors"}),"\n",(0,i.jsx)(e.p,{children:"Libraries:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Use precise custom error enums"}),"\n",(0,i.jsx)(e.li,{children:"Let callers match on variants"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Applications:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Often use ",(0,i.jsx)(e.code,{children:"Box<dyn Error>"})," or ",(0,i.jsx)(e.code,{children:"anyhow::Error"})," at top-level"]}),"\n",(0,i.jsx)(e.li,{children:"Internally still benefit from structured errors"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Custom error types improve clarity, safety, and debugging."}),"\n",(0,i.jsxs)(e.li,{children:["Use ",(0,i.jsx)(e.code,{children:"enum"})," to represent failure cases."]}),"\n",(0,i.jsxs)(e.li,{children:["Implement ",(0,i.jsx)(e.code,{children:"Display"}),", ",(0,i.jsx)(e.code,{children:"Error"}),", and ",(0,i.jsx)(e.code,{children:"From"})," for usability."]}),"\n",(0,i.jsxs)(e.li,{children:["Use ",(0,i.jsx)(e.code,{children:"thiserror"})," to reduce boilerplate."]}),"\n",(0,i.jsxs)(e.li,{children:["Combine with ",(0,i.jsx)(e.code,{children:"?"})," for clean, composable error propagation."]}),"\n"]})]})}function u(r={}){const{wrapper:e}={...(0,o.R)(),...r.components};return e?(0,i.jsx)(e,{...r,children:(0,i.jsx)(c,{...r})}):c(r)}},28453(r,e,n){n.d(e,{R:()=>l,x:()=>d});var s=n(96540);const i={},o=s.createContext(i);function l(r){const e=s.useContext(o);return s.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function d(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(i):r.components||i:l(r.components),s.createElement(o.Provider,{value:e},r.children)}}}]);