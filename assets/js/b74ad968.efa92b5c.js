"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[28016],{28453(e,n,s){s.d(n,{R:()=>i,x:()=>d});var l=s(96540);const r={},t=l.createContext(r);function i(e){const n=l.useContext(t);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),l.createElement(t.Provider,{value:n},e.children)}},54431(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>a,frontMatter:()=>i,metadata:()=>l,toc:()=>u});const l=JSON.parse('{"id":"rust/Asynchronous/Futures","title":"Futures","description":"At the highest level:","source":"@site/docs/rust/Asynchronous/2. Futures.md","sourceDirName":"rust/Asynchronous","slug":"/rust/Asynchronous/Futures","permalink":"/handbook/docs/rust/Asynchronous/Futures","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{}}');var r=s(74848),t=s(28453);const i={},d=void 0,c={},u=[{value:"The <code>Future</code> trait (real definition)",id:"the-future-trait-real-definition",level:2},{value:"Understanding <code>Poll</code>",id:"understanding-poll",level:2},{value:"Futures are lazy (very important)",id:"futures-are-lazy-very-important",level:2},{value:"Who polls a Future",id:"who-polls-a-future",level:2},{value:"What is <code>Context</code> and <code>Waker</code>",id:"what-is-context-and-waker",level:2},{value:"A future is a state machine",id:"a-future-is-a-state-machine",level:2},{value:"Example: a future that completes after being polled twice",id:"example-a-future-that-completes-after-being-polled-twice",level:3},{value:"How <code>async fn</code> becomes a Future",id:"how-async-fn-becomes-a-future",level:2},{value:"<code>.await</code> is just polling in a loop",id:"await-is-just-polling-in-a-loop",level:2},{value:"Example: Custom future with a timer (Tokio)",id:"example-custom-future-with-a-timer-tokio",level:2},{value:"Using futures directly vs <code>async/await</code>",id:"using-futures-directly-vs-asyncawait",level:2},{value:"Futures are single-use",id:"futures-are-single-use",level:2},{value:"Why <code>Pin&lt;&amp;mut Self&gt;</code>",id:"why-pinmut-self",level:2},{value:"<code>Send</code> futures and multithreading",id:"send-futures-and-multithreading",level:2},{value:"Key rules every future must follow",id:"key-rules-every-future-must-follow",level:2}];function o(e){const n={blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"At the highest level:"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.code,{children:"Future"})," represents a value that will be available later."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"But in Rust, that idea is made very explicit and low-level."}),"\n",(0,r.jsx)(n.p,{children:"A future is:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"lazy (nothing happens until it\u2019s polled)"}),"\n",(0,r.jsx)(n.li,{children:"stateful (it remembers where it left off)"}),"\n",(0,r.jsx)(n.li,{children:"cooperatively scheduled (it must voluntarily yield)"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"the-future-trait-real-definition",children:["The ",(0,r.jsx)(n.code,{children:"Future"})," trait (real definition)"]}),"\n",(0,r.jsxs)(n.p,{children:["From ",(0,r.jsx)(n.code,{children:"std::future"})," (simplified a bit):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use std::pin::Pin;\r\nuse std::task::{Context, Poll};\r\n\r\npub trait Future {\r\n    type Output;\r\n\r\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This single method explains everything."}),"\n",(0,r.jsxs)(n.h2,{id:"understanding-poll",children:["Understanding ",(0,r.jsx)(n.code,{children:"Poll"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"enum Poll<T> {\r\n    Ready(T),\r\n    Pending,\r\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Ready(value)"})," \u2192 the future is complete"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Pending"})," \u2192 not ready yet, poll me again later"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["A future is allowed to return ",(0,r.jsx)(n.code,{children:"Pending"})," as many times as it wants."]}),"\n",(0,r.jsx)(n.h2,{id:"futures-are-lazy-very-important",children:"Futures are lazy (very important)"}),"\n",(0,r.jsx)(n.p,{children:"This code does nothing:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"async fn compute() -> i32 {\r\n    5\r\n}\r\n\r\nfn main() {\r\n    let fut = compute();\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Why?"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"compute()"})," returns a ",(0,r.jsx)(n.code,{children:"Future"})]}),"\n",(0,r.jsx)(n.li,{children:"That future is never polled"}),"\n",(0,r.jsx)(n.li,{children:"So it never runs"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"In Rust:"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Creating a future does not start execution"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"who-polls-a-future",children:"Who polls a Future"}),"\n",(0,r.jsx)(n.p,{children:"A runtime / executor (Tokio, async-std, etc.)."}),"\n",(0,r.jsx)(n.p,{children:"The executor:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Calls ",(0,r.jsx)(n.code,{children:"poll()"})]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"Pending"}),", registers a waker"]}),"\n",(0,r.jsx)(n.li,{children:"Moves on to other futures"}),"\n",(0,r.jsx)(n.li,{children:"When woken, polls again"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"what-is-context-and-waker",children:["What is ",(0,r.jsx)(n.code,{children:"Context"})," and ",(0,r.jsx)(n.code,{children:"Waker"})]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"Context"})," gives the future a way to say:"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"\u201cHey executor, wake me up when I can make progress.\u201d"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Simplified:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"struct Context<'a> {\r\n    waker: &'a Waker,\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Waker"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Stored by the future"}),"\n",(0,r.jsx)(n.li,{children:"Used to notify the executor"}),"\n",(0,r.jsx)(n.li,{children:"Called when external state changes (socket ready, timer fired, etc.)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"a-future-is-a-state-machine",children:"A future is a state machine"}),"\n",(0,r.jsx)(n.p,{children:"Let\u2019s build a tiny future by hand to see this clearly."}),"\n",(0,r.jsx)(n.h3,{id:"example-a-future-that-completes-after-being-polled-twice",children:"Example: a future that completes after being polled twice"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use std::future::Future;\r\nuse std::pin::Pin;\r\nuse std::task::{Context, Poll};\r\n\r\nstruct TwoPollFuture {\r\n    polled_once: bool,\r\n}\r\n\r\nimpl Future for TwoPollFuture {\r\n    type Output = &'static str;\r\n\r\n    fn poll(mut self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {\r\n        if self.polled_once {\r\n            Poll::Ready(\"done\")\r\n        } else {\r\n            self.polled_once = true;\r\n            Poll::Pending\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"What\u2019s happening"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["First poll \u2192 ",(0,r.jsx)(n.code,{children:"Pending"})]}),"\n",(0,r.jsxs)(n.li,{children:["Second poll \u2192 ",(0,r.jsx)(n.code,{children:'Ready("done")'})]}),"\n",(0,r.jsxs)(n.li,{children:["Internal state (",(0,r.jsx)(n.code,{children:"polled_once"}),") tracks progress"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This is exactly what the compiler generates for ",(0,r.jsx)(n.code,{children:"async fn"}),"."]}),"\n",(0,r.jsxs)(n.h2,{id:"how-async-fn-becomes-a-future",children:["How ",(0,r.jsx)(n.code,{children:"async fn"})," becomes a Future"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"async fn example() -> i32 {\r\n    let a = 1;\r\n    let b = async_call().await;\r\n    a + b\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Roughly becomes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"enum ExampleState {\r\n    Start,\r\n    WaitingOnAsyncCall,\r\n    Done,\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Each ",(0,r.jsx)(n.code,{children:".await"})," is:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A possible ",(0,r.jsx)(n.code,{children:"Pending"})," return"]}),"\n",(0,r.jsx)(n.li,{children:"A resume point"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"await-is-just-polling-in-a-loop",children:[(0,r.jsx)(n.code,{children:".await"})," is just polling in a loop"]}),"\n",(0,r.jsx)(n.p,{children:"Conceptually:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"loop {\r\n    match future.poll(cx) {\r\n        Poll::Ready(val) => break val,\r\n        Poll::Pending => return Pending,\r\n    }\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:".await"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Polls the future"}),"\n",(0,r.jsxs)(n.li,{children:["Suspends if ",(0,r.jsx)(n.code,{children:"Pending"})]}),"\n",(0,r.jsx)(n.li,{children:"Resumes at the same line later"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"example-custom-future-with-a-timer-tokio",children:"Example: Custom future with a timer (Tokio)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use std::future::Future;\r\nuse std::pin::Pin;\r\nuse std::task::{Context, Poll};\r\nuse tokio::time::{Instant, Sleep};\r\n\r\nstruct MySleep {\r\n    sleep: Pin<Box<Sleep>>,\r\n}\r\n\r\nimpl Future for MySleep {\r\n    type Output = ();\r\n\r\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {\r\n        self.get_mut().sleep.as_mut().poll(cx)\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This wraps an existing future and delegates polling."}),"\n",(0,r.jsxs)(n.h2,{id:"using-futures-directly-vs-asyncawait",children:["Using futures directly vs ",(0,r.jsx)(n.code,{children:"async/await"})]}),"\n",(0,r.jsxs)(n.p,{children:["Using ",(0,r.jsx)(n.code,{children:"async/await"})," (normal)"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"async fn work() -> i32 {\r\n    10\r\n}\r\n\r\nlet result = work().await;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Using futures explicitly (rare, but educational)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use futures::executor::block_on;\r\n\r\nlet fut = work();\r\nlet result = block_on(fut);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Same thing. ",(0,r.jsx)(n.code,{children:".await"})," is just nicer syntax."]}),"\n",(0,r.jsx)(n.h2,{id:"futures-are-single-use",children:"Futures are single-use"}),"\n",(0,r.jsxs)(n.p,{children:["Once a future returns ",(0,r.jsx)(n.code,{children:"Ready"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"It must never be polled again"}),"\n",(0,r.jsx)(n.li,{children:"Polling again is undefined behavior"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"That\u2019s why futures are usually moved, not reused."}),"\n",(0,r.jsxs)(n.h2,{id:"why-pinmut-self",children:["Why ",(0,r.jsx)(n.code,{children:"Pin<&mut Self>"})]}),"\n",(0,r.jsx)(n.p,{children:"Short version:"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Futures must not move in memory once polling begins."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Because:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"They may store self-references"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:".await"})," points depend on stable addresses"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Pin"})," enforces this at compile time."]}),"\n",(0,r.jsxs)(n.h2,{id:"send-futures-and-multithreading",children:[(0,r.jsx)(n.code,{children:"Send"})," futures and multithreading"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Future + Send"})," \u2192 can move between threads"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"!Send"})," futures \u2192 must stay on one thread"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Tokio:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"spawn"})," requires ",(0,r.jsx)(n.code,{children:"Send"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"spawn_local"})," does not"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"key-rules-every-future-must-follow",children:"Key rules every future must follow"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Must not block"}),"\n",(0,r.jsxs)(n.li,{children:["Must return ",(0,r.jsx)(n.code,{children:"Pending"})," when not ready"]}),"\n",(0,r.jsx)(n.li,{children:"Must wake the executor when progress is possible"}),"\n",(0,r.jsx)(n.li,{children:"Must not be polled after completion"}),"\n",(0,r.jsx)(n.li,{children:"Must not move once pinned"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Break these and async breaks \ud83d\ude05"})]})}function a(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}}}]);