"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[72831],{28453(n,e,r){r.d(e,{R:()=>c,x:()=>a});var i=r(96540);const s={},t=i.createContext(s);function c(n){const e=i.useContext(t);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:c(n.components),i.createElement(t.Provider,{value:e},n.children)}},40964(n,e,r){r.r(e),r.d(e,{assets:()=>o,contentTitle:()=>a,default:()=>u,frontMatter:()=>c,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"dsa/Concepts/Recursion","title":"Recursion","description":"Recursion Tracing means following the execution flow of recursive calls:","source":"@site/docs/dsa/1. Concepts/5. Recursion.md","sourceDirName":"dsa/1. Concepts","slug":"/dsa/Concepts/Recursion","permalink":"/handbook/docs/dsa/Concepts/Recursion","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Recursion","sidebar_position":4},"sidebar":"dsaSidebar","previous":{"title":"Asymptotic Notation \u2714","permalink":"/handbook/docs/dsa/Concepts/Asymptotic Notations"},"next":{"title":"Backtracking","permalink":"/handbook/docs/dsa/Concepts/Backtracking"}}');var s=r(74848),t=r(28453);const c={title:"Recursion",sidebar_position:4},a=void 0,o={},l=[{value:"Direct Recursion",id:"direct-recursion",level:2},{value:"Indirect Recursion",id:"indirect-recursion",level:2},{value:"Tail Recursion",id:"tail-recursion",level:2},{value:"Head Recursion",id:"head-recursion",level:2},{value:"Tree Recursion",id:"tree-recursion",level:2},{value:"Nested Recursion",id:"nested-recursion",level:2}];function d(n){const e={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Recursion Tracing"})," means following the execution flow of recursive calls:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"How functions are called (going down the call stack)."}),"\n",(0,s.jsx)(e.li,{children:"How results come back (unwinding, going up the call stack)."}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"It helps us see what happens inside memory (stack frames) during recursion."}),"\n",(0,s.jsx)(e.h2,{id:"direct-recursion",children:"Direct Recursion"}),"\n",(0,s.jsx)(e.p,{children:"When a function calls itself directly."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"int factorial(int n) {\r\n    if (n == 0) return 1;        // Base case\r\n    return n * factorial(n - 1); // Direct recursion\r\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Tracing"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"factorial(4)\r\n \u2192 4 * factorial(3)\r\n     \u2192 3 * factorial(2)\r\n         \u2192 2 * factorial(1)\r\n             \u2192 1 * factorial(0)\r\n                 \u2192 return 1   (base case)\r\n             return 1\r\n         return 2 * 1 = 2\r\n     return 3 * 2 = 6\r\n return 4 * 6 = 24\n"})}),"\n",(0,s.jsx)(e.h2,{id:"indirect-recursion",children:"Indirect Recursion"}),"\n",(0,s.jsx)(e.p,{children:"When a function calls another function, and that function eventually calls the first one back."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'void B(int n);\r\n\r\nvoid A(int n) {\r\n    if (n > 0) {\r\n        cout << n << " ";\r\n        B(n - 1);   // A calls B\r\n    }\r\n}\r\n\r\nvoid B(int n) {\r\n    if (n > 1) {\r\n        cout << n << " ";\r\n        A(n / 2);   // B calls A\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Tracing"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"A(5) \u2192 prints A:5\r\n    B(4) \u2192 prints B:4\r\n        A(2) \u2192 prints A:2\r\n            B(1) \u2192 prints B:1\r\n                A(0) stops\n"})}),"\n",(0,s.jsx)(e.h2,{id:"tail-recursion",children:"Tail Recursion"}),"\n",(0,s.jsx)(e.p,{children:"When the recursive call is the last statement in the function (nothing to do after recursion returns). Can be optimized by the compiler (Tail Call Optimization)."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"int tailFactorial(int n, int result = 1) {\r\n    if (n == 0) return result;       // Base case\r\n    return tailFactorial(n - 1, n * result); // Tail recursion\r\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"Here, no pending operations after the recursive call."}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Tracing"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"tailRec(3) \u2192 prints 3\r\n    tailRec(2) \u2192 prints 2\r\n        tailRec(1) \u2192 prints 1\r\n            tailRec(0) \u2192 stops\n"})}),"\n",(0,s.jsx)(e.h2,{id:"head-recursion",children:"Head Recursion"}),"\n",(0,s.jsx)(e.p,{children:"When the recursive call happens first, before any other statements. Work happens after recursive call returns."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'void headRecursion(int n) {\r\n    if (n > 0) {\r\n        headRecursion(n - 1);  // Recursive call first\r\n        cout << n << " ";      // Work after return\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Tracing (it is different from other print is done returning time)"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"headRec(3)\r\n \u2192 headRec(2)\r\n     \u2192 headRec(1)\r\n         \u2192 headRec(0)   (base case, returns)\r\n         print 1\r\n     print 2\r\n print 3\n"})}),"\n",(0,s.jsx)(e.h2,{id:"tree-recursion",children:"Tree Recursion"}),"\n",(0,s.jsx)(e.p,{children:"When a function calls itself more than once."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"int fib(int n) {\r\n    if (n <= 1) return n;\r\n    return fib(n - 1) + fib(n - 2);  // Two recursive calls\r\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Tracing"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"fib(4)\r\n \u2192 fib(3) + fib(2)\r\n\r\nfib(3)\r\n \u2192 fib(2) + fib(1)\r\n\r\nfib(2)\r\n \u2192 fib(1) + fib(0)\r\n\r\nfib(1) \u2192 1\r\nfib(0) \u2192 0\r\nSo fib(2) = 1 + 0 = 1\r\n\r\nfib(1) \u2192 1\r\nSo fib(3) = 1 + 1 = 2\r\n\r\nfib(2) again\r\n \u2192 fib(1) + fib(0)\r\n \u2192 1 + 0 = 1\r\n\r\nSo fib(4) = 2 + 1 = 3\n"})}),"\n",(0,s.jsx)(e.h2,{id:"nested-recursion",children:"Nested Recursion"}),"\n",(0,s.jsx)(e.p,{children:"When a recursive function passes a recursive call as an argument."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"int nested(int n) {\r\n    if (n > 100) return n - 10;\r\n    return nested(nested(n + 11));\r\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Tracing"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"nested(95)\r\n \u2192 nested(nested(106))   // first call argument is another call\r\n     nested(106) \u2192 returns 96   (since >100, returns 106 - 10)\r\n \u2192 nested(96)\r\n     \u2192 nested(nested(107))\r\n         nested(107) \u2192 returns 97\r\n     \u2192 nested(97)\r\n         \u2192 nested(nested(108))\r\n             nested(108) \u2192 returns 98\r\n         \u2192 nested(98)\r\n             ...\r\n eventually reaches nested(101) \u2192 returns 91\n"})})]})}function u(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}}}]);