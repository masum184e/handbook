"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[30974],{28453(n,r,e){e.d(r,{R:()=>t,x:()=>a});var s=e(96540);const i={},l=s.createContext(i);function t(n){const r=s.useContext(l);return s.useMemo(function(){return"function"==typeof n?n(r):{...r,...n}},[r,n])}function a(n){let r;return r=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:t(n.components),s.createElement(l.Provider,{value:r},n.children)}},53641(n,r,e){e.r(r),e.d(r,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"rust/Asynchronous/Error Handling","title":"Error Handling","description":"Core rule:","source":"@site/docs/rust/Asynchronous/6. Error Handling.md","sourceDirName":"rust/Asynchronous","slug":"/rust/Asynchronous/Error Handling","permalink":"/handbook/docs/rust/Asynchronous/Error Handling","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{}}');var i=e(74848),l=e(28453);const t={},a=void 0,o={},c=[{value:"Async functions and <code>Result</code>",id:"async-functions-and-result",level:2},{value:"Using <code>?</code> inside async functions",id:"using--inside-async-functions",level:2},{value:"Handling errors at <code>.await</code> sites",id:"handling-errors-at-await-sites",level:2},{value:"Error handling across <code>.await</code> boundaries",id:"error-handling-across-await-boundaries",level:2},{value:"Custom error types in async code",id:"custom-error-types-in-async-code",level:2},{value:"Error handling with spawned tasks (very important)",id:"error-handling-with-spawned-tasks-very-important",level:2},{value:"Cancelling tasks and errors",id:"cancelling-tasks-and-errors",level:2},{value:"Error handling with <code>select!</code>",id:"error-handling-with-select",level:2},{value:"Streams and error handling",id:"streams-and-error-handling",level:2},{value:"Timeouts and errors",id:"timeouts-and-errors",level:2},{value:"Panic vs Result in async",id:"panic-vs-result-in-async",level:2},{value:"Common async error-handling mistakes",id:"common-async-error-handling-mistakes",level:2},{value:"Mental model",id:"mental-model",level:2}];function d(n){const r={blockquote:"blockquote",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.p,{children:"Core rule:"}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"Async Rust uses the same error handling model as sync Rust."}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"That means:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.code,{children:"Result<T, E>"})}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"?"})," operator"]}),"\n",(0,i.jsx)(r.li,{children:"Custom error types"}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"From"})," / ",(0,i.jsx)(r.code,{children:"Into"})]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"Async does not add exceptions, promises, or magic propagation."}),"\n",(0,i.jsx)(r.p,{children:"The only difference:"}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"Errors travel through futures."}),"\n"]}),"\n",(0,i.jsxs)(r.h2,{id:"async-functions-and-result",children:["Async functions and ",(0,i.jsx)(r.code,{children:"Result"})]}),"\n",(0,i.jsx)(r.p,{children:"An async function returning a result:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'async fn fetch_data() -> Result<String, std::io::Error> {\r\n    Ok("data".to_string())\r\n}\n'})}),"\n",(0,i.jsx)(r.p,{children:"This actually returns:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"impl Future<Output = Result<String, std::io::Error>>\n"})}),"\n",(0,i.jsxs)(r.p,{children:["So ",(0,i.jsx)(r.code,{children:".await"})," gives you a ",(0,i.jsx)(r.code,{children:"Result"}),"."]}),"\n",(0,i.jsxs)(r.h2,{id:"using--inside-async-functions",children:["Using ",(0,i.jsx)(r.code,{children:"?"})," inside async functions"]}),"\n",(0,i.jsx)(r.p,{children:"Nothing special here."}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'use tokio::fs;\r\n\r\nasync fn read_file() -> Result<String, std::io::Error> {\r\n    let content = fs::read_to_string("data.txt").await?;\r\n    Ok(content)\r\n}\n'})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["If ",(0,i.jsx)(r.code,{children:"read_to_string"})," fails"]}),"\n",(0,i.jsx)(r.li,{children:"The error is returned immediately"}),"\n",(0,i.jsxs)(r.li,{children:["The future resolves to ",(0,i.jsx)(r.code,{children:"Err(...)"})]}),"\n"]}),"\n",(0,i.jsxs)(r.h2,{id:"handling-errors-at-await-sites",children:["Handling errors at ",(0,i.jsx)(r.code,{children:".await"})," sites"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'#[tokio::main]\r\nasync fn main() -> Result<(), std::io::Error> {\r\n    let content = read_file().await?;\r\n    println!("{content}");\r\n    Ok(())\r\n}\n'})}),"\n",(0,i.jsx)(r.p,{children:"Clean. Linear. No nesting."}),"\n",(0,i.jsxs)(r.h2,{id:"error-handling-across-await-boundaries",children:["Error handling across ",(0,i.jsx)(r.code,{children:".await"})," boundaries"]}),"\n",(0,i.jsxs)(r.p,{children:["Each ",(0,i.jsx)(r.code,{children:".await"})," is a potential suspension point."]}),"\n",(0,i.jsx)(r.p,{children:"But:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Errors do not get lost"}),"\n",(0,i.jsx)(r.li,{children:"Stack traces remain logical (not real call stacks)"}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"async fn step1() -> Result<(), &'static str> {\r\n    Err(\"step1 failed\")\r\n}\r\n\r\nasync fn step2() -> Result<(), &'static str> {\r\n    step1().await?;\r\n    Ok(())\r\n}\n"})}),"\n",(0,i.jsxs)(r.p,{children:["If ",(0,i.jsx)(r.code,{children:"step1"})," fails:"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"step2"})," stops immediately"]}),"\n",(0,i.jsx)(r.li,{children:"Error propagates normally"}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"custom-error-types-in-async-code",children:"Custom error types in async code"}),"\n",(0,i.jsx)(r.p,{children:"Same as sync Rust."}),"\n",(0,i.jsxs)(r.p,{children:["Using ",(0,i.jsx)(r.code,{children:"thiserror"})]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'use thiserror::Error;\r\n\r\n#[derive(Error, Debug)]\r\nenum AppError {\r\n    #[error("IO error: {0}")]\r\n    Io(#[from] std::io::Error),\r\n\r\n    #[error("Invalid input")]\r\n    InvalidInput,\r\n}\n'})}),"\n",(0,i.jsx)(r.p,{children:"Async function using it"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'use tokio::fs;\r\n\r\nasync fn load_config() -> Result<String, AppError> {\r\n    let content = fs::read_to_string("config.toml").await?;\r\n    if content.is_empty() {\r\n        return Err(AppError::InvalidInput);\r\n    }\r\n    Ok(content)\r\n}\n'})}),"\n",(0,i.jsx)(r.h2,{id:"error-handling-with-spawned-tasks-very-important",children:"Error handling with spawned tasks (very important)"}),"\n",(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(r.code,{children:"JoinHandle"})," problem"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"let handle = tokio::spawn(async {\r\n    do_work().await\r\n});\n"})}),"\n",(0,i.jsx)(r.p,{children:"The type is:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"JoinHandle<Result<T, E>>\n"})}),"\n",(0,i.jsx)(r.p,{children:"So you get two layers of error."}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'async fn do_work() -> Result<(), &\'static str> {\r\n    Err("work failed")\r\n}\r\n\r\n#[tokio::main]\r\nasync fn main() {\r\n    let handle = tokio::spawn(do_work());\r\n\r\n    match handle.await {\r\n        Ok(Ok(())) => println!("success"),\r\n        Ok(Err(e)) => println!("task error: {e}"),\r\n        Err(e) => println!("task panicked: {e}"),\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"Err(JoinError)"})," \u2192 task panicked or was cancelled"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"Err(E)"})," \u2192 task ran but returned error"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"cancelling-tasks-and-errors",children:"Cancelling tasks and errors"}),"\n",(0,i.jsx)(r.p,{children:"Dropping a task handle cancels the task."}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'let handle = tokio::spawn(async {\r\n    loop {\r\n        println!("working...");\r\n        tokio::time::sleep(Duration::from_secs(1)).await;\r\n    }\r\n});\r\n\r\ndrop(handle); // task is cancelled\n'})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"No error is returned"}),"\n",(0,i.jsx)(r.li,{children:"Task simply stops"}),"\n",(0,i.jsxs)(r.li,{children:["Use ",(0,i.jsx)(r.code,{children:"select"}),"! if you need cleanup"]}),"\n"]}),"\n",(0,i.jsxs)(r.h2,{id:"error-handling-with-select",children:["Error handling with ",(0,i.jsx)(r.code,{children:"select!"})]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'use tokio::select;\r\n\r\nasync fn might_fail() -> Result<(), &\'static str> {\r\n    Err("oops")\r\n}\r\n\r\n#[tokio::main]\r\nasync fn main() {\r\n    let result = select! {\r\n        res = might_fail() => res,\r\n        _ = tokio::time::sleep(Duration::from_secs(1)) => Ok(()),\r\n    };\r\n\r\n    if let Err(e) = result {\r\n        println!("error: {e}");\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(r.p,{children:"Error propagation works naturally."}),"\n",(0,i.jsx)(r.h2,{id:"streams-and-error-handling",children:"Streams and error handling"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.code,{children:"Stream<Item = Result<T, E>>"})," pattern"]}),"\n",(0,i.jsx)(r.p,{children:"Very common."}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'use futures::StreamExt;\r\n\r\nwhile let Some(item) = stream.next().await {\r\n    match item {\r\n        Ok(value) => println!("value: {value}"),\r\n        Err(e) => {\r\n            println!("error: {e}");\r\n            break;\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(r.p,{children:"Alternative: fail-fast"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"let values: Result<Vec<_>, _> = stream.collect().await;\n"})}),"\n",(0,i.jsx)(r.h2,{id:"timeouts-and-errors",children:"Timeouts and errors"}),"\n",(0,i.jsx)(r.p,{children:"Timeouts convert slow futures into errors."}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'use tokio::time::{timeout, Duration};\r\n\r\nlet result = timeout(Duration::from_secs(1), async {\r\n    do_work().await\r\n}).await;\r\n\r\nmatch result {\r\n    Ok(Ok(())) => println!("success"),\r\n    Ok(Err(e)) => println!("task error: {e}"),\r\n    Err(_) => println!("timed out"),\r\n}\n'})}),"\n",(0,i.jsx)(r.h2,{id:"panic-vs-result-in-async",children:"Panic vs Result in async"}),"\n",(0,i.jsx)(r.p,{children:"Panics"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Kill the task"}),"\n",(0,i.jsx)(r.li,{children:"Do not kill the runtime"}),"\n",(0,i.jsxs)(r.li,{children:["Propagate as ",(0,i.jsx)(r.code,{children:"JoinError"})]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["Prefer ",(0,i.jsx)(r.code,{children:"Result"})," for:"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"IO failures"}),"\n",(0,i.jsx)(r.li,{children:"Business logic errors"}),"\n",(0,i.jsx)(r.li,{children:"Recoverable conditions"}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"common-async-error-handling-mistakes",children:"Common async error-handling mistakes"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["Ignoring ",(0,i.jsx)(r.code,{children:"JoinHandle"})]}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"tokio::spawn(do_work()); // error silently dropped\n"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["Using ",(0,i.jsx)(r.code,{children:"unwrap()"})," in async tasks: Panics get harder to trace."]}),"\n",(0,i.jsxs)(r.li,{children:["Mixing error types across layers: Use ",(0,i.jsx)(r.code,{children:"From"})," conversions or error enums."]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"mental-model",children:"Mental model"}),"\n",(0,i.jsx)(r.p,{children:"Think of async error handling as:"}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"\u201cSame rules, delayed delivery.\u201d"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"Errors:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Are values"}),"\n",(0,i.jsx)(r.li,{children:"Travel through futures"}),"\n",(0,i.jsxs)(r.li,{children:["Surface at ",(0,i.jsx)(r.code,{children:".await"})]}),"\n"]})]})}function h(n={}){const{wrapper:r}={...(0,l.R)(),...n.components};return r?(0,i.jsx)(r,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}}}]);