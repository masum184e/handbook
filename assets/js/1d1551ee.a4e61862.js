"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[34854],{28453(e,n,s){s.d(n,{R:()=>t,x:()=>c});var l=s(96540);const r={},i=l.createContext(r);function t(e){const n=l.useContext(i);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),l.createElement(i.Provider,{value:n},e.children)}},98506(e,n,s){s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>l,toc:()=>d});const l=JSON.parse('{"id":"rust/Copy vs Move","title":"Copy vs Move","description":"When you assign a value, pass it to a function, or return it, Rust must decide:","source":"@site/docs/rust/10. Copy vs Move.md","sourceDirName":"rust","slug":"/rust/Copy vs Move","permalink":"/handbook/docs/rust/Copy vs Move","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{}}');var r=s(74848),i=s(28453);const t={},c=void 0,o={},d=[{value:"Copy Semantics",id:"copy-semantics",level:2},{value:"Common <code>Copy</code> Types",id:"common-copy-types",level:2},{value:"Copy in Function Calls",id:"copy-in-function-calls",level:3},{value:"Move Semantics",id:"move-semantics",level:2},{value:"Move in Function Calls",id:"move-in-function-calls",level:2},{value:"Why Rust Defaults to Move",id:"why-rust-defaults-to-move",level:2},{value:"Clone vs Copy (Very Important)",id:"clone-vs-copy-very-important",level:2},{value:"Implementing Copy",id:"implementing-copy",level:2},{value:"References: Copy but Not Ownership",id:"references-copy-but-not-ownership",level:2},{value:"Partial Moves (Advanced but Useful)",id:"partial-moves-advanced-but-useful",level:2},{value:"Moves in Pattern Matching",id:"moves-in-pattern-matching",level:2},{value:"Copy vs Move Summary Table",id:"copy-vs-move-summary-table",level:2},{value:"Mental Model (This Sticks)",id:"mental-model-this-sticks",level:2},{value:"Why This Matters for Memory Safety",id:"why-this-matters-for-memory-safety",level:2}];function a(e){const n={blockquote:"blockquote",br:"br",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"When you assign a value, pass it to a function, or return it, Rust must decide:"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Do I copy the value, or do I move ownership?"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Rust answers this at compile time, based on the type."}),"\n",(0,r.jsx)(n.h2,{id:"copy-semantics",children:"Copy Semantics"}),"\n",(0,r.jsx)(n.p,{children:"A type is Copy if:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Its value can be duplicated bit-for-bit"}),"\n",(0,r.jsx)(n.li,{children:"Copying is cheap and safe"}),"\n",(0,r.jsx)(n.li,{children:"No heap memory needs to be managed"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"common-copy-types",children:["Common ",(0,r.jsx)(n.code,{children:"Copy"})," Types"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Integers: ",(0,r.jsx)(n.code,{children:"i32"}),", ",(0,r.jsx)(n.code,{children:"u64"})]}),"\n",(0,r.jsxs)(n.li,{children:["Floating point: ",(0,r.jsx)(n.code,{children:"f32"}),", ",(0,r.jsx)(n.code,{children:"f64"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"bool"}),", ",(0,r.jsx)(n.code,{children:"char"})]}),"\n",(0,r.jsxs)(n.li,{children:["Tuples of ",(0,r.jsx)(n.code,{children:"Copy"})," types"]}),"\n",(0,r.jsxs)(n.li,{children:["References (",(0,r.jsx)(n.code,{children:"&T"}),", ",(0,r.jsx)(n.code,{children:"&mut T"})," are Copy, not the data!)"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'fn main() {\r\n    let x = 5;\r\n    let y = x;\r\n\r\n    println!("{}", x); // \u2705 still valid\r\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"What happens in memory"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"x"})," lives on the stack"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"y"})," gets a full copy of the bits"]}),"\n",(0,r.jsx)(n.li,{children:"Both values are independent"}),"\n",(0,r.jsx)(n.li,{children:"No ownership transfer"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Think: photocopying a number"}),"\n",(0,r.jsx)(n.h3,{id:"copy-in-function-calls",children:"Copy in Function Calls"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'fn takes_i32(n: i32) {\r\n    println!("{}", n);\r\n}\r\n\r\nlet x = 10;\r\ntakes_i32(x);\r\nprintln!("{}", x); // \u2705 OK\n'})}),"\n",(0,r.jsx)(n.h2,{id:"move-semantics",children:"Move Semantics"}),"\n",(0,r.jsx)(n.p,{children:"A move happens when:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A value owns heap memory"}),"\n",(0,r.jsx)(n.li,{children:"Copying would risk double free"}),"\n",(0,r.jsx)(n.li,{children:"Ownership must be transferred"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"After a move:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The original variable is invalid"}),"\n",(0,r.jsx)(n.li,{children:"The new variable is the sole owner"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'fn main() {\r\n    let s1 = String::from("hello");\r\n    let s2 = s1;\r\n\r\n    println!("{}", s1); // \u274c compile-time error\r\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"What happens in memory"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'Stack before move:      Stack after move:\r\ns1 \u2500\u2510                   s2 \u2500\u2510\r\n    \u2514\u2500\u2192 Heap "hello"         \u2514\u2500\u2192 Heap "hello"\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Only the pointer is moved"}),"\n",(0,r.jsx)(n.li,{children:"Heap data is NOT copied"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"s1"})," is invalidated"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This prevents double free."}),"\n",(0,r.jsx)(n.h2,{id:"move-in-function-calls",children:"Move in Function Calls"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'fn takes_string(s: String) {\r\n    println!("{}", s);\r\n}\r\n\r\nlet s = String::from("hello");\r\ntakes_string(s);\r\nprintln!("{}", s); // \u274c error\n'})}),"\n",(0,r.jsx)(n.p,{children:"Ownership moves into the function."}),"\n",(0,r.jsx)(n.h2,{id:"why-rust-defaults-to-move",children:"Why Rust Defaults to Move"}),"\n",(0,r.jsx)(n.p,{children:"Imagine Rust copied heap data automatically:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let s1 = String::from("hello");\r\nlet s2 = s1; // deep copy?\n'})}),"\n",(0,r.jsx)(n.p,{children:"Problems:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Expensive"}),"\n",(0,r.jsx)(n.li,{children:"Unexpected performance cost"}),"\n",(0,r.jsx)(n.li,{children:"Double-free risk if shallow copy"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Rust chooses:"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Move by default, copy only when explicitly safe"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"clone-vs-copy-very-important",children:"Clone vs Copy (Very Important)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Copy"})," \u2013 implicit, cheap, automatic"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"let x = 5;\r\nlet y = x; // copy\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Clone"})," \u2013 explicit, potentially expensive"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let s1 = String::from("hello");\r\nlet s2 = s1.clone();\r\n\r\nprintln!("{}", s1); // \u2705 OK\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Allocates new heap memory"}),"\n",(0,r.jsx)(n.li,{children:"Copies the data"}),"\n",(0,r.jsx)(n.li,{children:"You must ask for it"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Rust makes you be explicit about cost."}),"\n",(0,r.jsx)(n.h2,{id:"implementing-copy",children:"Implementing Copy"}),"\n",(0,r.jsx)(n.p,{children:"A type can be Copy only if all its fields are Copy."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[derive(Copy, Clone)]\r\nstruct Point {\r\n    x: i32,\r\n    y: i32,\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let p1 = Point { x: 1, y: 2 };\r\nlet p2 = p1;\r\nprintln!("{}, {}", p1.x, p2.x); // \u2705\n'})}),"\n",(0,r.jsx)(n.p,{children:"But this is illegal:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"struct Bad {\r\n    s: String, // \u274c not Copy\r\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"references-copy-but-not-ownership",children:"References: Copy but Not Ownership"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let s = String::from("hello");\r\nlet r1 = &s;\r\nlet r2 = r1; // copy of reference\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"r1"})," and ",(0,r.jsx)(n.code,{children:"r2"})," both point to ",(0,r.jsx)(n.code,{children:"s"})]}),"\n",(0,r.jsx)(n.li,{children:"Ownership is unchanged"}),"\n",(0,r.jsx)(n.li,{children:"Borrowing rules still apply"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"partial-moves-advanced-but-useful",children:"Partial Moves (Advanced but Useful)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'struct User {\r\n    name: String,\r\n    age: u32,\r\n}\r\n\r\nlet user = User {\r\n    name: String::from("Alice"),\r\n    age: 30,\r\n};\r\n\r\nlet name = user.name; // move\r\nprintln!("{}", user.age); // \u2705 OK\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"name"})," moved"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"age"})," still accessible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"user"})," is partially invalid"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"moves-in-pattern-matching",children:"Moves in Pattern Matching"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let s = Some(String::from("hello"));\r\n\r\nmatch s {\r\n    Some(value) => println!("{}", value), // move\r\n    None => {}\r\n}\r\n\r\nprintln!("{:?}", s); // \u274c error\n'})}),"\n",(0,r.jsx)(n.p,{children:"Fix with borrowing:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'match &s {\r\n    Some(value) => println!("{}", value),\r\n    None => {}\r\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"copy-vs-move-summary-table",children:"Copy vs Move Summary Table"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Aspect"}),(0,r.jsx)(n.th,{children:"Copy"}),(0,r.jsx)(n.th,{children:"Move"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Implicit"}),(0,r.jsx)(n.td,{children:"\u2705"}),(0,r.jsx)(n.td,{children:"\u2705"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Heap-safe"}),(0,r.jsx)(n.td,{children:"\u274c"}),(0,r.jsx)(n.td,{children:"\u2705"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Performance cost"}),(0,r.jsx)(n.td,{children:"Tiny"}),(0,r.jsx)(n.td,{children:"Tiny"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Heap allocation"}),(0,r.jsx)(n.td,{children:"\u274c"}),(0,r.jsx)(n.td,{children:"\u274c"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Ownership transfer"}),(0,r.jsx)(n.td,{children:"\u274c"}),(0,r.jsx)(n.td,{children:"\u2705"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Original usable"}),(0,r.jsx)(n.td,{children:"\u2705"}),(0,r.jsx)(n.td,{children:"\u274c"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"mental-model-this-sticks",children:"Mental Model (This Sticks)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Copy = duplicate bits"}),"\n",(0,r.jsx)(n.li,{children:"Move = transfer responsibility"}),"\n",(0,r.jsx)(n.li,{children:"Clone = deep copy (explicit)"}),"\n",(0,r.jsx)(n.li,{children:"Ownership = who frees the heap"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Rust doesn\u2019t guess.",(0,r.jsx)(n.br,{}),"\n","If it\u2019s expensive or dangerous, you must say so."]}),"\n",(0,r.jsx)(n.h2,{id:"why-this-matters-for-memory-safety",children:"Why This Matters for Memory Safety"}),"\n",(0,r.jsx)(n.p,{children:"Without move semantics:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Double free bugs"}),"\n",(0,r.jsx)(n.li,{children:"Use-after-free"}),"\n",(0,r.jsx)(n.li,{children:"Hidden performance costs"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Rust prevents all of these at compile time."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}}}]);