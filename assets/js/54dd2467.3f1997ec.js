"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[72515],{28453(e,r,n){n.d(r,{R:()=>t,x:()=>a});var s=n(96540);const i={},l=s.createContext(i);function t(e){const r=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),s.createElement(l.Provider,{value:r},e.children)}},34916(e,r,n){n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>a,default:()=>o,frontMatter:()=>t,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"rust/Data Structure/Arrays","title":"Arrays","description":"An array in Rust is a fixed-size collection of elements of the same type, stored contiguously in memory.","source":"@site/docs/rust/11. Data Structure/2. Arrays.md","sourceDirName":"rust/11. Data Structure","slug":"/rust/Data Structure/Arrays","permalink":"/handbook/docs/rust/Data Structure/Arrays","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{}}');var i=n(74848),l=n(28453);const t={},a=void 0,c={},d=[{value:"Type of an Array",id:"type-of-an-array",level:2},{value:"Key Characteristics of Arrays",id:"key-characteristics-of-arrays",level:2},{value:"Creating Arrays",id:"creating-arrays",level:2},{value:"Accessing Array Elements",id:"accessing-array-elements",level:2},{value:"Iterating Over Arrays",id:"iterating-over-arrays",level:2},{value:"Array Slices (&amp;[T])",id:"array-slices-t",level:2},{value:"Arrays vs Vectors (Very Important)",id:"arrays-vs-vectors-very-important",level:2},{value:"Passing Arrays to Functions",id:"passing-arrays-to-functions",level:2},{value:"Multidimensional Arrays",id:"multidimensional-arrays",level:2},{value:"Memory Safety Highlights",id:"memory-safety-highlights",level:2}];function h(e){const r={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.p,{children:"An array in Rust is a fixed-size collection of elements of the same type, stored contiguously in memory."}),"\n",(0,i.jsx)(r.p,{children:"Rust arrays are simple, fast, and safe, but not growable."}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"let arr = [1, 2, 3, 4, 5];\n"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"All elements must be the same type"}),"\n",(0,i.jsx)(r.li,{children:"Length is known at compile time"}),"\n",(0,i.jsx)(r.li,{children:"Stored on the stack (by default)"}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"type-of-an-array",children:"Type of an Array"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"let arr: [i32; 5] = [1, 2, 3, 4, 5];\n"})}),"\n",(0,i.jsx)(r.p,{children:"Syntax:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"[element_type; number_of_elements]\n"})}),"\n",(0,i.jsx)(r.h2,{id:"key-characteristics-of-arrays",children:"Key Characteristics of Arrays"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Feature"}),(0,i.jsx)(r.th,{children:"Arrays"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Size"}),(0,i.jsx)(r.td,{children:"Fixed"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Memory"}),(0,i.jsx)(r.td,{children:"Contiguous"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Grow/Shrink"}),(0,i.jsx)(r.td,{children:"\u274c No"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Indexing"}),(0,i.jsx)(r.td,{children:"O(1)"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Safety"}),(0,i.jsx)(r.td,{children:"Bounds-checked"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Mutability"}),(0,i.jsx)(r.td,{children:"Optional"})]})]})]}),"\n",(0,i.jsx)(r.h2,{id:"creating-arrays",children:"Creating Arrays"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["Standard Initialization: ",(0,i.jsx)(r.code,{children:"let numbers = [10, 20, 30, 40];"})]}),"\n",(0,i.jsxs)(r.li,{children:["Initialize with Same Value: ",(0,i.jsx)(r.code,{children:"let zeros = [0; 5];"})," Creates: ",(0,i.jsx)(r.code,{children:"[0, 0, 0, 0, 0]"})]}),"\n",(0,i.jsxs)(r.li,{children:["Mutable Array: ",(0,i.jsx)(r.code,{children:"let mut scores = [50, 60, 70];scores[1] = 85;"})]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"accessing-array-elements",children:"Accessing Array Elements"}),"\n",(0,i.jsx)(r.p,{children:"Using Index"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'let arr = [1, 2, 3];\r\n\r\nprintln!("{}", arr[0]); // 1\n'})}),"\n",(0,i.jsx)(r.p,{children:"Out-of-Bounds Access (Runtime Panic)"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"let arr = [1, 2, 3];\r\nlet x = arr[10]; // \u274c panic\n"})}),"\n",(0,i.jsx)(r.p,{children:"Rust performs runtime bounds checking to ensure safety."}),"\n",(0,i.jsx)(r.p,{children:"Safe Access Using .get()"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'let arr = [1, 2, 3];\r\n\r\nmatch arr.get(10) {\r\n    Some(value) => println!("{}", value),\r\n    None => println!("Index out of bounds"),\r\n}\n'})}),"\n",(0,i.jsx)(r.h2,{id:"iterating-over-arrays",children:"Iterating Over Arrays"}),"\n",(0,i.jsx)(r.p,{children:"Using for Loop (Recommended)"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'let arr = [10, 20, 30];\r\n\r\nfor value in arr {\r\n    println!("{}", value);\r\n}\n'})}),"\n",(0,i.jsxs)(r.p,{children:["\ud83d\udccc This works because arrays implement ",(0,i.jsx)(r.code,{children:"Copy"})," for small types."]}),"\n",(0,i.jsx)(r.p,{children:"Using Index-Based Loop"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'let arr = [10, 20, 30];\r\n\r\nfor i in 0..arr.len() {\r\n    println!("Index {} = {}", i, arr[i]);\r\n}\n'})}),"\n",(0,i.jsx)(r.p,{children:"Using Iterator Methods"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'let arr = [1, 2, 3, 4];\r\n\r\nfor value in arr.iter() {\r\n    println!("{}", value);\r\n}\n'})}),"\n",(0,i.jsx)(r.h2,{id:"array-slices-t",children:"Array Slices (&[T])"}),"\n",(0,i.jsx)(r.p,{children:"A slice is a reference to part (or all) of an array."}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"let arr = [1, 2, 3, 4, 5];\r\nlet slice = &arr[1..4];\n"})}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.code,{children:"slice"})," type: ",(0,i.jsx)(r.code,{children:"&[i32]"})]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Slice Properties"})}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Feature"}),(0,i.jsx)(r.th,{children:"Slice"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Ownership"}),(0,i.jsx)(r.td,{children:"\u274c No"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Size"}),(0,i.jsx)(r.td,{children:"Dynamic"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Mutability"}),(0,i.jsx)(r.td,{children:"Depends"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Memory"}),(0,i.jsx)(r.td,{children:"Borrowed"})]})]})]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Mutable Slice"})}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"let mut arr = [1, 2, 3, 4];\r\nlet slice = &mut arr[1..3];\r\n\r\nslice[0] = 20;\n"})}),"\n",(0,i.jsxs)(r.p,{children:["Array becomes: ",(0,i.jsx)(r.code,{children:"[1, 20, 3, 4]"})]}),"\n",(0,i.jsx)(r.h2,{id:"arrays-vs-vectors-very-important",children:"Arrays vs Vectors (Very Important)"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Feature"}),(0,i.jsx)(r.th,{children:"Array"}),(0,i.jsxs)(r.th,{children:["Vector (",(0,i.jsx)(r.code,{children:"Vec<T>"}),")"]})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Size"}),(0,i.jsx)(r.td,{children:"Fixed"}),(0,i.jsx)(r.td,{children:"Dynamic"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Memory"}),(0,i.jsx)(r.td,{children:"Stack"}),(0,i.jsx)(r.td,{children:"Heap"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Resize"}),(0,i.jsx)(r.td,{children:"\u274c"}),(0,i.jsx)(r.td,{children:"\u2705"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Use case"}),(0,i.jsx)(r.td,{children:"Known-size data"}),(0,i.jsx)(r.td,{children:"Flexible collections"})]})]})]}),"\n",(0,i.jsx)(r.p,{children:"Use arrays when:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Size is fixed"}),"\n",(0,i.jsx)(r.li,{children:"Performance is critical"}),"\n",(0,i.jsx)(r.li,{children:"Data is small"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"Use vectors when:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Size may change"}),"\n",(0,i.jsx)(r.li,{children:"Input comes from users/files"}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"passing-arrays-to-functions",children:"Passing Arrays to Functions"}),"\n",(0,i.jsx)(r.p,{children:"Passing by Reference (Best Practice)"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'fn print_array(arr: &[i32]) {\r\n    for x in arr {\r\n        println!("{}", x);\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(r.p,{children:"Usage:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"let numbers = [1, 2, 3];\r\nprint_array(&numbers);\n"})}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.code,{children:"&[i32]"})," works for: Arrays, Slices, Vectors"]}),"\n",(0,i.jsx)(r.p,{children:"Passing Fixed-Size Array"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"fn sum(arr: [i32; 3]) -> i32 {\r\n    arr.iter().sum()\r\n}\n"})}),"\n",(0,i.jsx)(r.p,{children:"Less flexible (size must match exactly)."}),"\n",(0,i.jsx)(r.h2,{id:"multidimensional-arrays",children:"Multidimensional Arrays"}),"\n",(0,i.jsx)(r.p,{children:"2D Array Example"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"let matrix = [\r\n    [1, 2, 3],\r\n    [4, 5, 6],\r\n];\n"})}),"\n",(0,i.jsxs)(r.p,{children:["Access Elements: ",(0,i.jsx)(r.code,{children:'println!("{}", matrix[1][2]); // 6'})]}),"\n",(0,i.jsx)(r.p,{children:"Iterating 2D Arrays"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'for row in matrix {\r\n    for val in row {\r\n        print!("{} ", val);\r\n    }\r\n    println!();\r\n}\n'})}),"\n",(0,i.jsx)(r.h2,{id:"memory-safety-highlights",children:"Memory Safety Highlights"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Fixed size prevents unexpected reallocations"}),"\n",(0,i.jsx)(r.li,{children:"Bounds checking prevents buffer overflows"}),"\n",(0,i.jsx)(r.li,{children:"Ownership rules prevent data races"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"Rust arrays are low-level but safe."})]})}function o(e={}){const{wrapper:r}={...(0,l.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);