"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[11441],{28453(e,n,i){i.d(n,{R:()=>a,x:()=>c});var r=i(96540);const s={},l=r.createContext(s);function a(e){const n=r.useContext(l);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(l.Provider,{value:n},e.children)}},65477(e,n,i){i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>t});const r=JSON.parse('{"id":"javascript/Variables","title":"Variables","description":"Variable Environments","source":"@site/docs/javascript/6. Variables.md","sourceDirName":"javascript","slug":"/javascript/Variables","permalink":"/handbook/docs/javascript/Variables","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"javascriptSidebar","previous":{"title":"Data Types","permalink":"/handbook/docs/javascript/Data Types"},"next":{"title":"Modules","permalink":"/handbook/docs/javascript/Modules"}}');var s=i(74848),l=i(28453);const a={sidebar_position:7},c=void 0,o={},t=[{value:"Variable Environments",id:"variable-environments",level:2},{value:"Components of Variable Environment",id:"components-of-variable-environment",level:3},{value:"Variable Environment vs Lexical Environment",id:"variable-environment-vs-lexical-environment",level:3},{value:"Variable Declaration",id:"variable-declaration",level:2},{value:"Automatic Global Variable",id:"automatic-global-variable",level:2}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"variable-environments",children:"Variable Environments"}),"\n",(0,s.jsx)(n.p,{children:"In JavaScript, every execution context (like global code, a function, or a block) has an associated Variable Environment."}),"\n",(0,s.jsx)(n.p,{children:"A Variable Environment is a special internal object where all the variables and function declarations of that context are stored."}),"\n",(0,s.jsx)(n.p,{children:"When JavaScript code runs:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"The Execution Context is created."}),"\n",(0,s.jsxs)(n.li,{children:["Inside it, the Variable Environment is created to keep track of variables defined with ",(0,s.jsx)(n.code,{children:"var"}),", ",(0,s.jsx)(n.code,{children:"let"}),", and ",(0,s.jsx)(n.code,{children:"const"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"This environment helps JavaScript engines know where and how to find variables during execution."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"components-of-variable-environment",children:"Components of Variable Environment"}),"\n",(0,s.jsx)(n.p,{children:"The Variable Environment is closely related to Lexical Environments. Both together form the scope chain."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Variable Declarations (var, let, const)"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Stored differently:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"`var \u2192 Stored in Variable Environment (function-scoped)."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"let & "}),"const` \u2192 Stored in Lexical Environment (block-scoped), but conceptually part of execution context too."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"Function Declarations"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Stored in Variable Environment and hoisted."}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"Scope Chain"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Variable Environment links to its outer environment reference, allowing inner functions to access variables from outer scopes (closures)."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"variable-environment-vs-lexical-environment",children:"Variable Environment vs Lexical Environment"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Variable Environment:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Holds variables declared with var (function-scoped)."}),"\n",(0,s.jsx)(n.li,{children:"Created when execution context is created."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Lexical Environment:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Holds let and const (block-scoped)."}),"\n",(0,s.jsx)(n.li,{children:"Depends on where code is written (lexical scope)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"\ud83d\udccc But in modern JS discussions, people often use Lexical Environment as a more general term. The Variable Environment is just a specific part of it."}),"\n",(0,s.jsx)(n.h2,{id:"variable-declaration",children:"Variable Declaration"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"var"})," maintain function scope (",(0,s.jsx)(n.strong,{children:"not global scope"}),"), ",(0,s.jsx)(n.code,{children:"let"}),", ",(0,s.jsx)(n.code,{children:"const"})," maintain block scope."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Updating/re-assigning ",(0,s.jsx)(n.code,{children:"const"})," variable create ",(0,s.jsx)(n.code,{children:"TypeError: Assignment to constant variable."})," error."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"var"})," maintain function scope, ",(0,s.jsx)(n.code,{children:"let"}),", ",(0,s.jsx)(n.code,{children:"const"})," maintain block scope."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Updating/re-assigning ",(0,s.jsx)(n.code,{children:"const"})," variable create ",(0,s.jsx)(n.code,{children:"TypeError: Assignment to constant variable."})," error."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const a = "hello";\r\na = "hi";\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"It creates a constant reference to a value. if the value is an object or array, you can mutate its contents (because the reference stays the same)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const x = 10;\r\nx = 20; // \u274c Error: Assignment to constant variable\r\n\r\nconst arr = [1, 2, 3];\r\narr.push(4); // \u2705 Allowed\r\narr = [5, 6]; // \u274c Error\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Primitive ",(0,s.jsx)(n.code,{children:"const"}),", ",(0,s.jsx)(n.code,{children:"let"}),", ",(0,s.jsx)(n.code,{children:"var"})," store in stack, Non-primitive store in stack."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["A variable with same name can be declare twice with ",(0,s.jsx)(n.code,{children:"var"})," but not with ",(0,s.jsx)(n.code,{children:"let"})," and ",(0,s.jsx)(n.code,{children:"const"}),", it will create ",(0,s.jsx)(n.code,{children:"SyntaxError: Identifier 'a' has already been declared"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"It creates a constant reference to a value. if the value is an object or array, you can mutate its contents (because the reference stays the same)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const x = 10;\r\nx = 20; // \u274c Error: Assignment to constant variable\r\n\r\nconst arr = [1, 2, 3];\r\narr.push(4); // \u2705 Allowed\r\narr = [5, 6]; // \u274c Error\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Primitive ",(0,s.jsx)(n.code,{children:"const"}),", ",(0,s.jsx)(n.code,{children:"let"}),", ",(0,s.jsx)(n.code,{children:"var"})," store in stack, Non-primitive store in stack."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["A variable with same name can be declare twice with ",(0,s.jsx)(n.code,{children:"var"})," but not with ",(0,s.jsx)(n.code,{children:"let"})," and ",(0,s.jsx)(n.code,{children:"const"}),", it will create ",(0,s.jsx)(n.code,{children:"SyntaxError: Identifier 'a' has already been declared"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JS",children:'let a=\'hello\'; // ERROR\r\nlet a="hi"; // ERROR\r\n\r\nvar b="hello";\r\nvar b="hello";\n'})}),"\n",(0,s.jsxs)(n.p,{children:["a variable with same name can be declare twice with ",(0,s.jsx)(n.code,{children:"let"})," if both are in different scope, this is not applicable for ",(0,s.jsx)(n.code,{children:"const"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let a = 5;\r\nconsole.log(a);\r\n{\r\n  let a = 4;\r\n  console.log(a);\r\n}\r\nconsole.log(a);\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"var"})," maintain function/global scope, ",(0,s.jsx)(n.code,{children:"let"})," and ",(0,s.jsx)(n.code,{children:"const"})," maintain local scope."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Using any variable before declaration with ",(0,s.jsx)(n.code,{children:"var"})," return ",(0,s.jsx)(n.code,{children:"undefined"})," due to hoisting but with ",(0,s.jsx)(n.code,{children:"let"})," and ",(0,s.jsx)(n.code,{children:"const"})," it will return an error of ",(0,s.jsx)(n.code,{children:"ReferenceError: Cannot access 'myVariable' before initialization"})," due to temporal deadzone."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'console.log(myVariable);\r\nlet myVariable = "Hello";\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"ReferenceError"}),": Occurs when a variable that isn\u2019t declared or isn\u2019t accessible is referenced. This often happens due to misspellings, accessing variables in the temporal dead zone, or outside their scope."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"SyntaxError"}),": Occurs when code does not conform to the correct syntax of the language. This type of error is detected before the code is executed and typically involves missing or incorrect syntax elements."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"TypeError"}),": Occurs when a value is not of the expected type, such as calling a non-function as a function, or accessing properties on ",(0,s.jsx)(n.code,{children:"null"})," or ",(0,s.jsx)(n.code,{children:"undefined"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Explaination:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let i = 50;\r\nfor (let i = 0; i < 5; i++) {\r\n  console.log(i);\r\n}\r\nconsole.log(i);\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["memory allocate for initial ",(0,s.jsx)(n.code,{children:"i"})," in script object with global scope"]}),"\n",(0,s.jsxs)(n.li,{children:["memory allocate for last ",(0,s.jsx)(n.code,{children:"i"})," in script object with local scope"]}),"\n",(0,s.jsxs)(n.li,{children:["memory allocate for initial ",(0,s.jsx)(n.code,{children:"i"})," in script object with global scope"]}),"\n",(0,s.jsxs)(n.li,{children:["memory allocate for last ",(0,s.jsx)(n.code,{children:"i"})," in script object with local scope"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"automatic-global-variable",children:"Automatic Global Variable"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["We can declare variable without ",(0,s.jsx)(n.code,{children:"var"}),", in that case it will be consider as global variable."]}),"\n",(0,s.jsx)(n.li,{children:"Scope is determine in creation phase, but undeclared variable executed at exection phase, that's how it became global variable"}),"\n",(0,s.jsx)(n.li,{children:"this will not in strict mode"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const show = () => {\r\n  name = "Masum Billah";\r\n};\r\nshow();\r\nconsole.log(name);\r\n{\r\n  age = 25;\r\n}\r\nconsole.log(age);\r\n## Automatic Global Variable\r\n\r\n- We can declare variable without `var`, in that case it will be consider as global variable.\r\n- Scope is determine in creation phase, but undeclared variable executed at exection phase, that\'s how it became global variable\r\n- this will not in strict mode\r\n\r\n```javascript\r\nconst show = () => {\r\n  name = "Masum Billah";\r\n};\r\nshow();\r\nconsole.log(name);\r\n{\r\n  age = 25;\r\n}\r\nconsole.log(age);\n'})})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);