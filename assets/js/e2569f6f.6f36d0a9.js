"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[40862],{28453(e,n,r){r.d(n,{R:()=>a,x:()=>l});var t=r(96540);const i={},s=t.createContext(i);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:n},e.children)}},57020(e,n,r){r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"rust/Macros/Attribute Macros","title":"Attribute Macros","description":"An attribute macro is a procedural macro used like this:","source":"@site/docs/rust/Macros/4. Attribute Macros.md","sourceDirName":"rust/Macros","slug":"/rust/Macros/Attribute Macros","permalink":"/handbook/docs/rust/Macros/Attribute Macros","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"rustApiSidebar","previous":{"title":"Custom Derive Macro","permalink":"/handbook/docs/rust/Macros/Custom Derive Macro"},"next":{"title":"REST API","permalink":"/handbook/docs/rust/Web Application/REST API"}}');var i=r(74848),s=r(28453);const a={},l=void 0,o={},c=[{value:"When to Use Attribute Macros",id:"when-to-use-attribute-macros",level:2},{value:"Attribute Macros vs Custom Derives",id:"attribute-macros-vs-custom-derives",level:2},{value:"How Attribute Macros Work",id:"how-attribute-macros-work",level:2},{value:"Setting Up an Attribute Macro Crate",id:"setting-up-an-attribute-macro-crate",level:2},{value:"Example 1: Simple Logging Attribute for Functions",id:"example-1-simple-logging-attribute-for-functions",level:2},{value:"Example 2: Attribute Macro With Arguments",id:"example-2-attribute-macro-with-arguments",level:2},{value:"Example 3: Attribute Macro on Structs",id:"example-3-attribute-macro-on-structs",level:2},{value:"Hygiene and Name Resolution",id:"hygiene-and-name-resolution",level:2},{value:"Error Handling in Attribute Macros",id:"error-handling-in-attribute-macros",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"An attribute macro is a procedural macro used like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[my_attribute]\r\nfn my_function() { ... }\n"})}),"\n",(0,i.jsx)(n.p,{children:"or with arguments:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'#[my_attribute(key = "value")]\r\nfn my_function() { ... }\n'})}),"\n",(0,i.jsx)(n.p,{children:"It:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Receives the annotated item as input."}),"\n",(0,i.jsx)(n.li,{children:"Optionally receives arguments from the attribute."}),"\n",(0,i.jsx)(n.li,{children:"Returns transformed Rust code that replaces the original item."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use-attribute-macros",children:"When to Use Attribute Macros"}),"\n",(0,i.jsx)(n.p,{children:"Use them when you want to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Modify function behavior (logging, timing, retries, async setup)."}),"\n",(0,i.jsx)(n.li,{children:"Add validation or instrumentation."}),"\n",(0,i.jsx)(n.li,{children:"Generate extra code around structs, modules, or impl blocks."}),"\n",(0,i.jsxs)(n.li,{children:["Create ergonomic APIs (e.g., ",(0,i.jsx)(n.code,{children:"#[tokio::main]"}),", ",(0,i.jsx)(n.code,{children:"#[test]"}),", ",(0,i.jsx)(n.code,{children:"#[wasm_bindgen]"}),")."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"attribute-macros-vs-custom-derives",children:"Attribute Macros vs Custom Derives"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Feature"}),(0,i.jsx)(n.th,{children:"Attribute Macro"}),(0,i.jsx)(n.th,{children:"Custom Derive"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Syntax"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"#[my_attr]"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"#[derive(MyTrait)]"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Applies to"}),(0,i.jsx)(n.td,{children:"Any item"}),(0,i.jsx)(n.td,{children:"Structs/enums/unions"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Can modify original item"}),(0,i.jsx)(n.td,{children:"\u2705 Yes"}),(0,i.jsx)(n.td,{children:"\u274c No (only adds code)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Receives arguments"}),(0,i.jsx)(n.td,{children:"\u2705 Yes"}),(0,i.jsx)(n.td,{children:"\u274c No"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"how-attribute-macros-work",children:"How Attribute Macros Work"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Compiler encounters #[my_attr(...)]."}),"\n",(0,i.jsxs)(n.li,{children:["It passes:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The attribute arguments as a TokenStream."}),"\n",(0,i.jsx)(n.li,{children:"The annotated item as another TokenStream."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Your macro:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Parses both."}),"\n",(0,i.jsx)(n.li,{children:"Generates new code."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"The new code replaces the original item."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"setting-up-an-attribute-macro-crate",children:"Setting Up an Attribute Macro Crate"}),"\n",(0,i.jsxs)(n.p,{children:["Procedural macros must live in a ",(0,i.jsx)(n.code,{children:"proc-macro"})," crate."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"cargo new my_attr_macros --lib\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Cargo.toml"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-toml",children:'[lib]\r\nproc-macro = true\r\n\r\n[dependencies]\r\nsyn = "2"\r\nquote = "1"\r\nproc-macro2 = "1"\n'})}),"\n",(0,i.jsx)(n.h2,{id:"example-1-simple-logging-attribute-for-functions",children:"Example 1: Simple Logging Attribute for Functions"}),"\n",(0,i.jsxs)(n.p,{children:["We\u2019ll write ",(0,i.jsx)(n.code,{children:"#[log_calls]"})," to log entry and exit of a function."]}),"\n",(0,i.jsx)(n.p,{children:"Macro Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use proc_macro::TokenStream;\r\nuse quote::quote;\r\nuse syn::{parse_macro_input, ItemFn};\r\n\r\n#[proc_macro_attribute]\r\npub fn log_calls(_attr: TokenStream, item: TokenStream) -> TokenStream {\r\n    // Parse the input as a function\r\n    let input = parse_macro_input!(item as ItemFn);\r\n\r\n    let vis = &input.vis;\r\n    let sig = &input.sig;\r\n    let block = &input.block;\r\n    let name = &sig.ident;\r\n\r\n    let expanded = quote! {\r\n        #vis #sig {\r\n            println!("Entering {}", stringify!(#name));\r\n            let result = (|| #block)();\r\n            println!("Exiting {}", stringify!(#name));\r\n            result\r\n        }\r\n    };\r\n\r\n    TokenStream::from(expanded)\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use my_attr_macros::log_calls;\r\n\r\n#[log_calls]\r\nfn add(a: i32, b: i32) -> i32 {\r\n    a + b\r\n}\r\n\r\nfn main() {\r\n    let x = add(2, 3);\r\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"What Gets Generated"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'fn add(a: i32, b: i32) -> i32 {\r\n    println!("Entering add");\r\n    let result = (|| { a + b })();\r\n    println!("Exiting add");\r\n    result\r\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This preserves return values, early returns, and ",(0,i.jsx)(n.code,{children:"?"})," behavior."]}),"\n",(0,i.jsx)(n.h2,{id:"example-2-attribute-macro-with-arguments",children:"Example 2: Attribute Macro With Arguments"}),"\n",(0,i.jsx)(n.p,{children:"Let\u2019s create:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'#[route(method = "GET", path = "/users")]\r\nfn get_users() { ... }\n'})}),"\n",(0,i.jsx)(n.p,{children:"Macro Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use proc_macro::TokenStream;\r\nuse quote::quote;\r\nuse syn::{parse_macro_input, ItemFn, Meta, NestedMeta, Lit};\r\n\r\n#[proc_macro_attribute]\r\npub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {\r\n    let input = parse_macro_input!(item as ItemFn);\r\n\r\n    let mut method = None;\r\n    let mut path = None;\r\n\r\n    let meta = parse_macro_input!(attr as syn::AttributeArgs);\r\n    for arg in meta {\r\n        if let NestedMeta::Meta(Meta::NameValue(nv)) = arg {\r\n            if nv.path.is_ident("method") {\r\n                if let Lit::Str(lit) = nv.lit {\r\n                    method = Some(lit.value());\r\n                }\r\n            }\r\n            if nv.path.is_ident("path") {\r\n                if let Lit::Str(lit) = nv.lit {\r\n                    path = Some(lit.value());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    let method = method.expect("Missing method");\r\n    let path = path.expect("Missing path");\r\n\r\n    let name = &input.sig.ident;\r\n    let vis = &input.vis;\r\n    let sig = &input.sig;\r\n    let block = &input.block;\r\n\r\n    let expanded = quote! {\r\n        // original function\r\n        #vis #sig #block\r\n\r\n        // generated metadata\r\n        fn #name##_route_info() {\r\n            println!("Route: {} {}", #method, #path);\r\n        }\r\n    };\r\n\r\n    TokenStream::from(expanded)\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use my_attr_macros::route;\r\n\r\n#[route(method = "GET", path = "/users")]\r\nfn get_users() {\r\n    println!("Fetching users");\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Conceptual Expansion"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'fn get_users() {\r\n    println!("Fetching users");\r\n}\r\n\r\nfn get_users_route_info() {\r\n    println!("Route: GET /users");\r\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"example-3-attribute-macro-on-structs",children:"Example 3: Attribute Macro on Structs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[auto_new]\r\nstruct Point {\r\n    x: i32,\r\n    y: i32,\r\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Generate a constructor:"}),"\n",(0,i.jsx)(n.p,{children:"Macro Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use proc_macro::TokenStream;\r\nuse quote::quote;\r\nuse syn::{parse_macro_input, DeriveInput, Data, Fields};\r\n\r\n#[proc_macro_attribute]\r\npub fn auto_new(_attr: TokenStream, item: TokenStream) -> TokenStream {\r\n    let input = parse_macro_input!(item as DeriveInput);\r\n    let name = &input.ident;\r\n\r\n    let fields = match &input.data {\r\n        Data::Struct(data) => match &data.fields {\r\n            Fields::Named(fields) => &fields.named,\r\n            _ => panic!("auto_new only supports named fields"),\r\n        },\r\n        _ => panic!("auto_new only supports structs"),\r\n    };\r\n\r\n    let params = fields.iter().map(|f| {\r\n        let name = &f.ident;\r\n        let ty = &f.ty;\r\n        quote! { #name: #ty }\r\n    });\r\n\r\n    let inits = fields.iter().map(|f| {\r\n        let name = &f.ident;\r\n        quote! { #name }\r\n    });\r\n\r\n    let expanded = quote! {\r\n        #input\r\n\r\n        impl #name {\r\n            pub fn new(#(#params),*) -> Self {\r\n                Self { #(#inits),* }\r\n            }\r\n        }\r\n    };\r\n\r\n    TokenStream::from(expanded)\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[auto_new]\r\nstruct Point {\r\n    x: i32,\r\n    y: i32,\r\n}\r\n\r\nfn main() {\r\n    let p = Point::new(1, 2);\r\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Expansion"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"struct Point {\r\n    x: i32,\r\n    y: i32,\r\n}\r\n\r\nimpl Point {\r\n    pub fn new(x: i32, y: i32) -> Self {\r\n        Self { x, y }\r\n    }\r\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"hygiene-and-name-resolution",children:"Hygiene and Name Resolution"}),"\n",(0,i.jsx)(n.p,{children:"Attribute macros are hygienic:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"They won\u2019t accidentally capture local variables."}),"\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"stringify!"}),", fully qualified paths (",(0,i.jsx)(n.code,{children:"::std::println!"}),"), and careful naming."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"error-handling-in-attribute-macros",children:"Error Handling in Attribute Macros"}),"\n",(0,i.jsxs)(n.p,{children:["Use compile-time errors instead of ",(0,i.jsx)(n.code,{children:"panic!"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'return syn::Error::new_spanned(\r\n    input,\r\n    "This attribute only supports functions",\r\n)\r\n.to_compile_error()\r\n.into();\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Keep attribute macros focused and predictable."}),"\n",(0,i.jsx)(n.li,{children:"Provide clear compiler errors."}),"\n",(0,i.jsx)(n.li,{children:"Preserve user-written code as much as possible."}),"\n",(0,i.jsx)(n.li,{children:"Prefer derives for trait implementations and attributes for behavior modification."}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);