"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[74135],{28453(n,e,r){r.d(e,{R:()=>a,x:()=>s});var t=r(96540);const i={},o=t.createContext(i);function a(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),t.createElement(o.Provider,{value:e},n.children)}},65039(n,e,r){r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"nextjs/Internationlization","title":"Internationalization","description":"Next.js provides built-in i18n routing support, but you\u2019ll often combine it with either translation libraries (like next-intl or next-i18next) or custom dictionaries. With the App Router, you don\u2019t rely on _app.tsx anymore \u2014 instead, you structure translations around layouts, server components, and data fetching.","source":"@site/docs/nextjs/14. Internationlization.md","sourceDirName":"nextjs","slug":"/nextjs/Internationlization","permalink":"/handbook/docs/nextjs/Internationlization","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":16,"frontMatter":{"title":"Internationalization","sidebar_position":16},"sidebar":"nextjsSidebar","previous":{"title":"Deployment","permalink":"/handbook/docs/nextjs/Deployment"},"next":{"title":"Custom Server","permalink":"/handbook/docs/nextjs/Custom Server"}}');var i=r(74848),o=r(28453);const a={title:"Internationalization",sidebar_position:16},s=void 0,l={},c=[{value:"Configure i18n",id:"configure-i18n",level:2},{value:"Organize Translation Dictionaries",id:"organize-translation-dictionaries",level:2},{value:"Create a Translation Loader",id:"create-a-translation-loader",level:2},{value:"Define Locale-Specific Routes",id:"define-locale-specific-routes",level:2},{value:"Use Translations in Layout",id:"use-translations-in-layout",level:2},{value:"Example with Data Fetching",id:"example-with-data-fetching",level:2},{value:"How Internationalization Works",id:"how-internationalization-works",level:2}];function d(n){const e={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.p,{children:["Next.js provides built-in i18n routing support, but you\u2019ll often combine it with either translation libraries (like ",(0,i.jsx)(e.code,{children:"next-intl"})," or ",(0,i.jsx)(e.code,{children:"next-i18next"}),") or custom dictionaries. With the App Router, you don\u2019t rely on ",(0,i.jsx)(e.code,{children:"_app.tsx"})," anymore \u2014 instead, you structure translations around layouts, server components, and data fetching."]}),"\n",(0,i.jsx)(e.h2,{id:"configure-i18n",children:"Configure i18n"}),"\n",(0,i.jsx)(e.p,{children:"Next.js has built-in locale routing, so you declare your supported locales here:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-ts",children:'// next.config.ts\r\n/** @type {import(\'next\').NextConfig} */\r\nconst nextConfig = {\r\n  i18n: {\r\n    locales: ["en", "fr", "bn"], // English, French, Bangla\r\n    defaultLocale: "en",\r\n  },\r\n};\r\n\r\nmodule.exports = nextConfig;\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["This enables URLs like: ",(0,i.jsx)(e.code,{children:"/en/products"}),", ",(0,i.jsx)(e.code,{children:"/fr/products"}),", ",(0,i.jsx)(e.code,{children:"/bn/products"})]}),"\n",(0,i.jsxs)(e.li,{children:["The locale will be available on both the server and client via ",(0,i.jsx)(e.code,{children:"params"})," or ",(0,i.jsx)(e.code,{children:"useParams()"})]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"organize-translation-dictionaries",children:"Organize Translation Dictionaries"}),"\n",(0,i.jsx)(e.p,{children:"Instead of a library, we\u2019ll use simple JSON dictionaries for each language."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-json",children:'// messages/en.json\r\n{\r\n  "welcome": "Welcome to our store",\r\n  "products": "Products"\r\n}\r\n\r\n// messages/fr.json\r\n{\r\n  "welcome": "Bienvenue dans notre magasin",\r\n  "products": "Produits"\r\n}\r\n\r\n// messages/bn.json\r\n{\r\n  "welcome": "\u0986\u09ae\u09be\u09a6\u09c7\u09b0 \u09a6\u09cb\u0995\u09be\u09a8\u09c7 \u09b8\u09cd\u09ac\u09be\u0997\u09a4\u09ae",\r\n  "products": "\u09aa\u09a3\u09cd\u09af\u09b8\u09ae\u09c2\u09b9"\r\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"create-a-translation-loader",children:"Create a Translation Loader"}),"\n",(0,i.jsx)(e.p,{children:"We\u2019ll load dictionary files dynamically based on the locale."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-ts",children:'// lib/get-dictionary.ts\r\nexport type Locale = "en" | "fr" | "bn";\r\n\r\nexport async function getDictionary(locale: Locale) {\r\n  const dictionaries = {\r\n    en: () => import("../messages/en.json").then((m) => m.default),\r\n    fr: () => import("../messages/fr.json").then((m) => m.default),\r\n    bn: () => import("../messages/bn.json").then((m) => m.default),\r\n  };\r\n\r\n  return dictionaries[locale]?.() ?? dictionaries.en();\r\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"define-locale-specific-routes",children:"Define Locale-Specific Routes"}),"\n",(0,i.jsxs)(e.p,{children:["With the App Router, you can scope everything under ",(0,i.jsx)(e.code,{children:"[locale]"}),"."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"app/\r\n \u251c\u2500 [locale]/\r\n \u2502   \u251c\u2500 layout.tsx\r\n \u2502   \u251c\u2500 page.tsx\r\n \u2502   \u2514\u2500 products/\r\n \u2502       \u2514\u2500 page.tsx\r\n \u2514\u2500 globals.css\n"})}),"\n",(0,i.jsx)(e.h2,{id:"use-translations-in-layout",children:"Use Translations in Layout"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-tsx",children:'// app/[locale]/layout.tsx\r\nimport { ReactNode } from "react";\r\nimport { getDictionary, Locale } from "@/utils/get-dictionary";\r\n\r\nexport async function generateStaticParams() {\r\n  return [{ locale: "en" }, { locale: "fr" }, { locale: "bn" }];\r\n}\r\n\r\nexport default async function LocaleLayout({\r\n  children,\r\n  params,\r\n}: {\r\n  children: ReactNode;\r\n  params: { locale: Locale };\r\n}) {\r\n  const { locale } = await params;\r\n  const dict = await getDictionary(locale);\r\n\r\n  return (\r\n    <html lang={locale}>\r\n      <body>\r\n        <header className="p-4 bg-gray-200">\r\n          <h1>{dict.welcome}</h1>\r\n        </header>\r\n        <main>{children}</main>\r\n      </body>\r\n    </html>\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"example-with-data-fetching",children:"Example with Data Fetching"}),"\n",(0,i.jsx)(e.p,{children:"Let\u2019s fetch product data and localize UI labels."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-tsx",children:'// app/[locale]/page.tsx\r\nimport { getDictionary, Locale } from "@/utils/get-dictionary";\r\n\r\ntype Product = {\r\n  id: number;\r\n  name: string;\r\n};\r\n\r\nasync function getProducts(): Promise<Product[]> {\r\n  // Example: server-side fetching (e.g., from an API or DB)\r\n  return [\r\n    { id: 1, name: "Laptop" },\r\n    { id: 2, name: "Phone" },\r\n  ];\r\n}\r\n\r\nexport default async function ProductsPage({\r\n  params,\r\n}: {\r\n  params: { locale: Locale };\r\n}) {\r\n  const { locale } = await params;\r\n  const dict = await getDictionary(locale);\r\n  const products = await getProducts();\r\n\r\n  return (\r\n    <section className="p-4">\r\n      <h2 className="text-xl font-bold">{dict.products}</h2>\r\n      <ul>\r\n        {products.map((p) => (\r\n          <li key={p.id}>{p.name}</li>\r\n        ))}\r\n      </ul>\r\n    </section>\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"how-internationalization-works",children:"How Internationalization Works"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Routing"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"/en/products"})," \u2192 loads English dictionary"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"/fr/products"})," \u2192 loads French dictionary"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"/bn/products"})," \u2192 loads Bangla dictionary"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Data Fetching"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"getProducts()"})," runs on the server."]}),"\n",(0,i.jsx)(e.li,{children:"Dictionary is also fetched on the server."}),"\n",(0,i.jsx)(e.li,{children:"Both are merged in the server component before rendering."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Scalability"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"You can fetch dictionaries from APIs instead of JSON files."}),"\n",(0,i.jsxs)(e.li,{children:["You can add middleware to redirect users based on ",(0,i.jsx)(e.code,{children:"Accept-Language"})," header."]}),"\n"]}),"\n"]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}}}]);