"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[4447],{28453(e,n,i){i.d(n,{R:()=>a,x:()=>o});var s=i(96540);const r={},t=s.createContext(r);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(t.Provider,{value:n},e.children)}},62607(e,n,i){i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"prisma/Transaction","title":"Transaction","description":"Atomic Operations","source":"@site/docs/prisma/8. Transaction.md","sourceDirName":"prisma","slug":"/prisma/Transaction","permalink":"/handbook/docs/prisma/Transaction","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"prismaApiSidebar","previous":{"title":"Middleware","permalink":"/handbook/docs/prisma/Middleware"},"next":{"title":"Connection Pooling","permalink":"/handbook/docs/prisma/Connection Pooling"}}');var r=i(74848),t=i(28453);const a={sidebar_position:8},o=void 0,c={},l=[{value:"Atomic Operations",id:"atomic-operations",level:2},{value:"Why use Atomic Operations?",id:"why-use-atomic-operations",level:3},{value:"Common Atomic Operations",id:"common-atomic-operations",level:3},{value:"Incrementing a counter safely",id:"incrementing-a-counter-safely",level:3},{value:"Batch Operations",id:"batch-operations",level:3},{value:"Interactive transactions",id:"interactive-transactions",level:2}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"atomic-operations",children:"Atomic Operations"}),"\n",(0,r.jsx)(n.p,{children:"Atomic operations in Prisma refer to operations that are executed as a single, indivisible action inside the database. This means either the whole operation succeeds, or it fails without partially applying changes."}),"\n",(0,r.jsx)(n.p,{children:"They are particularly useful when you want to update a field relative to its current value (like increment, decrement, multiply, divide, push, etc.) instead of overwriting it manually."}),"\n",(0,r.jsx)(n.p,{children:"Atomic operations ensure that these updates are safe even under concurrent database access (no race conditions)."}),"\n",(0,r.jsx)(n.h3,{id:"why-use-atomic-operations",children:"Why use Atomic Operations?"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Prevent race conditions:"})," Two users incrementing a likes counter at the same time won\u2019t overwrite each other\u2019s update."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cleaner & safer code:"})," You don\u2019t have to read \u2192 modify \u2192 write, Prisma does it in one atomic step."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance:"})," Saves extra queries because the modification happens directly in the database."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"common-atomic-operations",children:"Common Atomic Operations"}),"\n",(0,r.jsxs)(n.p,{children:["These are used mostly in ",(0,r.jsx)(n.code,{children:"update"})," and ",(0,r.jsx)(n.code,{children:"updateMany"})," queries:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"increment"})," \u2192 Adds a value to a number field"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"decrement"})," \u2192 Subtracts a value from a number field"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"multiply"})," \u2192 Multiplies a number field"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"divide"})," \u2192 Divides a number field"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"set"})," \u2192 Sets the value directly"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"push"})," \u2192 Appends values to an array field (PostgreSQL, MongoDB, etc.)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"incrementing-a-counter-safely",children:"Incrementing a counter safely"}),"\n",(0,r.jsxs)(n.p,{children:["Suppose we have a ",(0,r.jsx)(n.code,{children:"Post"})," model:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-prisma",children:"model Post {\r\n  id        Int    @id @default(autoincrement())\r\n  title     String\r\n  views     Int    @default(0)\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Now, if you want to increment the ",(0,r.jsx)(n.code,{children:"views"})," count every time someone reads the post:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-prisma",children:"await prisma.post.update({\r\n  where: { id: 1 },\r\n  data: {\r\n    views: {\r\n      increment: 1, // increases by 1 atomically\r\n    },\r\n  },\r\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"batch-operations",children:"Batch Operations"}),"\n",(0,r.jsx)(n.p,{children:"In Prisma, batch operations mean executing multiple database queries together in a single transaction."}),"\n",(0,r.jsxs)(n.p,{children:["This is done with ",(0,r.jsx)(n.code,{children:"prisma.$transaction()"}),", where you can pass an array of queries."]}),"\n",(0,r.jsx)(n.p,{children:"Key property:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Either all queries succeed (commit)"}),"\n",(0,r.jsx)(n.li,{children:"Or if one fails, everything rolls back (no partial changes)."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This is critical when you want to maintain data consistency."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-prisma",children:"await prisma.$transaction([\r\n  prisma.model1.create(...),\r\n  prisma.model2.update(...),\r\n  prisma.model3.delete(...),\r\n]);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Important Notes"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"prisma.$transaction()"})," can accept:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"An array of queries (batch mode)."}),"\n",(0,r.jsx)(n.li,{children:"A callback function (interactive transactions, for more complex logic)."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"Batch transactions are atomic \u2192 all queries succeed or none."}),"\n",(0,r.jsxs)(n.li,{children:["Useful for:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Bulk inserts"}),"\n",(0,r.jsx)(n.li,{children:"Multi-table consistency"}),"\n",(0,r.jsx)(n.li,{children:"Money transfers / stock updates"}),"\n",(0,r.jsx)(n.li,{children:"Running multiple reads efficiently"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"interactive-transactions",children:"Interactive transactions"}),"\n",(0,r.jsxs)(n.p,{children:["So far, we\u2019ve seen batch transactions (where you pass an array of queries to ",(0,r.jsx)(n.code,{children:"prisma.$transaction([])"}),").\r\nBut sometimes you need more control:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Run conditional logic inside a transaction"}),"\n",(0,r.jsx)(n.li,{children:"Perform multiple dependent queries (where later queries depend on earlier results)"}),"\n",(0,r.jsx)(n.li,{children:"Ensure all-or-nothing execution even with complex application logic"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"That\u2019s where Interactive Transactions come in."}),"\n",(0,r.jsxs)(n.p,{children:["They use a callback form of ",(0,r.jsx)(n.code,{children:"prisma.$transaction()"}),".\r\nPrisma gives you a special ",(0,r.jsx)(n.code,{children:"tx"})," client that you must use inside the transaction."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"await prisma.$transaction(async (tx) => {\r\n  // use tx instead of prisma\r\n  const user = await tx.user.create(...);\r\n  const post = await tx.post.create(...);\r\n  return { user, post };\r\n});\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The callback runs in a single database transaction."}),"\n",(0,r.jsx)(n.li,{children:"If any query fails (or you throw an error), the whole transaction rolls back."}),"\n",(0,r.jsx)(n.li,{children:"If everything succeeds, Prisma commits the transaction."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Why Interactive Transactions"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Conditional logic: e.g., only create a record if a check passes."}),"\n",(0,r.jsx)(n.li,{children:"Dependent queries: e.g., create a user, then use their ID for a post."}),"\n",(0,r.jsx)(n.li,{children:"Business rules: e.g., don\u2019t let someone overspend."}),"\n",(0,r.jsx)(n.li,{children:"Complex workflows: more than just independent queries."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Notes"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Always use the ",(0,r.jsx)(n.code,{children:"tx"})," client inside the callback, not the global ",(0,r.jsx)(n.code,{children:"prisma"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"If an error is thrown, Prisma rolls back automatically."}),"\n",(0,r.jsx)(n.li,{children:"You can add custom logic (loops, conditionals, validations) inside the transaction."}),"\n",(0,r.jsx)(n.li,{children:"Transactions are time-limited \u2192 by default, Prisma sets a timeout (usually 5s), but you can configure it."}),"\n",(0,r.jsx)(n.li,{children:"Not all databases handle interactive transactions identically \u2014 e.g., in MongoDB, only replica sets/sharded clusters support transactions."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);