"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[83714],{21261(e,n,r){r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"rust/Asynchronous/Streams","title":"Streams","description":"In Rust async: A Stream is an asynchronous sequence of values.","source":"@site/docs/rust/Asynchronous/5. Streams.md","sourceDirName":"rust/Asynchronous","slug":"/rust/Asynchronous/Streams","permalink":"/handbook/docs/rust/Asynchronous/Streams","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{},"sidebar":"rustApiSidebar","previous":{"title":"Async I_O","permalink":"/handbook/docs/rust/Asynchronous/Async I_O"},"next":{"title":"Error Handling","permalink":"/handbook/docs/rust/Asynchronous/Error Handling"}}');var t=r(74848),l=r(28453);const i={},a=void 0,c={},o=[{value:"Why Futures are not enough",id:"why-futures-are-not-enough",level:2},{value:"The <code>Stream</code> trait (core definition)",id:"the-stream-trait-core-definition",level:2},{value:"Streams vs Iterators (important comparison)",id:"streams-vs-iterators-important-comparison",level:2},{value:"How Streams work with <code>async/await</code>",id:"how-streams-work-with-asyncawait",level:2},{value:"Manual Stream implementation (from scratch)",id:"manual-stream-implementation-from-scratch",level:2},{value:"Using the stream",id:"using-the-stream",level:2},{value:"Streams from async I/O (real-world example)",id:"streams-from-async-io-real-world-example",level:2},{value:"Channels are streams",id:"channels-are-streams",level:2},{value:"Stream combinators (powerful stuff)",id:"stream-combinators-powerful-stuff",level:2},{value:"Backpressure (critical concept)",id:"backpressure-critical-concept",level:2},{value:"Common pitfalls",id:"common-pitfalls",level:2},{value:"Mental model",id:"mental-model",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"In Rust async: A Stream is an asynchronous sequence of values."}),"\n",(0,t.jsx)(n.p,{children:"Compare:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Abstraction"}),(0,t.jsx)(n.th,{children:"Produces"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Future<T>"})}),(0,t.jsxs)(n.td,{children:["One ",(0,t.jsx)(n.code,{children:"T"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Stream<Item = T>"})}),(0,t.jsxs)(n.td,{children:["Many ",(0,t.jsx)(n.code,{children:"T"}),"s over time"]})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"Examples of streams:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Lines from a socket"}),"\n",(0,t.jsx)(n.li,{children:"Messages from a channel"}),"\n",(0,t.jsx)(n.li,{children:"Incoming HTTP request bodies"}),"\n",(0,t.jsx)(n.li,{children:"Periodic timer ticks"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"why-futures-are-not-enough",children:"Why Futures are not enough"}),"\n",(0,t.jsx)(n.p,{children:"A future completes once."}),"\n",(0,t.jsx)(n.p,{children:"But many async problems look like:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"wait \u2192 value \u2192 wait \u2192 value \u2192 wait \u2192 value \u2192 done\n"})}),"\n",(0,t.jsx)(n.p,{children:"That\u2019s a stream."}),"\n",(0,t.jsxs)(n.h2,{id:"the-stream-trait-core-definition",children:["The ",(0,t.jsx)(n.code,{children:"Stream"})," trait (core definition)"]}),"\n",(0,t.jsxs)(n.p,{children:["From ",(0,t.jsx)(n.code,{children:"futures-core"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"use std::pin::Pin;\r\nuse std::task::{Context, Poll};\r\n\r\npub trait Stream {\r\n    type Item;\r\n\r\n    fn poll_next(\r\n        self: Pin<&mut Self>,\r\n        cx: &mut Context<'_>,\r\n    ) -> Poll<Option<Self::Item>>;\r\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Return values explained"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"Poll::Pending           // no item yet\r\nPoll::Ready(Some(item)) // next item produced\r\nPoll::Ready(None)       // stream is finished\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This mirrors ",(0,t.jsx)(n.code,{children:"Iterator"}),", but async."]}),"\n",(0,t.jsx)(n.h2,{id:"streams-vs-iterators-important-comparison",children:"Streams vs Iterators (important comparison)"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Iterator"}),(0,t.jsx)(n.th,{children:"Stream"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"next()"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"poll_next()"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Synchronous"}),(0,t.jsx)(n.td,{children:"Asynchronous"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Blocking"}),(0,t.jsx)(n.td,{children:"Non-blocking"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Pull-based"}),(0,t.jsx)(n.td,{children:"Pull-based"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"You can think of:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"Stream \u2248 async Iterator\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"how-streams-work-with-asyncawait",children:["How Streams work with ",(0,t.jsx)(n.code,{children:"async/await"})]}),"\n",(0,t.jsxs)(n.p,{children:["Rust does not yet have native ",(0,t.jsx)(n.code,{children:"async fn next()"})," syntax."]}),"\n",(0,t.jsx)(n.p,{children:"So we use:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"while let Some(item) = stream.next().await"})}),"\n",(0,t.jsxs)(n.li,{children:["Provided by ",(0,t.jsx)(n.code,{children:"StreamExt"})]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use futures::stream::StreamExt;\r\n\r\nwhile let Some(item) = stream.next().await {\r\n    println!("{item}");\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Under the hood:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:".next()"})," returns a Future"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:".await"})," polls ",(0,t.jsx)(n.code,{children:"poll_next"})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"manual-stream-implementation-from-scratch",children:"Manual Stream implementation (from scratch)"}),"\n",(0,t.jsx)(n.p,{children:"Let\u2019s build a tiny stream that yields numbers with pauses."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"use std::pin::Pin;\r\nuse std::task::{Context, Poll};\r\nuse futures::Stream;\r\nuse tokio::time::{Sleep, Duration};\r\n\r\nstruct CounterStream {\r\n    current: u32,\r\n    max: u32,\r\n    delay: Pin<Box<Sleep>>,\r\n}\r\n\r\nimpl Stream for CounterStream {\r\n    type Item = u32;\r\n\r\n    fn poll_next(\r\n        mut self: Pin<&mut Self>,\r\n        cx: &mut Context<'_>,\r\n    ) -> Poll<Option<Self::Item>> {\r\n        if self.current >= self.max {\r\n            return Poll::Ready(None);\r\n        }\r\n\r\n        if self.delay.as_mut().poll(cx).is_pending() {\r\n            return Poll::Pending;\r\n        }\r\n\r\n        let value = self.current;\r\n        self.current += 1;\r\n        self.delay = Box::pin(tokio::time::sleep(Duration::from_secs(1)));\r\n\r\n        Poll::Ready(Some(value))\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"What\u2019s happening"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Each call waits 1 second"}),"\n",(0,t.jsx)(n.li,{children:"Produces a number"}),"\n",(0,t.jsx)(n.li,{children:"Resets the timer"}),"\n",(0,t.jsxs)(n.li,{children:["Ends after ",(0,t.jsx)(n.code,{children:"max"})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"using-the-stream",children:"Using the stream"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use futures::StreamExt;\r\n\r\n#[tokio::main]\r\nasync fn main() {\r\n    let mut stream = CounterStream {\r\n        current: 0,\r\n        max: 5,\r\n        delay: Box::pin(tokio::time::sleep(Duration::from_secs(1))),\r\n    };\r\n\r\n    while let Some(value) = stream.next().await {\r\n        println!("got {value}");\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"streams-from-async-io-real-world-example",children:"Streams from async I/O (real-world example)"}),"\n",(0,t.jsx)(n.p,{children:"TCP lines as a stream"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use tokio::io::{AsyncBufReadExt, BufReader};\r\nuse tokio::net::TcpStream;\r\nuse futures::StreamExt;\r\n\r\nasync fn read_lines(stream: TcpStream) {\r\n    let reader = BufReader::new(stream);\r\n    let mut lines = reader.lines();\r\n\r\n    while let Some(line) = lines.next_line().await.unwrap() {\r\n        println!("received: {}", line);\r\n    }\r\n}\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Each line arrives asynchronously"}),"\n",(0,t.jsx)(n.li,{children:"Backpressure is handled naturally"}),"\n",(0,t.jsx)(n.li,{children:"No blocking threads"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"channels-are-streams",children:"Channels are streams"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use tokio::sync::mpsc;\r\nuse futures::StreamExt;\r\n\r\n#[tokio::main]\r\nasync fn main() {\r\n    let (tx, mut rx) = mpsc::channel(10);\r\n\r\n    tokio::spawn(async move {\r\n        for i in 0..5 {\r\n            tx.send(i).await.unwrap();\r\n        }\r\n    });\r\n\r\n    while let Some(value) = rx.recv().await {\r\n        println!("got {value}");\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Conceptually:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"recv()"})," = stream item"]}),"\n",(0,t.jsx)(n.li,{children:"Channel = async stream of messages"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"stream-combinators-powerful-stuff",children:"Stream combinators (powerful stuff)"}),"\n",(0,t.jsxs)(n.p,{children:["From ",(0,t.jsx)(n.code,{children:"futures::stream::StreamExt"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'stream\r\n    .filter(|x| async move { x % 2 == 0 })\r\n    .map(|x| x * 2)\r\n    .take(5)\r\n    .for_each(|x| async move {\r\n        println!("{x}");\r\n    })\r\n    .await;\n'})}),"\n",(0,t.jsx)(n.p,{children:"This is like:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Async iterator pipelines"}),"\n",(0,t.jsx)(n.li,{children:"With backpressure"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"backpressure-critical-concept",children:"Backpressure (critical concept)"}),"\n",(0,t.jsx)(n.p,{children:"Streams:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Only produce items when polled"}),"\n",(0,t.jsx)(n.li,{children:"Naturally slow down producers"}),"\n",(0,t.jsx)(n.li,{children:"Prevent memory blowups"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This is why streams scale so well."}),"\n",(0,t.jsx)(n.h2,{id:"common-pitfalls",children:"Common pitfalls"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Forgetting to ",(0,t.jsx)(n.code,{children:".await"})]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"stream.next(); // returns a Future, does nothing\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Blocking inside stream poll: Never block inside ",(0,t.jsx)(n.code,{children:"poll_next"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Holding references across yield points: Streams are state machines \u2192 same rules as futures."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"mental-model",children:"Mental model"}),"\n",(0,t.jsx)(n.p,{children:"Think of a stream as:"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"\u201cCall me when you want the next value. I might not have one yet. I\u2019ll tell you when I do.\u201d"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Or:"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"\u201cAn async iterator driven by an executor.\u201d"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453(e,n,r){r.d(n,{R:()=>i,x:()=>a});var s=r(96540);const t={},l=s.createContext(t);function i(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(l.Provider,{value:n},e.children)}}}]);