"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[7872],{8453(e,n,r){r.d(n,{R:()=>a,x:()=>c});var s=r(6540);const i={},t=s.createContext(i);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(t.Provider,{value:n},e.children)}},8484(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"typescript/Objects","title":"Objects","description":"Object Type Annotations","source":"@site/docs/typescript/4. Objects.md","sourceDirName":"typescript","slug":"/typescript/Objects","permalink":"/handbook/docs/typescript/Objects","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"typescriptSidebar","previous":{"title":"Types","permalink":"/handbook/docs/typescript/Types"},"next":{"title":"Advance Types","permalink":"/handbook/docs/typescript/Advance Types"}}');var i=r(4848),t=r(8453);const a={},c=void 0,l={},o=[{value:"Object Type Annotations",id:"object-type-annotations",level:2},{value:"Readonly Properties",id:"readonly-properties",level:3},{value:"Index Signatures",id:"index-signatures",level:3},{value:"Function as a Property",id:"function-as-a-property",level:3},{value:"Interfaces",id:"interfaces",level:2},{value:"Extending Interfaces",id:"extending-interfaces",level:3},{value:"Declaration Merging (Special Feature of Interfaces)",id:"declaration-merging-special-feature-of-interfaces",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"object-type-annotations",children:"Object Type Annotations"}),"\n",(0,i.jsx)(n.p,{children:"In TypeScript, Object Type Annotations let you explicitly describe the shape of an object \u2014 i.e., what properties it has and what types those properties are."}),"\n",(0,i.jsx)(n.p,{children:"This helps TypeScript check correctness at compile time and prevents mistakes like missing or wrongly typed properties."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"let obj: {\r\n  key1: Type1;\r\n  key2: Type2;\r\n};\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Keys represent property names."}),"\n",(0,i.jsx)(n.li,{children:"Values represent property types."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"readonly-properties",children:"Readonly Properties"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"readonly"})," to prevent modification after initialization."]}),"\n",(0,i.jsx)(n.li,{children:"It enforces immutability at the type level (compile-time safety)."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'let config: {\r\n  readonly apiKey: string;\r\n  mode: "dev" | "prod";\r\n};\r\n\r\nconfig = { apiKey: "12345", mode: "dev" };\r\n\r\n// config.apiKey = "67890"; \u274c Error (readonly)\r\nconfig.mode = "prod"; // \u2705 Allowed\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"apiKey"})," cannot be reassigned after initialization."]}),"\n",(0,i.jsx)(n.h3,{id:"index-signatures",children:"Index Signatures"}),"\n",(0,i.jsx)(n.p,{children:"Use index signatures when you don\u2019t know all property names ahead of time."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"let salaries: {\r\n  [employeeName: string]: number;\r\n};\r\n\r\nsalaries = {\r\n  Alice: 50000,\r\n  Bob: 60000,\r\n  Charlie: 55000,\r\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Any string key is allowed, and its value must be a ",(0,i.jsx)(n.code,{children:"number"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Number Index Signature"})}),"\n",(0,i.jsx)(n.p,{children:"You can use numbers as keys."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'interface NumberArray {\r\n  [index: number]: string;\r\n}\r\n\r\nconst myArray: NumberArray = ["apple", "banana", "cherry"];\r\n\r\nconsole.log(myArray[0]); // apple\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Here, ",(0,i.jsx)(n.code,{children:"index: number"})," means array-like indexing."]}),"\n",(0,i.jsx)(n.li,{children:"All elements must be strings."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Note: In JavaScript, object keys are always strings under the hood, so number index signatures are converted to strings internally."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Mixed Keys (String + Number)"})}),"\n",(0,i.jsx)(n.p,{children:"If you mix string and number index signatures, the number index must be a subtype of the string index (since JavaScript converts numbers \u2192 strings)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'interface MixedDictionary {\r\n  [key: string]: string; // string keys allowed\r\n  [index: number]: string; // number keys allowed\r\n}\r\n\r\nconst data: MixedDictionary = {\r\n  a: "alpha",\r\n  1: "one",\r\n};\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Both string and number keys are allowed."}),"\n",(0,i.jsxs)(n.li,{children:["Values must be ",(0,i.jsx)(n.code,{children:"string"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Restricting Index Signatures"})}),"\n",(0,i.jsx)(n.p,{children:"You can still add specific properties alongside index signatures."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'interface EmployeeDirectory {\r\n  [id: string]: string; // index signature\r\n  company: string; // fixed property\r\n}\r\n\r\nconst employees: EmployeeDirectory = {\r\n  company: "TechCorp",\r\n  e101: "Alice",\r\n  e102: "Bob",\r\n};\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"company"})," is a required property."]}),"\n",(0,i.jsxs)(n.li,{children:["Any other string key is allowed, but must have a ",(0,i.jsx)(n.code,{children:"string"})," value."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"API Response Map"})}),"\n",(0,i.jsx)(n.p,{children:"Index signatures are common when dealing with dynamic data structures like dictionaries, configuration maps, or JSON responses."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'interface ApiResponse {\r\n  [field: string]: string | number | boolean;\r\n}\r\n\r\nconst response: ApiResponse = {\r\n  status: "success",\r\n  code: 200,\r\n  isLoggedIn: true,\r\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"function-as-a-property",children:"Function as a Property"}),"\n",(0,i.jsx)(n.p,{children:"You can annotate functions inside objects."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"let mathUtils: {\r\n  add: (a: number, b: number) => number;\r\n  square: (x: number) => number;\r\n};\r\n\r\nmathUtils = {\r\n  add: (a, b) => a + b,\r\n  square: (x) => x * x,\r\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:"Ensures methods inside objects follow specific signatures."}),"\n",(0,i.jsx)(n.h2,{id:"interfaces",children:"Interfaces"}),"\n",(0,i.jsx)(n.p,{children:"An interface in TypeScript is a way to define the shape of an object."}),"\n",(0,i.jsx)(n.p,{children:"It tells TypeScript:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"What properties an object must have."}),"\n",(0,i.jsx)(n.li,{children:"What types those properties should be."}),"\n",(0,i.jsx)(n.li,{children:"Optionally, what methods the object should include."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Think of it as a contract: if a variable claims to follow an interface, it must satisfy that contract."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"interface InterfaceName {\r\n  propertyName: Type;\r\n  anotherProperty: Type;\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"extending-interfaces",children:"Extending Interfaces"}),"\n",(0,i.jsx)(n.p,{children:"TypeScript allows interfaces to extend:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Other interfaces (most common case)."}),"\n",(0,i.jsxs)(n.li,{children:["Object types (via ",(0,i.jsx)(n.code,{children:"type"})," aliases)."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'interface Person {\r\n  name: string;\r\n}\r\n\r\ninterface Employee extends Person {\r\n  id: number;\r\n  department: string;\r\n}\r\n\r\nlet emp: Employee = {\r\n  id: 1,\r\n  name: "Alice",\r\n  department: "HR",\r\n};\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Employee"})," must have everything from ",(0,i.jsx)(n.code,{children:"Person"})," plus its own properties."]}),"\n",(0,i.jsx)(n.li,{children:"You can extend multiple interfaces (similar to multiple inheritance)."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"type Person = {\r\n  name: string;\r\n  age: number;\r\n};\r\n\r\ninterface Employee extends Person {\r\n  employeeId: number;\r\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Interface vs. Type Extension"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Interface ",(0,i.jsx)(n.code,{children:"extends"})," Interface / Type \u2192 only works with object-like shapes."]}),"\n",(0,i.jsxs)(n.li,{children:["Type alias ",(0,i.jsx)(n.code,{children:"&"})," (intersection) \u2192 combines multiple types."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"type Person = {\r\n  name: string;\r\n  age: number;\r\n};\r\n\r\ntype Address = {\r\n  city: string;\r\n  country: string;\r\n};\r\n\r\n// Intersection\r\ntype Employee = Person &\r\n  Address & {\r\n    employeeId: number;\r\n  };\n"})}),"\n",(0,i.jsx)(n.h3,{id:"declaration-merging-special-feature-of-interfaces",children:"Declaration Merging (Special Feature of Interfaces)"}),"\n",(0,i.jsx)(n.p,{children:"If you declare the same interface name twice, TypeScript merges them."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'interface Car {\r\n  brand: string;\r\n}\r\n\r\ninterface Car {\r\n  model: string;\r\n}\r\n\r\nlet myCar: Car = {\r\n  brand: "Toyota",\r\n  model: "Corolla",\r\n};\n'})}),"\n",(0,i.jsx)(n.p,{children:"Useful when extending library types without modifying them directly."})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);