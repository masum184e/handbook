"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[13357],{28453(r,e,n){n.d(e,{R:()=>i,x:()=>c});var t=n(96540);const s={},o=t.createContext(s);function i(r){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function c(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(s):r.components||s:i(r.components),t.createElement(o.Provider,{value:e},r.children)}},86397(r,e,n){n.r(e),n.d(e,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"dsa/Concepts/Tree","title":"Tree","description":"Tree Traversal","source":"@site/docs/dsa/1. Concepts/13. Tree.md","sourceDirName":"dsa/1. Concepts","slug":"/dsa/Concepts/Tree","permalink":"/handbook/docs/dsa/Concepts/Tree","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":13,"frontMatter":{"title":"Tree","sidebar_position":13},"sidebar":"dsaSidebar","previous":{"title":"Graph","permalink":"/handbook/docs/dsa/Concepts/Graph"},"next":{"title":"Binary Tree","permalink":"/handbook/docs/dsa/Concepts/Binary Tree"}}');var s=n(74848),o=n(28453);const i={title:"Tree",sidebar_position:13},c=void 0,d={},l=[{value:"Tree Traversal",id:"tree-traversal",level:2},{value:"BFS",id:"bfs",level:3},{value:"BFS",id:"bfs-1",level:3}];function a(r){const e={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...r.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h2,{id:"tree-traversal",children:"Tree Traversal"}),"\n",(0,s.jsx)(e.h3,{id:"bfs",children:"BFS"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Level Order"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"bfs-1",children:"BFS"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"preorder : root -> left -> right"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Prefix expression are generated from expressoin tree of the expression."}),"\n",(0,s.jsx)(e.li,{children:"A copy of the tree is generated from preorder traverse."}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'void preorderIterative(Node* root) {\r\n    if (root == NULL) return;\r\n\r\n    stack<Node*> st;\r\n    st.push(root);\r\n\r\n    while (!st.empty()) {\r\n        Node* current = st.top();\r\n        st.pop();\r\n\r\n        cout << current->data << " ";\r\n\r\n        if (current->right)\r\n            st.push(current->right);\r\n\r\n        if (current->left)\r\n            st.push(current->left);\r\n    }\r\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"inorder : left -> root -> right"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Expression are extracted from inorder tree of the expressoin."}),"\n",(0,s.jsxs)(e.li,{children:["In BST, to extract item in non-decresing order, perform reverse inorder(",(0,s.jsx)(e.code,{children:"HOW"}),")"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'void inorder(Node* root) {\r\n    stack<Node*> st;\r\n    Node* current = root;\r\n\r\n    while (current != NULL || !st.empty()) {\r\n\r\n        // Go to leftmost node\r\n        while (current != NULL) {\r\n            st.push(current);\r\n            current = current->left;\r\n        }\r\n\r\n        current = st.top();\r\n        st.pop();\r\n\r\n        cout << current->data << " ";\r\n\r\n        current = current->right;\r\n    }\r\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"postorder: left -> right -> root"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Post expression are generated from expressoin tree of the expression."}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'// One Stack\r\nvoid postorder(Node* root) {\r\n    if (root == NULL) return;\r\n\r\n    stack<Node*> st1, st2;\r\n    st1.push(root);\r\n\r\n    while (!st1.empty()) {\r\n        Node* current = st1.top();\r\n        st1.pop();\r\n\r\n        st2.push(current);\r\n\r\n        if (current->left)\r\n            st1.push(current->left);\r\n\r\n        if (current->right)\r\n            st1.push(current->right);\r\n    }\r\n\r\n    while (!st2.empty()) {\r\n        cout << st2.top()->data << " ";\r\n        st2.pop();\r\n    }\r\n}\r\n\r\n// Two Stack\r\nvoid postorder(Node* root) {\r\n    if (root == NULL) return;\r\n\r\n    stack<Node*> st;\r\n    Node* current = root;\r\n    Node* lastVisited = NULL;\r\n\r\n    while (current != NULL || !st.empty()) {\r\n\r\n        if (current != NULL) {\r\n            st.push(current);\r\n            current = current->left;\r\n        }\r\n        else {\r\n            Node* peekNode = st.top();\r\n\r\n            if (peekNode->right != NULL && lastVisited != peekNode->right) {\r\n                current = peekNode->right;\r\n            }\r\n            else {\r\n                cout << peekNode->data << " ";\r\n                lastVisited = peekNode;\r\n                st.pop();\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n"]}),"\n"]})]})}function p(r={}){const{wrapper:e}={...(0,o.R)(),...r.components};return e?(0,s.jsx)(e,{...r,children:(0,s.jsx)(a,{...r})}):a(r)}}}]);