"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[98],{6781:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>t,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"database-design/Storage Consideration","title":"Storage Consideration","description":"When we talk about storage, we mean how data is physically stored on disk (or SSD, memory). This includes:","source":"@site/docs/database-design/16. Storage Consideration.md","sourceDirName":"database-design","slug":"/database-design/Storage Consideration","permalink":"/handbook/docs/database-design/Storage Consideration","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":17,"frontMatter":{"sidebar_position":17}}');var a=s(4848),l=s(8453);const r={sidebar_position:17},t=void 0,o={},d=[{value:"Key Storage Considerations",id:"key-storage-considerations",level:2},{value:"Data Types and Storage Size",id:"data-types-and-storage-size",level:3},{value:"Row Storage Format",id:"row-storage-format",level:3},{value:"Normalization vs Denormalization",id:"normalization-vs-denormalization",level:3},{value:"Index Storage",id:"index-storage",level:3},{value:"Null and Sparse Data",id:"null-and-sparse-data",level:3},{value:"LOB (Large Objects) Storage",id:"lob-large-objects-storage",level:3},{value:"Partitioning &amp; Tablespaces",id:"partitioning--tablespaces",level:3},{value:"Compression",id:"compression",level:3},{value:"Caching &amp; Buffer Pools",id:"caching--buffer-pools",level:3}];function c(e){const n={h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",ul:"ul",...(0,l.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"When we talk about storage, we mean how data is physically stored on disk (or SSD, memory). This includes:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"How tables and indexes are organized on disk."}),"\n",(0,a.jsx)(n.li,{children:"How much space they use."}),"\n",(0,a.jsx)(n.li,{children:"How efficiently data is read/written during queries."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"key-storage-considerations",children:"Key Storage Considerations"}),"\n",(0,a.jsx)(n.h3,{id:"data-types-and-storage-size",children:"Data Types and Storage Size"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Choosing the right data type affects storage."}),"\n",(0,a.jsxs)(n.li,{children:["Example:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"INT (4 bytes) vs BIGINT (8 bytes)."}),"\n",(0,a.jsx)(n.li,{children:"If you only need values up to 1M, INT is enough."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.li,{children:"Storing unnecessarily large types wastes space and slows I/O."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"row-storage-format",children:"Row Storage Format"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Fixed-length storage:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Faster to access (rows are predictable size)."}),"\n",(0,a.jsx)(n.li,{children:"But wastes space if values are small."}),"\n",(0,a.jsx)(n.li,{children:"Example: CHAR(50) always takes 50 bytes."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["Variable-length storage:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Saves space (only stores needed bytes)."}),"\n",(0,a.jsx)(n.li,{children:"Slightly slower (extra lookup)."}),"\n",(0,a.jsx)(n.li,{children:"Example: VARCHAR(50) only stores actual characters + length info."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"normalization-vs-denormalization",children:"Normalization vs Denormalization"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Normalized tables: reduce redundancy, save storage space, but may require joins (extra reads)."}),"\n",(0,a.jsx)(n.li,{children:"Denormalized tables: may increase storage (duplication), but speed up queries."}),"\n",(0,a.jsx)(n.li,{children:"Trade-off depends on workload (OLTP vs OLAP)."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"index-storage",children:"Index Storage"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Every index takes extra disk space."}),"\n",(0,a.jsxs)(n.li,{children:["Example:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"A table of 10M rows, indexed on 3 columns, might double storage needs."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.li,{children:"Indexes speed up queries but slow down inserts/updates."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"null-and-sparse-data",children:"Null and Sparse Data"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Columns with many NULL values should be carefully stored."}),"\n",(0,a.jsx)(n.li,{children:"Some DBMS support sparse columns (store only non-null values)."}),"\n",(0,a.jsx)(n.li,{children:"Example: Employee table with 100 optional attributes \u2192 better to split into separate tables."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"lob-large-objects-storage",children:"LOB (Large Objects) Storage"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Images, PDFs, audio, video = BLOBs (Binary Large Objects)."}),"\n",(0,a.jsx)(n.li,{children:"Text documents = CLOBs (Character Large Objects)."}),"\n",(0,a.jsxs)(n.li,{children:["Options for storage:","\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Inside the database (slower queries, but consistent backups)."}),"\n",(0,a.jsx)(n.li,{children:"Outside the database (filesystem or cloud), with just a reference in DB (faster, smaller DB)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"partitioning--tablespaces",children:"Partitioning & Tablespaces"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Partitioning (split data into smaller parts) improves manageability + query speed."}),"\n",(0,a.jsx)(n.li,{children:"Tablespaces allow storing different tables/indexes on different physical disks \u2192 balance I/O load."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"compression",children:"Compression"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Many DBMS support table and index compression."}),"\n",(0,a.jsx)(n.li,{children:"Reduces disk usage and I/O, but may increase CPU load."}),"\n",(0,a.jsxs)(n.li,{children:["Example:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Compressing a log table with millions of rows that are rarely updated."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"caching--buffer-pools",children:"Caching & Buffer Pools"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Databases use memory caches to reduce disk reads."}),"\n",(0,a.jsx)(n.li,{children:"Storage design should optimize which data fits in cache (e.g., hot vs cold data)."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>t});var i=s(6540);const a={},l=i.createContext(a);function r(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);