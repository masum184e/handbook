"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[3416],{5431(e,n,r){r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>o,frontMatter:()=>d,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"dsa/Concepts/Graph","title":"Graph","description":"Graph Representation","source":"@site/docs/dsa/1. Concepts/12. Graph.md","sourceDirName":"dsa/1. Concepts","slug":"/dsa/Concepts/Graph","permalink":"/handbook/docs/dsa/Concepts/Graph","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":12,"frontMatter":{"title":"Graph","sidebar_position":12},"sidebar":"dsaSidebar","previous":{"title":"Greedy","permalink":"/handbook/docs/dsa/Concepts/Greedy"},"next":{"title":"Tree","permalink":"/handbook/docs/dsa/Concepts/Tree"}}');var i=r(4848),t=r(8453);const d={title:"Graph",sidebar_position:12},l=void 0,c={},h=[{value:"Graph Representation",id:"graph-representation",level:2},{value:"Adjacency Matrix",id:"adjacency-matrix",level:3},{value:"Adjacency List",id:"adjacency-list",level:3},{value:"Edge List",id:"edge-list",level:3},{value:"Adjacency Set / Map",id:"adjacency-set--map",level:3},{value:"Incidence Matrix",id:"incidence-matrix",level:3},{value:"Quick Comparison",id:"quick-comparison",level:3},{value:"Graph Implementation",id:"graph-implementation",level:2},{value:"C Programming",id:"c-programming",level:3},{value:"C++ Programming",id:"c-programming-1",level:3},{value:"Traversing",id:"traversing",level:2},{value:"DFS",id:"dfs",level:3},{value:"BFS",id:"bfs",level:3},{value:"When to Use BFS vs DFS?",id:"when-to-use-bfs-vs-dfs",level:3},{value:"Complexity",id:"complexity",level:3},{value:"Shortest path using BFS",id:"shortest-path-using-bfs",level:2}];function a(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"graph-representation",children:"Graph Representation"}),"\n",(0,i.jsx)(n.h3,{id:"adjacency-matrix",children:"Adjacency Matrix"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A 2D V\xd7V array (",(0,i.jsx)(n.code,{children:"matrix[i][j]"}),") where:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"1"})," (or weight) \u2192 edge exists between vertex ",(0,i.jsx)(n.code,{children:"i"})," and ",(0,i.jsx)(n.code,{children:"j"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"0"})," \u2192 no edge."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Works for directed/undirected, weighted/unweighted graphs."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Pros:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Fast edge check: ",(0,i.jsx)(n.code,{children:"O(1)"})," to check if edge ",(0,i.jsx)(n.code,{children:"(u, v)"})," exists."]}),"\n",(0,i.jsx)(n.li,{children:"Simple implementation: Very straightforward."}),"\n",(0,i.jsx)(n.li,{children:"Good for dense graphs: When number of edges E \u2248 V^2."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Cons:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Memory heavy: Requires O(V",(0,i.jsx)("sup",{children:"2"}),") space, even if sparse."]}),"\n",(0,i.jsx)(n.li,{children:"Inefficient for sparse graphs: Most of the matrix might be zeros."}),"\n",(0,i.jsx)(n.li,{children:"Slow to iterate neighbors: Takes O(V) to find all neighbors of a vertex."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use:"})," Small graphs or dense graphs where checking edge existence quickly is needed."]}),"\n",(0,i.jsx)(n.h3,{id:"adjacency-list",children:"Adjacency List"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Each vertex has a list of neighbors."}),"\n",(0,i.jsx)(n.li,{children:"Usually implemented as an array of lists or vectors."}),"\n",(0,i.jsx)(n.li,{children:"Can store weights if needed."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Pros:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Space efficient: Uses O(V+E) space, good for sparse graphs."}),"\n",(0,i.jsx)(n.li,{children:"Easy to iterate neighbors: Only iterate over actual edges, not empty slots."}),"\n",(0,i.jsx)(n.li,{children:"Flexible: Can store weights easily."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Cons:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Edge existence check is slower: Need to search the list \u2192 O(k), where k = degree of vertex."}),"\n",(0,i.jsx)(n.li,{children:"Slightly more complex implementation than a matrix."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use:"})," Large sparse graphs, most real-world networks (social networks, maps)."]}),"\n",(0,i.jsx)(n.h3,{id:"edge-list",children:"Edge List"}),"\n",(0,i.jsx)(n.p,{children:"A list of all edges. Each edge is stored as a pair (u, v) or (u, v, w) if weighted."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Pros:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Simple and compact: Good for storing edges only."}),"\n",(0,i.jsx)(n.li,{children:"Easy to implement algorithms like Kruskal\u2019s (MST)."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Cons:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Slow to check edge existence: O(E) search needed."}),"\n",(0,i.jsx)(n.li,{children:"Hard to iterate neighbors of a vertex efficiently."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use:"})," Algorithms that process edges directly, e.g., Kruskal\u2019s MST, or input/output of edges."]}),"\n",(0,i.jsx)(n.h3,{id:"adjacency-set--map",children:"Adjacency Set / Map"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Similar to adjacency list but uses hash sets/maps instead of lists."}),"\n",(0,i.jsxs)(n.li,{children:["Example: ",(0,i.jsx)(n.code,{children:"unordered_map<int, unordered_set<int>>"})," in C++."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Pros:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Fast edge check: O(1) average for set/map."}),"\n",(0,i.jsx)(n.li,{children:"Space efficient for sparse graphs."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Cons:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"More memory overhead than simple lists."}),"\n",(0,i.jsx)(n.li,{children:"Slightly slower iteration than plain arrays/lists."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use:"})," Sparse graphs when you need fast existence checks for edges."]}),"\n",(0,i.jsx)(n.h3,{id:"incidence-matrix",children:"Incidence Matrix"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A V\xd7E matrix: ",(0,i.jsx)(n.code,{children:"matrix[i][j] = 1"})," if vertex ",(0,i.jsx)(n.code,{children:"i"})," is incident to edge ",(0,i.jsx)(n.code,{children:"j"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"Rarely used except in special graph algorithms."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Pros:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Mathematically elegant; good for theoretical analysis."}),"\n",(0,i.jsx)(n.li,{children:"Can represent multi-graphs easily."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Cons:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Memory heavy: O(V\xd7E)"}),"\n",(0,i.jsx)(n.li,{children:"Not practical for most programming problems."}),"\n",(0,i.jsx)(n.li,{children:"Edge iteration and neighbor finding is slower."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use:"})," Academic or theoretical problems, multi-graphs, or algorithms needing incidence info."]}),"\n",(0,i.jsx)(n.h3,{id:"quick-comparison",children:"Quick Comparison"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Representation"}),(0,i.jsx)(n.th,{children:"Space Complexity"}),(0,i.jsx)(n.th,{children:"Edge Check"}),(0,i.jsx)(n.th,{children:"Neighbor Iteration"}),(0,i.jsx)(n.th,{children:"Best For"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Adjacency Matrix"}),(0,i.jsx)(n.td,{children:"O(V\xb2)"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"O(V)"}),(0,i.jsx)(n.td,{children:"Dense graph, fast edge check"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Adjacency List"}),(0,i.jsx)(n.td,{children:"O(V+E)"}),(0,i.jsx)(n.td,{children:"O(k)"}),(0,i.jsx)(n.td,{children:"O(k)"}),(0,i.jsx)(n.td,{children:"Sparse graph, iterate neighbors"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Edge List"}),(0,i.jsx)(n.td,{children:"O(E)"}),(0,i.jsx)(n.td,{children:"O(E)"}),(0,i.jsx)(n.td,{children:"O(E)"}),(0,i.jsx)(n.td,{children:"Edge-centric algorithms"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Adjacency Set/Map"}),(0,i.jsx)(n.td,{children:"O(V+E)"}),(0,i.jsx)(n.td,{children:"O(1) avg"}),(0,i.jsx)(n.td,{children:"O(k)"}),(0,i.jsx)(n.td,{children:"Sparse graph, fast edge check"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Incidence Matrix"}),(0,i.jsx)(n.td,{children:"O(V*E)"}),(0,i.jsx)(n.td,{children:"O(V)"}),(0,i.jsx)(n.td,{children:"O(E)"}),(0,i.jsx)(n.td,{children:"Multi-graphs, theoretical work"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"graph-implementation",children:"Graph Implementation"}),"\n",(0,i.jsx)(n.h3,{id:"c-programming",children:"C Programming"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"struct Node {\r\n    int vertex;\r\n    struct Node* next;\r\n};\r\n\r\n// Graph structure\r\nstruct Graph {\r\n    int numVertices;\r\n    struct Node** adjLists;\r\n    bool* visited;\r\n};\r\n\r\n// Create a node\r\nstruct Node* createNode(int v) {\r\n    struct Node* newNode = malloc(sizeof(struct Node));\r\n    newNode->vertex = v;\r\n    newNode->next = NULL;\r\n    return newNode;\r\n}\r\n\r\n// Create a graph\r\nstruct Graph* createGraph(int vertices) {\r\n    struct Graph* graph = malloc(sizeof(struct Graph));\r\n    graph->numVertices = vertices;\r\n    graph->adjLists = malloc(vertices * sizeof(struct Node*));\r\n    graph->visited = malloc(vertices * sizeof(bool));\r\n\r\n    for (int i = 0; i < vertices; i++) {\r\n        graph->adjLists[i] = NULL;\r\n        graph->visited[i] = false;\r\n    }\r\n    return graph;\r\n}\r\n\r\n// Add edge (undirected)\r\nvoid addEdge(struct Graph* graph, int src, int dest) {\r\n    // Add edge src -> dest\r\n    struct Node* newNode = createNode(dest);\r\n    newNode->next = graph->adjLists[src];\r\n    graph->adjLists[src] = newNode;\r\n\r\n    // Add edge dest -> src\r\n    newNode = createNode(src);\r\n    newNode->next = graph->adjLists[dest];\r\n    graph->adjLists[dest] = newNode;\r\n}\r\n\r\nint main() {\r\n    struct Graph* graph = createGraph(4);\r\n\r\n    addEdge(graph, 0, 1);\r\n    addEdge(graph, 0, 2);\r\n    addEdge(graph, 1, 2);\r\n    addEdge(graph, 2, 3);\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"c-programming-1",children:"C++ Programming"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"class Graph {\r\n    int V;                    // Number of vertices\r\n    vector<list<int>> adj;    // Adjacency list\r\n\r\npublic:\r\n    Graph(int V) {\r\n        this->V = V;\r\n        adj.resize(V);\r\n    }\r\n\r\n    // Add edge (undirected)\r\n    void addEdge(int v, int w) {\r\n        adj[v].push_back(w);\r\n        adj[w].push_back(v);\r\n    }\r\n};\r\n\r\nint main() {\r\n    Graph g(4);\r\n\r\n    g.addEdge(0, 1);\r\n    g.addEdge(0, 2);\r\n    g.addEdge(1, 2);\r\n    g.addEdge(2, 3);\r\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"traversing",children:"Traversing"}),"\n",(0,i.jsx)(n.h3,{id:"dfs",children:"DFS"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Recursive/Iterative:"})," Required 3 parameter(adj list, visited nodes, current node)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Itertive:"})," In ",(0,i.jsx)(n.strong,{children:"stack"})," which element insert first, pop out at last, which ",(0,i.jsx)(n.strong,{children:"reverse"})," the order. So iterate the list from last and insert into stack, whish will pop out at last as well, this way the order of traversing maintain properly."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Characterstics:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["It is useful for tasks like ",(0,i.jsx)(n.strong,{children:"cycle detection"}),", ",(0,i.jsx)(n.strong,{children:"topological sorting"}),", and ",(0,i.jsx)(n.strong,{children:"maze solving"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"Find path without shortest path requirement"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"bfs",children:"BFS"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Iterative:"})," Just replace stack with queue in dfs, rest is same."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Characterstics:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Explores neighbors before children(layer by layer)"}),"\n",(0,i.jsxs)(n.li,{children:["Finds ",(0,i.jsx)(n.strong,{children:"shortest path"})," in an ",(0,i.jsx)(n.strong,{children:"unweighted"})," graph"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"when-to-use-bfs-vs-dfs",children:"When to Use BFS vs DFS?"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Aspect"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"BFS"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"DFS"})})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Shortest Path?"})}),(0,i.jsx)(n.td,{children:"\u2705 Yes (unweighted graphs)"}),(0,i.jsx)(n.td,{children:"\u274c No"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Memory Usage"})}),(0,i.jsx)(n.td,{children:"\ud83d\udfe0 High (stores full layer)"}),(0,i.jsx)(n.td,{children:"\ud83d\udfe2 Lower (stores one path)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Graph Type?"})}),(0,i.jsx)(n.td,{children:"\ud83d\udfe2 Wide, shallow graphs"}),(0,i.jsx)(n.td,{children:"\ud83d\udfe2 Deep, narrow graphs"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Cycle Detection?"})}),(0,i.jsx)(n.td,{children:"\ud83d\udfe2 Yes"}),(0,i.jsx)(n.td,{children:"\ud83d\udfe2 Yes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Connected Components?"})}),(0,i.jsx)(n.td,{children:"\ud83d\udfe2 Yes"}),(0,i.jsx)(n.td,{children:"\ud83d\udfe2 Yes"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"complexity",children:"Complexity"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"V: Number of vertices (nodes)"}),"\n",(0,i.jsx)(n.li,{children:"E: Number of edges (connections)"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Time Complexity:"})," O(V + E)"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Space Complexity:"})," O(V)"]}),"\n",(0,i.jsx)(n.h2,{id:"shortest-path-using-bfs",children:"Shortest path using BFS"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"BFS explores all nodes at distance 1 first, then distance 2, and so on."}),"\n",(0,i.jsx)(n.li,{children:"The first time you reach a node, you have found the shortest path from the source."}),"\n",(0,i.jsx)(n.li,{children:"To extract the path, you need to track the parent of each node."}),"\n",(0,i.jsxs)(n.li,{children:["Create a ",(0,i.jsx)(n.code,{children:"visited"})," array to mark visited nodes."]}),"\n",(0,i.jsxs)(n.li,{children:["Create a ",(0,i.jsx)(n.code,{children:"parent"})," array to store the predecessor of each node.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"parent[v] = u"})," the node from which you reached ",(0,i.jsx)(n.code,{children:"v"}),"."]}),"\n"]}),"\n"]}),"\n"]})]})}function o(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453(e,n,r){r.d(n,{R:()=>d,x:()=>l});var s=r(6540);const i={},t=s.createContext(i);function d(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);