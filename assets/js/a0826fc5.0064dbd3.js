"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[54722],{6705(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>o,frontMatter:()=>t,metadata:()=>l,toc:()=>d});const l=JSON.parse('{"id":"rust/Stack vs Heap","title":"Stack vs Heap","description":"| Stack                     | Heap                               |","source":"@site/docs/rust/9. Stack vs Heap.md","sourceDirName":"rust","slug":"/rust/Stack vs Heap","permalink":"/handbook/docs/rust/Stack vs Heap","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{}}');var i=s(74848),r=s(28453);const t={},a=void 0,c={},d=[{value:"The Stack",id:"the-stack",level:2},{value:"Stack Frames",id:"stack-frames",level:3},{value:"The Heap",id:"the-heap",level:2},{value:"Example: Heap Allocation with String",id:"example-heap-allocation-with-string",level:3},{value:"Why Ownership Matters for the Heap",id:"why-ownership-matters-for-the-heap",level:2},{value:"Problem Without Ownership",id:"problem-without-ownership",level:3},{value:"Move Semantics (Heap Safety)",id:"move-semantics-heap-safety",level:2},{value:"Stack vs Heap in Function Calls",id:"stack-vs-heap-in-function-calls",level:2},{value:"Stack-only argument",id:"stack-only-argument",level:3},{value:"Heap-allocated argument",id:"heap-allocated-argument",level:3},{value:"Borrowing: Safe Heap Access",id:"borrowing-safe-heap-access",level:3},{value:"Mutable Borrowing &amp; Heap Writes",id:"mutable-borrowing--heap-writes",level:2},{value:"Stack Data Referencing Heap Data",id:"stack-data-referencing-heap-data",level:2},{value:"Example: Dangling Pointer (Prevented)",id:"example-dangling-pointer-prevented",level:2},{value:"Stack vs Heap and Lifetimes",id:"stack-vs-heap-and-lifetimes",level:2},{value:"Common Heap Types in Rust",id:"common-heap-types-in-rust",level:2},{value:"Mental Model (This One Sticks)",id:"mental-model-this-one-sticks",level:2},{value:"Why Rust Cares So Much",id:"why-rust-cares-so-much",level:2}];function h(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Stack"}),(0,i.jsx)(n.th,{children:"Heap"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Fast"}),(0,i.jsx)(n.td,{children:"Slower (but flexible)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Fixed size"}),(0,i.jsx)(n.td,{children:"Dynamic size"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"LIFO (last in, first out)"}),(0,i.jsx)(n.td,{children:"Arbitrary order"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Known at compile time"}),(0,i.jsx)(n.td,{children:"Known at runtime"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Automatically managed"}),(0,i.jsx)(n.td,{children:"Explicitly managed (by Rust rules)"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"the-stack",children:"The Stack"}),"\n",(0,i.jsx)(n.p,{children:"The stack is a region of memory that:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Grows and shrinks automatically"}),"\n",(0,i.jsx)(n.li,{children:"Stores values with a known, fixed size"}),"\n",(0,i.jsx)(n.li,{children:"Is extremely fast to access"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"fn main() {\r\n    let x: i32 = 5;\r\n    let y: i32 = x;\r\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"What happens in memory"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"x"})," is pushed onto the stack"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"y"})," gets a copy of the value"]}),"\n",(0,i.jsx)(n.li,{children:"Both values exist independently"}),"\n",(0,i.jsx)(n.li,{children:"No ownership complexity"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Why copying is allowed:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"i32"})," has a fixed size"]}),"\n",(0,i.jsx)(n.li,{children:"No heap allocation"}),"\n",(0,i.jsxs)(n.li,{children:["Implements ",(0,i.jsx)(n.code,{children:"Copy"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"stack-frames",children:"Stack Frames"}),"\n",(0,i.jsx)(n.p,{children:"Each function call gets its own stack frame:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"fn foo() {\r\n    let a = 10;\r\n}\r\n\r\nfn main() {\r\n    foo();\r\n}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"a"})," exists only inside ",(0,i.jsx)(n.code,{children:"foo"}),"\u2019s stack frame"]}),"\n",(0,i.jsxs)(n.li,{children:["When ",(0,i.jsx)(n.code,{children:"foo"})," returns, the frame is popped"]}),"\n",(0,i.jsx)(n.li,{children:"Memory is instantly reclaimed"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This is why stack memory is so fast."}),"\n",(0,i.jsx)(n.h2,{id:"the-heap",children:"The Heap"}),"\n",(0,i.jsx)(n.p,{children:"The heap is used when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Size is unknown at compile time"}),"\n",(0,i.jsx)(n.li,{children:"Data needs to live longer than a stack frame"}),"\n",(0,i.jsx)(n.li,{children:"Data needs to be shared or grow dynamically"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Heap allocation is:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Slower"}),"\n",(0,i.jsx)(n.li,{children:"More flexible"}),"\n",(0,i.jsx)(n.li,{children:"Requires explicit rules to manage safely"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-heap-allocation-with-string",children:"Example: Heap Allocation with String"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let s = String::from("hello");\n'})}),"\n",(0,i.jsx)(n.p,{children:"Memory layout"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'Stack:           Heap:\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 s           \u2502\u2192 \u2502 "hello"     \u2502\r\n\u2502 ptr         \u2502  \u2502             \u2502\r\n\u2502 len         \u2502  \u2502             \u2502\r\n\u2502 capacity    \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"String"})," struct lives on the stack"]}),"\n",(0,i.jsx)(n.li,{children:"The actual text lives on the heap"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"s"})," owns the heap allocation"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"why-ownership-matters-for-the-heap",children:"Why Ownership Matters for the Heap"}),"\n",(0,i.jsx)(n.h3,{id:"problem-without-ownership",children:"Problem Without Ownership"}),"\n",(0,i.jsx)(n.p,{children:"In C/C++:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'char* s = malloc(5);\r\nfree(s);\r\nprintf("%s", s); // \ud83d\udca5 undefined behavior\n'})}),"\n",(0,i.jsx)(n.p,{children:"Use-after-free."}),"\n",(0,i.jsx)(n.p,{children:"Rust makes this impossible."}),"\n",(0,i.jsx)(n.h2,{id:"move-semantics-heap-safety",children:"Move Semantics (Heap Safety)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let s1 = String::from("hello");\r\nlet s2 = s1;\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Stack data (",(0,i.jsx)(n.code,{children:"ptr"}),", ",(0,i.jsx)(n.code,{children:"len"}),", ",(0,i.jsx)(n.code,{children:"capacity"}),") is moved"]}),"\n",(0,i.jsx)(n.li,{children:"Heap allocation is NOT copied"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"s1"})," is invalidated"]}),"\n",(0,i.jsx)(n.li,{children:"Only one owner remains"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This prevents double free."}),"\n",(0,i.jsx)(n.h2,{id:"stack-vs-heap-in-function-calls",children:"Stack vs Heap in Function Calls"}),"\n",(0,i.jsx)(n.h3,{id:"stack-only-argument",children:"Stack-only argument"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"fn takes_i32(x: i32) {}\r\n\r\nlet a = 5;\r\ntakes_i32(a); // copy\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Cheap"}),"\n",(0,i.jsx)(n.li,{children:"No ownership transfer"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"heap-allocated-argument",children:"Heap-allocated argument"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'fn takes_string(s: String) {}\r\n\r\nlet s = String::from("hello");\r\ntakes_string(s); // move\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Ownership moves into the function"}),"\n",(0,i.jsx)(n.li,{children:"Heap memory freed when function ends"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"borrowing-safe-heap-access",children:"Borrowing: Safe Heap Access"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'fn print(s: &String) {\r\n    println!("{}", s);\r\n}\r\n\r\nlet s = String::from("hello");\r\nprint(&s);\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Stack reference passed"}),"\n",(0,i.jsx)(n.li,{children:"Heap data is not moved"}),"\n",(0,i.jsx)(n.li,{children:"Owner remains responsible for freeing"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Borrowing exists because heap data is expensive and dangerous to duplicate."}),"\n",(0,i.jsx)(n.h2,{id:"mutable-borrowing--heap-writes",children:"Mutable Borrowing & Heap Writes"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'fn append(s: &mut String) {\r\n    s.push_str(" world");\r\n}\r\n\r\nlet mut s = String::from("hello");\r\nappend(&mut s);\n'})}),"\n",(0,i.jsx)(n.p,{children:"Why only one mutable borrow?"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Multiple writers to heap memory = data races"}),"\n",(0,i.jsx)(n.li,{children:"Rust forbids this at compile time"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"stack-data-referencing-heap-data",children:"Stack Data Referencing Heap Data"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let s = String::from("hello");\r\nlet r = &s;\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"r"})," is on the stack"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"r"})," points to stack data (",(0,i.jsx)(n.code,{children:"s"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"s"})," points to heap data"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Rust ensures:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"r"})," cannot outlive ",(0,i.jsx)(n.code,{children:"s"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"s"})," frees heap memory exactly once"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"example-dangling-pointer-prevented",children:"Example: Dangling Pointer (Prevented)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let r: &String;\r\n\r\n{\r\n    let s = String::from("hello");\r\n    r = &s; // \u274c compile-time error\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Why?"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"s"}),"\u2019s stack frame disappears"]}),"\n",(0,i.jsx)(n.li,{children:"Heap memory would be freed"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"r"})," would dangle"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Rust refuses to compile."}),"\n",(0,i.jsx)(n.h2,{id:"stack-vs-heap-and-lifetimes",children:"Stack vs Heap and Lifetimes"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\r\n    if x.len() > y.len() { x } else { y }\r\n}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Lifetimes track stack references"}),"\n",(0,i.jsx)(n.li,{children:"Ownership controls heap memory"}),"\n",(0,i.jsx)(n.li,{children:"Together, they prevent dangling pointers"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Performance Perspective"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Aspect"}),(0,i.jsx)(n.th,{children:"Stack"}),(0,i.jsx)(n.th,{children:"Heap"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Allocation"}),(0,i.jsx)(n.td,{children:"Free"}),(0,i.jsx)(n.td,{children:"Expensive"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Deallocation"}),(0,i.jsx)(n.td,{children:"Free"}),(0,i.jsx)(n.td,{children:"Expensive"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Cache-friendly"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"Less"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Ownership needed"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"Yes"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Rust:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Prefers stack allocation by default"}),"\n",(0,i.jsx)(n.li,{children:"Uses heap only when necessary"}),"\n",(0,i.jsx)(n.li,{children:"Makes heap usage explicit"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"common-heap-types-in-rust",children:"Common Heap Types in Rust"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"String"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"Vec<T>"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"Box<T>"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Rc<T>"})," / ",(0,i.jsx)(n.code,{children:"Arc<T>"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"All of them:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Own heap data"}),"\n",(0,i.jsx)(n.li,{children:"Use ownership rules to free memory safely"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"mental-model-this-one-sticks",children:"Mental Model (This One Sticks)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Stack = short-lived, fixed-size, automatic"}),"\n",(0,i.jsx)(n.li,{children:"Heap = long-lived, dynamic, owned"}),"\n",(0,i.jsx)(n.li,{children:"Ownership = who frees the heap"}),"\n",(0,i.jsx)(n.li,{children:"Borrowing = temporary access"}),"\n",(0,i.jsx)(n.li,{children:"Lifetimes = how long references are valid"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"why-rust-cares-so-much",children:"Why Rust Cares So Much"}),"\n",(0,i.jsx)(n.p,{children:"Because almost all memory bugs come from:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Heap misuse"}),"\n",(0,i.jsx)(n.li,{children:"Aliasing + mutation"}),"\n",(0,i.jsx)(n.li,{children:"Lifetime mismatches"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Rust solves these without a garbage collector."})]})}function o(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453(e,n,s){s.d(n,{R:()=>t,x:()=>a});var l=s(96540);const i={},r=l.createContext(i);function t(e){const n=l.useContext(r);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),l.createElement(r.Provider,{value:n},e.children)}}}]);