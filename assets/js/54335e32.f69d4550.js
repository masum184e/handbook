"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[45627],{28453(r,n,e){e.d(n,{R:()=>i,x:()=>t});var s=e(96540);const o={},c=s.createContext(o);function i(r){const n=s.useContext(c);return s.useMemo(function(){return"function"==typeof r?r(n):{...n,...r}},[n,r])}function t(r){let n;return n=r.disableParentContext?"function"==typeof r.components?r.components(o):r.components||o:i(r.components),s.createElement(c.Provider,{value:n},r.children)}},75099(r,n,e){e.r(n),e.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"reactjs/Error Boundaries","title":"Error Boundaries","description":"An Error Boundary is a React component that catches JavaScript errors in its child component tree and prevents the entire app from crashing.","source":"@site/docs/reactjs/18. Error Boundaries.md","sourceDirName":"reactjs","slug":"/reactjs/Error Boundaries","permalink":"/handbook/docs/reactjs/Error Boundaries","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":19,"frontMatter":{"sidebar_position":19},"sidebar":"reactjsApiSidebar","previous":{"title":"Uncontrolled Component","permalink":"/handbook/docs/reactjs/Uncontrolled Component"},"next":{"title":"Styling","permalink":"/handbook/docs/reactjs/Styling"}}');var o=e(74848),c=e(28453);const i={sidebar_position:19},t=void 0,d={},l=[{value:"What Error Boundaries Can and Cannot Catch",id:"what-error-boundaries-can-and-cannot-catch",level:2},{value:"They CAN catch:",id:"they-can-catch",level:3},{value:"They CANNOT catch:",id:"they-cannot-catch",level:3},{value:"Error Boundaries Must Be Class Components",id:"error-boundaries-must-be-class-components",level:2},{value:"Error Boundary Scope (Very Important)",id:"error-boundary-scope-very-important",level:2},{value:"Handling Errors in Event Handlers",id:"handling-errors-in-event-handlers",level:2},{value:"Resetting an Error Boundary",id:"resetting-an-error-boundary",level:2},{value:"Error Boundaries vs <code>try/catch</code>",id:"error-boundaries-vs-trycatch",level:2},{value:"Why Hooks Cannot Catch Render Errors",id:"why-hooks-cannot-catch-render-errors",level:2},{value:"Why the Async Function Is Inside useEffect",id:"why-the-async-function-is-inside-useeffect",level:2}];function a(r){const n={blockquote:"blockquote",br:"br",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,c.R)(),...r.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"An Error Boundary is a React component that catches JavaScript errors in its child component tree and prevents the entire app from crashing."}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Error boundaries catch errors during rendering, lifecycle methods, and constructors of child components."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Instead of a blank screen, you can show:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"A fallback UI"}),"\n",(0,o.jsx)(n.li,{children:"An error message"}),"\n",(0,o.jsx)(n.li,{children:"A recovery option"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Why Do We Need Error Boundaries?"})}),"\n",(0,o.jsx)(n.p,{children:"Without error boundaries:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"A single component error crashes the whole app"}),"\n",(0,o.jsx)(n.li,{children:"Users see a white screen"}),"\n",(0,o.jsx)(n.li,{children:"Debugging is harder"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"With error boundaries:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Errors are isolated"}),"\n",(0,o.jsx)(n.li,{children:"App continues to work"}),"\n",(0,o.jsx)(n.li,{children:"UX is much better"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"what-error-boundaries-can-and-cannot-catch",children:"What Error Boundaries Can and Cannot Catch"}),"\n",(0,o.jsx)(n.h3,{id:"they-can-catch",children:"They CAN catch:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Errors in rendering"}),"\n",(0,o.jsx)(n.li,{children:"Errors in lifecycle methods"}),"\n",(0,o.jsx)(n.li,{children:"Errors in constructors of child components"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"they-cannot-catch",children:"They CANNOT catch:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Event handler errors (",(0,o.jsx)(n.code,{children:"onClick"}),", ",(0,o.jsx)(n.code,{children:"onChange"}),")"]}),"\n",(0,o.jsxs)(n.li,{children:["Errors in async code (",(0,o.jsx)(n.code,{children:"setTimeout"}),", ",(0,o.jsx)(n.code,{children:"fetch"}),", ",(0,o.jsx)(n.code,{children:"async/await"}),")"]}),"\n",(0,o.jsx)(n.li,{children:"Errors in the error boundary itself"}),"\n",(0,o.jsx)(n.li,{children:"Server-side rendering errors"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Event handlers must use ",(0,o.jsx)(n.code,{children:"try/catch"}),"."]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["Error boundaries handle render-time errors.",(0,o.jsx)(n.br,{}),"\n",(0,o.jsx)(n.code,{children:"try...catch"})," handles runtime async errors."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"error-boundaries-must-be-class-components",children:"Error Boundaries Must Be Class Components"}),"\n",(0,o.jsx)(n.p,{children:"As of now, error boundaries cannot be written with hooks.\r\nThey must be class components."}),"\n",(0,o.jsx)(n.p,{children:"React provides two lifecycle methods for this:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"static getDerivedStateFromError()"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"componentDidCatch()"})}),"\n"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Create an Error Boundary"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:'import React from "react";\r\n\r\nclass ErrorBoundary extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { hasError: false };\r\n  }\r\n\r\n  static getDerivedStateFromError(error) {\r\n    return { hasError: true };\r\n  }\r\n\r\n  componentDidCatch(error, errorInfo) {\r\n    console.error("Error caught:", error, errorInfo);\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      return <h2>Something went wrong.</h2>;\r\n    }\r\n\r\n    return this.props.children;\r\n  }\r\n}\r\n\r\nexport default ErrorBoundary;\n'})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"hasError"})," tracks whether an error occurred"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"getDerivedStateFromError()"})," updates UI state"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"componentDidCatch()"})," logs error details"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"children"})," renders wrapped components"]}),"\n"]}),"\n",(0,o.jsxs)(n.ol,{start:"2",children:["\n",(0,o.jsx)(n.li,{children:"Component That Throws an Error"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:'function BuggyComponent({ crash }) {\r\n  if (crash) {\r\n    throw new Error("Boom! Component crashed");\r\n  }\r\n\r\n  return <h3>Component is working fine</h3>;\r\n}\n'})}),"\n",(0,o.jsxs)(n.ol,{start:"3",children:["\n",(0,o.jsx)(n.li,{children:"Using the Error Boundary"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"function App() {\r\n  return (\r\n    <ErrorBoundary>\r\n      <BuggyComponent crash={true} />\r\n    </ErrorBoundary>\r\n  );\r\n}\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"BuggyComponent"})," throws an error"]}),"\n",(0,o.jsx)(n.li,{children:"Error boundary catches it"}),"\n",(0,o.jsx)(n.li,{children:"React stops rendering the broken subtree"}),"\n",(0,o.jsx)(n.li,{children:"Fallback UI is shown instead of crashing the app"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"error-boundary-scope-very-important",children:"Error Boundary Scope (Very Important)"}),"\n",(0,o.jsx)(n.p,{children:"Error boundaries only catch errors in their children, not siblings or parents."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"<ErrorBoundary>\r\n  <ComponentA />\r\n  <ComponentB />\r\n</ErrorBoundary>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If ",(0,o.jsx)(n.code,{children:"ComponentA"})," crashes:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"ComponentB"})," is also replaced by fallback UI"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"To isolate errors, use multiple boundaries."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Fine-Grained Error Handling"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"<ErrorBoundary>\r\n  <Sidebar />\r\n</ErrorBoundary>\r\n\r\n<ErrorBoundary>\r\n  <MainContent />\r\n</ErrorBoundary>\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Sidebar errors don\u2019t break main content"}),"\n",(0,o.jsx)(n.li,{children:"Better fault isolation"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"handling-errors-in-event-handlers",children:"Handling Errors in Event Handlers"}),"\n",(0,o.jsx)(n.p,{children:"Error boundaries do not catch event handler errors."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:'function ClickError() {\r\n  function handleClick() {\r\n    throw new Error("Click error");\r\n  }\r\n\r\n  return <button onClick={handleClick}>Click</button>;\r\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Correct Way"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:'function ClickError() {\r\n  function handleClick() {\r\n    try {\r\n      throw new Error("Click error");\r\n    } catch (error) {\r\n      console.error(error);\r\n    }\r\n  }\r\n\r\n  return <button onClick={handleClick}>Click</button>;\r\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"resetting-an-error-boundary",children:"Resetting an Error Boundary"}),"\n",(0,o.jsx)(n.p,{children:"You can reset error state when props change."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"componentDidUpdate(prevProps) {\r\n  if (prevProps.resetKey !== this.props.resetKey) {\r\n    this.setState({ hasError: false });\r\n  }\r\n}\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Retry buttons"}),"\n",(0,o.jsx)(n.li,{children:"Navigation changes"}),"\n"]}),"\n",(0,o.jsxs)(n.h2,{id:"error-boundaries-vs-trycatch",children:["Error Boundaries vs ",(0,o.jsx)(n.code,{children:"try/catch"})]}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Feature"}),(0,o.jsx)(n.th,{children:"Error Boundary"}),(0,o.jsx)(n.th,{children:"try/catch"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Render errors"}),(0,o.jsx)(n.td,{children:"\u2705"}),(0,o.jsx)(n.td,{children:"\u274c"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Event handlers"}),(0,o.jsx)(n.td,{children:"\u274c"}),(0,o.jsx)(n.td,{children:"\u2705"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Async code"}),(0,o.jsx)(n.td,{children:"\u274c"}),(0,o.jsx)(n.td,{children:"\u2705"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"UI fallback"}),(0,o.jsx)(n.td,{children:"\u2705"}),(0,o.jsx)(n.td,{children:"\u274c"})]})]})]}),"\n",(0,o.jsx)(n.h2,{id:"why-hooks-cannot-catch-render-errors",children:"Why Hooks Cannot Catch Render Errors"}),"\n",(0,o.jsxs)(n.p,{children:["Hooks like ",(0,o.jsx)(n.code,{children:"useEffect"}),", ",(0,o.jsx)(n.code,{children:"useState"}),", and ",(0,o.jsx)(n.code,{children:"try/catch"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Do NOT catch rendering errors"}),"\n",(0,o.jsx)(n.li,{children:"Do NOT catch errors in JSX"}),"\n",(0,o.jsx)(n.li,{children:"Do NOT replace error boundaries"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Example that does NOT work:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:'function BadErrorHandling() {\r\n  try {\r\n    throw new Error("Crash");\r\n  } catch (e) {\r\n    return <p>Error</p>;\r\n  }\r\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Why?"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"React errors happen during rendering"}),"\n",(0,o.jsx)(n.li,{children:"Rendering happens before hooks logic finishes"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"why-the-async-function-is-inside-useeffect",children:"Why the Async Function Is Inside useEffect"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"useEffect"})," callback cannot be ",(0,o.jsx)(n.code,{children:"async"})]}),"\n",(0,o.jsx)(n.li,{children:"We define and call an async function inside it"}),"\n"]})]})}function h(r={}){const{wrapper:n}={...(0,c.R)(),...r.components};return n?(0,o.jsx)(n,{...r,children:(0,o.jsx)(a,{...r})}):a(r)}}}]);