"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[91547],{28453(n,e,s){s.d(e,{R:()=>t,x:()=>c});var i=s(96540);const l={},r=i.createContext(l);function t(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(l):n.components||l:t(n.components),i.createElement(r.Provider,{value:e},n.children)}},76773(n,e,s){s.r(e),s.d(e,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"rust/Asynchronous/async_await","title":"async_await","description":"In Rust, async does NOT mean \u201crun this on another thread.\u201d","source":"@site/docs/rust/Asynchronous/1. async_await.md","sourceDirName":"rust/Asynchronous","slug":"/rust/Asynchronous/async_await","permalink":"/handbook/docs/rust/Asynchronous/async_await","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{}}');var l=s(74848),r=s(28453);const t={},c=void 0,a={},o=[{value:"Blocking vs async (mental model)",id:"blocking-vs-async-mental-model",level:2},{value:"<code>async fn</code> \u2014 what it really returns",id:"async-fn--what-it-really-returns",level:2},{value:"What is a <code>Future</code>",id:"what-is-a-future",level:2},{value:"What <code>await</code> actually does",id:"what-await-actually-does",level:2},{value:"Async does not do anything by itself",id:"async-does-not-do-anything-by-itself",level:2},{value:"Minimal working async example (Tokio)",id:"minimal-working-async-example-tokio",level:2},{value:"Example 1: Basic async function",id:"example-1-basic-async-function",level:3},{value:"Async concurrency (not parallelism)",id:"async-concurrency-not-parallelism",level:2},{value:"Spawning tasks (true async scheduling)",id:"spawning-tasks-true-async-scheduling",level:2},{value:"Common misconceptions (very important)",id:"common-misconceptions-very-important",level:2}];function d(n){const e={blockquote:"blockquote",br:"br",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...n.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(e.p,{children:["In Rust, ",(0,l.jsx)(e.code,{children:"async"})," does NOT mean \u201crun this on another thread.\u201d\r\nThis is the single most important thing to understand."]}),"\n",(0,l.jsx)(e.p,{children:"Instead:"}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"async"})," means \u201cthis function can be paused and resumed without blocking the thread.\u201d"]}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["Rust ",(0,l.jsx)(e.code,{children:"async"})," is about cooperative multitasking, not preemptive multitasking."]}),"\n",(0,l.jsx)(e.h2,{id:"blocking-vs-async-mental-model",children:"Blocking vs async (mental model)"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["Blocking code: ",(0,l.jsx)(e.code,{children:"let data = socket.read(); // thread is stuck here"})]}),"\n",(0,l.jsxs)(e.li,{children:["Async code: ",(0,l.jsx)(e.code,{children:"let data = socket.read().await; // thread can do other work"})]}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["When you ",(0,l.jsx)(e.code,{children:"await"}),", you\u2019re saying:"]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"\u201cIf this isn\u2019t ready yet, pause me and let something else run.\u201d"}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"async-fn--what-it-really-returns",children:[(0,l.jsx)(e.code,{children:"async fn"})," \u2014 what it really returns"]}),"\n",(0,l.jsx)(e.p,{children:"When you write:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-rust",children:"async fn fetch() -> u32 {\r\n    42\r\n}\n"})}),"\n",(0,l.jsxs)(e.p,{children:["You might think it returns a ",(0,l.jsx)(e.code,{children:"u32"}),".\r\nIt does not."]}),"\n",(0,l.jsx)(e.p,{children:"It actually returns:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-rust",children:"fn fetch() -> impl Future<Output = u32>\n"})}),"\n",(0,l.jsx)(e.p,{children:"So this:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-rust",children:"let x = fetch();\n"})}),"\n",(0,l.jsxs)(e.p,{children:["does not run the function",(0,l.jsx)(e.br,{}),"\n","it just creates a Future"]}),"\n",(0,l.jsxs)(e.p,{children:["Nothing executes until the future is polled (usually by ",(0,l.jsx)(e.code,{children:".await"}),")."]}),"\n",(0,l.jsxs)(e.h2,{id:"what-is-a-future",children:["What is a ",(0,l.jsx)(e.code,{children:"Future"})]}),"\n",(0,l.jsxs)(e.p,{children:["A ",(0,l.jsx)(e.code,{children:"Future"})," is basically a state machine."]}),"\n",(0,l.jsx)(e.p,{children:"Simplified definition:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-rust",children:"trait Future {\r\n    type Output;\r\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\r\n}\n"})}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"Poll"})," has two states:"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-rust",children:"enum Poll<T> {\r\n    Ready(T),\r\n    Pending,\r\n}\n"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"Ready(value)"})," \u2192 computation finished"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"Pending"})," \u2192 not ready yet, try again later"]}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"Rust async is pull-based:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"An executor keeps polling futures"}),"\n",(0,l.jsx)(e.li,{children:"Futures say \u201cnot ready\u201d or \u201cdone\u201d"}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"what-await-actually-does",children:["What ",(0,l.jsx)(e.code,{children:"await"})," actually does"]}),"\n",(0,l.jsx)(e.p,{children:"When you write:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-rust",children:"let result = some_future.await;\n"})}),"\n",(0,l.jsx)(e.p,{children:"The compiler rewrites this into:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"A state machine"}),"\n",(0,l.jsxs)(e.li,{children:["That yields control when the future returns ",(0,l.jsx)(e.code,{children:"Pending"})]}),"\n",(0,l.jsx)(e.li,{children:"And resumes from the same spot later"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"Key rule"}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:".await"})," can only appear inside an ",(0,l.jsx)(e.code,{children:"async"})," context"]}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"Because only async functions can be turned into resumable state machines."}),"\n",(0,l.jsx)(e.h2,{id:"async-does-not-do-anything-by-itself",children:"Async does not do anything by itself"}),"\n",(0,l.jsx)(e.p,{children:"This code does nothing:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-rust",children:'async fn hello() {\r\n    println!("hello");\r\n}\r\n\r\nfn main() {\r\n    hello(); // nothing happens\r\n}\n'})}),"\n",(0,l.jsx)(e.p,{children:"Why?\r\nBecause:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"No executor"}),"\n",(0,l.jsx)(e.li,{children:"Future is never polled"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"You need:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"An async runtime (Tokio, async-std, smol, etc.)"}),"\n"]}),"\n",(0,l.jsx)(e.h2,{id:"minimal-working-async-example-tokio",children:"Minimal working async example (Tokio)"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.code,{children:"Cargo.toml"})}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-toml",children:'[dependencies]\r\ntokio = { version = "1", features = ["full"] }\n'})}),"\n",(0,l.jsx)(e.h3,{id:"example-1-basic-async-function",children:"Example 1: Basic async function"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-rust",children:'use tokio::time::{sleep, Duration};\r\n\r\nasync fn say_hello() {\r\n    println!("hello...");\r\n    sleep(Duration::from_secs(1)).await;\r\n    println!("world!");\r\n}\r\n\r\n#[tokio::main]\r\nasync fn main() {\r\n    say_hello().await;\r\n}\n'})}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"say_hello()"})," returns a ",(0,l.jsx)(e.code,{children:"Future"})]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:".await"})," polls it"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"sleep()"})," returns ",(0,l.jsx)(e.code,{children:"Pending"})]}),"\n",(0,l.jsxs)(e.li,{children:["Tokio pauses ",(0,l.jsx)(e.code,{children:"say_hello"})]}),"\n",(0,l.jsx)(e.li,{children:"Timer completes"}),"\n",(0,l.jsxs)(e.li,{children:["Tokio resumes ",(0,l.jsx)(e.code,{children:"say_hello"})]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:'"world!"'})," prints"]}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"The thread was free during the sleep"}),"\n",(0,l.jsx)(e.h2,{id:"async-concurrency-not-parallelism",children:"Async concurrency (not parallelism)"}),"\n",(0,l.jsx)(e.p,{children:"Running multiple async tasks"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-rust",children:'use tokio::time::{sleep, Duration};\r\n\r\nasync fn task(id: u32) {\r\n    println!("task {} started", id);\r\n    sleep(Duration::from_secs(1)).await;\r\n    println!("task {} finished", id);\r\n}\r\n\r\n#[tokio::main]\r\nasync fn main() {\r\n    let t1 = task(1);\r\n    let t2 = task(2);\r\n\r\n    tokio::join!(t1, t2);\r\n}\n'})}),"\n",(0,l.jsx)(e.p,{children:"Output (order may vary)"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{children:"task 1 started\r\ntask 2 started\r\ntask 1 finished\r\ntask 2 finished\n"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Both tasks run on one thread"}),"\n",(0,l.jsxs)(e.li,{children:["They interleave at ",(0,l.jsx)(e.code,{children:".await"})]}),"\n",(0,l.jsx)(e.li,{children:"No threads are blocked"}),"\n"]}),"\n",(0,l.jsx)(e.h2,{id:"spawning-tasks-true-async-scheduling",children:"Spawning tasks (true async scheduling)"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-rust",children:'use tokio::time::{sleep, Duration};\r\n\r\n#[tokio::main]\r\nasync fn main() {\r\n    tokio::spawn(async {\r\n        sleep(Duration::from_secs(1)).await;\r\n        println!("task A");\r\n    });\r\n\r\n    tokio::spawn(async {\r\n        sleep(Duration::from_secs(1)).await;\r\n        println!("task B");\r\n    });\r\n\r\n    sleep(Duration::from_secs(2)).await;\r\n}\n'})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"spawn"})," schedules independent tasks"]}),"\n",(0,l.jsx)(e.li,{children:"Executor decides when to poll them"}),"\n",(0,l.jsx)(e.li,{children:"Still async, still cooperative"}),"\n"]}),"\n",(0,l.jsx)(e.h2,{id:"common-misconceptions-very-important",children:"Common misconceptions (very important)"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Async = multithreading: Nope."}),"\n",(0,l.jsx)(e.li,{children:"Async = faster: Only for IO-bound workloads."}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"await"})," blocks: It yields, not blocks."]}),"\n",(0,l.jsx)(e.li,{children:"Async works without runtime: You always need an executor."}),"\n"]}),"\n",(0,l.jsxs)(e.ol,{start:"10",children:["\n",(0,l.jsx)(e.li,{children:"When should you use async in Rust?"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"Use async when:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Network IO"}),"\n",(0,l.jsx)(e.li,{children:"File IO"}),"\n",(0,l.jsx)(e.li,{children:"Timers"}),"\n",(0,l.jsx)(e.li,{children:"High concurrency with low CPU usage"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"Avoid async when:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Heavy CPU computation"}),"\n",(0,l.jsx)(e.li,{children:"Tight loops"}),"\n",(0,l.jsx)(e.li,{children:"Simple synchronous programs"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"(You can mix async + threads when needed.)"})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,l.jsx)(e,{...n,children:(0,l.jsx)(d,{...n})}):d(n)}}}]);