"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[60679],{28453(r,e,n){n.d(e,{R:()=>o,x:()=>l});var s=n(96540);const t={},i=s.createContext(t);function o(r){const e=s.useContext(i);return s.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function l(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(t):r.components||t:o(r.components),s.createElement(i.Provider,{value:e},r.children)}},68558(r,e,n){n.r(e),n.d(e,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"rust/Error Handling.md/Error Propagation","title":"Error Propagation","description":"The ? operator:","source":"@site/docs/rust/12. Error Handling.md/4. Error Propagation.md","sourceDirName":"rust/12. Error Handling.md","slug":"/rust/Error Handling.md/Error Propagation","permalink":"/handbook/docs/rust/Error Handling.md/Error Propagation","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{}}');var t=n(74848),i=n(28453);const o={},l=void 0,d={},c=[{value:"Why use <code>?</code>?",id:"why-use-",level:2},{value:"How <code>?</code> works with <code>Result</code>",id:"how--works-with-result",level:2},{value:"Example 1: File reading",id:"example-1-file-reading",level:3},{value:"How <code>?</code> works with <code>Option</code>",id:"how--works-with-option",level:2},{value:"Example 2: Chaining optional values",id:"example-2-chaining-optional-values",level:3},{value:"Rules for using <code>?</code>",id:"rules-for-using-",level:2},{value:"Automatic error conversion with <code>From</code>",id:"automatic-error-conversion-with-from",level:2},{value:"Example 3: Custom error type",id:"example-3-custom-error-type",level:3},{value:"Example 4: Using <code>?</code> in <code>main</code>",id:"example-4-using--in-main",level:3},{value:"<code>?</code> vs <code>unwrap()</code> / <code>expect()</code>",id:"-vs-unwrap--expect",level:2},{value:"Summary",id:"summary",level:2}];function a(r){const e={blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...r.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.code,{children:"?"})," operator:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Works with ",(0,t.jsx)(e.code,{children:"Result"})," and ",(0,t.jsx)(e.code,{children:"Option"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["If the value is success (",(0,t.jsx)(e.code,{children:"Ok"})," / ",(0,t.jsx)(e.code,{children:"Some"}),"), it unwraps it."]}),"\n",(0,t.jsxs)(e.li,{children:["If the value is failure (",(0,t.jsx)(e.code,{children:"Err"})," / ",(0,t.jsx)(e.code,{children:"None"}),"), it returns early from the current function with that error."]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"In short:"}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"?"})," = \u201cTry this. If it fails, return the error immediately.\u201d"]}),"\n"]}),"\n",(0,t.jsxs)(e.h2,{id:"why-use-",children:["Why use ",(0,t.jsx)(e.code,{children:"?"}),"?"]}),"\n",(0,t.jsxs)(e.p,{children:["Without ",(0,t.jsx)(e.code,{children:"?"}),", error handling gets verbose:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"fn read_number(path: &str) -> Result<i32, std::io::Error> {\r\n    let contents = match std::fs::read_to_string(path) {\r\n        Ok(c) => c,\r\n        Err(e) => return Err(e),\r\n    };\r\n\r\n    let number = match contents.trim().parse::<i32>() {\r\n        Ok(n) => n,\r\n        Err(e) => return Err(std::io::Error::new(std::io::ErrorKind::InvalidData, e)),\r\n    };\r\n\r\n    Ok(number)\r\n}\r\n```rust\r\n\r\nWith `?`, it becomes much cleaner:\r\n```rust\r\nfn read_number(path: &str) -> Result<i32, std::io::Error> {\r\n    let contents = std::fs::read_to_string(path)?;\r\n    let number = contents.trim().parse::<i32>()\r\n        .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))?;\r\n    Ok(number)\r\n}\n"})}),"\n",(0,t.jsxs)(e.h2,{id:"how--works-with-result",children:["How ",(0,t.jsx)(e.code,{children:"?"})," works with ",(0,t.jsx)(e.code,{children:"Result"})]}),"\n",(0,t.jsx)(e.h3,{id:"example-1-file-reading",children:"Example 1: File reading"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::fs::File;\r\nuse std::io::{self, Read};\r\n\r\nfn read_file(path: &str) -> Result<String, io::Error> {\r\n    let mut file = File::open(path)?;       // If Err, return Err\r\n    let mut contents = String::new();\r\n    file.read_to_string(&mut contents)?;    // If Err, return Err\r\n    Ok(contents)\r\n}\r\n\r\nfn main() {\r\n    match read_file("hello.txt") {\r\n        Ok(text) => println!("File contents:\\n{}", text),\r\n        Err(e) => println!("Error reading file: {}", e),\r\n    }\r\n}\n'})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["If ",(0,t.jsx)(e.code,{children:"File::open"})," fails \u2192 function returns immediately with that error."]}),"\n",(0,t.jsxs)(e.li,{children:["If ",(0,t.jsx)(e.code,{children:"read_to_string"})," fails \u2192 same."]}),"\n",(0,t.jsxs)(e.li,{children:["Otherwise, returns ",(0,t.jsx)(e.code,{children:"Ok(contents)"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(e.h2,{id:"how--works-with-option",children:["How ",(0,t.jsx)(e.code,{children:"?"})," works with ",(0,t.jsx)(e.code,{children:"Option"})]}),"\n",(0,t.jsx)(e.h3,{id:"example-2-chaining-optional-values",children:"Example 2: Chaining optional values"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn first_even_double(nums: &[i32]) -> Option<i32> {\r\n    let first = nums.first()?;      // If empty, return None\r\n    let even = if first % 2 == 0 {\r\n        Some(*first)\r\n    } else {\r\n        None\r\n    }?;\r\n    Some(even * 2)\r\n}\r\n\r\nfn main() {\r\n    let nums = vec![2, 4, 6];\r\n    println!("{:?}", first_even_double(&nums)); // Some(4)\r\n\r\n    let empty: Vec<i32> = vec![];\r\n    println!("{:?}", first_even_double(&empty)); // None\r\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:["If any step returns ",(0,t.jsx)(e.code,{children:"None"}),", the whole function returns ",(0,t.jsx)(e.code,{children:"None"}),"."]}),"\n",(0,t.jsxs)(e.h2,{id:"rules-for-using-",children:["Rules for using ",(0,t.jsx)(e.code,{children:"?"})]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["The function must return a compatible type:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Use ",(0,t.jsx)(e.code,{children:"?"})," on ",(0,t.jsx)(e.code,{children:"Result<T, E>"})," \u2192 function must return ",(0,t.jsx)(e.code,{children:"Result<_, E>"})," (or compatible error)."]}),"\n",(0,t.jsxs)(e.li,{children:["Use ",(0,t.jsx)(e.code,{children:"?"})," on ",(0,t.jsx)(e.code,{children:"Option<T>"})," \u2192 function must return ",(0,t.jsx)(e.code,{children:"Option<_>"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.li,{children:"Error types must match or be convertible."}),"\n"]}),"\n",(0,t.jsxs)(e.h2,{id:"automatic-error-conversion-with-from",children:["Automatic error conversion with ",(0,t.jsx)(e.code,{children:"From"})]}),"\n",(0,t.jsxs)(e.p,{children:["If your function returns a different error type, Rust uses ",(0,t.jsx)(e.code,{children:"From"})," to convert automatically."]}),"\n",(0,t.jsx)(e.h3,{id:"example-3-custom-error-type",children:"Example 3: Custom error type"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::fs;\r\nuse std::num::ParseIntError;\r\nuse std::io;\r\n\r\n#[derive(Debug)]\r\nenum MyError {\r\n    Io(io::Error),\r\n    Parse(ParseIntError),\r\n}\r\n\r\nimpl From<io::Error> for MyError {\r\n    fn from(err: io::Error) -> MyError {\r\n        MyError::Io(err)\r\n    }\r\n}\r\n\r\nimpl From<ParseIntError> for MyError {\r\n    fn from(err: ParseIntError) -> MyError {\r\n        MyError::Parse(err)\r\n    }\r\n}\r\n\r\nfn read_number(path: &str) -> Result<i32, MyError> {\r\n    let contents = fs::read_to_string(path)?;  // io::Error \u2192 MyError\r\n    let number = contents.trim().parse::<i32>()?; // ParseIntError \u2192 MyError\r\n    Ok(number)\r\n}\n"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"?"})," automatically converts errors using ",(0,t.jsx)(e.code,{children:"From"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"example-4-using--in-main",children:["Example 4: Using ",(0,t.jsx)(e.code,{children:"?"})," in ",(0,t.jsx)(e.code,{children:"main"})]}),"\n",(0,t.jsxs)(e.p,{children:["Rust allows ",(0,t.jsx)(e.code,{children:"main"})," to return ",(0,t.jsx)(e.code,{children:"Result"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() -> Result<(), Box<dyn std::error::Error>> {\r\n    let text = std::fs::read_to_string("hello.txt")?;\r\n    println!("{}", text);\r\n    Ok(())\r\n}\n'})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Any error will automatically be printed and the program exits with a failure code."}),"\n"]}),"\n",(0,t.jsxs)(e.h2,{id:"-vs-unwrap--expect",children:[(0,t.jsx)(e.code,{children:"?"})," vs ",(0,t.jsx)(e.code,{children:"unwrap()"})," / ",(0,t.jsx)(e.code,{children:"expect()"})]}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Feature"}),(0,t.jsx)(e.th,{children:(0,t.jsx)(e.code,{children:"?"})}),(0,t.jsxs)(e.th,{children:[(0,t.jsx)(e.code,{children:"unwrap()"})," / ",(0,t.jsx)(e.code,{children:"expect()"})]})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"On failure"}),(0,t.jsx)(e.td,{children:"Returns error to caller"}),(0,t.jsx)(e.td,{children:"Panics"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Use case"}),(0,t.jsx)(e.td,{children:"Recoverable errors"}),(0,t.jsx)(e.td,{children:"Bugs / impossible cases"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Code safety"}),(0,t.jsx)(e.td,{children:"Safer, composable"}),(0,t.jsx)(e.td,{children:"Risky in production"})]})]})]}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"?"})," propagates errors automatically."]}),"\n",(0,t.jsxs)(e.li,{children:["Works with ",(0,t.jsx)(e.code,{children:"Result"})," and ",(0,t.jsx)(e.code,{children:"Option"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["Eliminates boilerplate ",(0,t.jsx)(e.code,{children:"match"})," and ",(0,t.jsx)(e.code,{children:"if let"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["Uses ",(0,t.jsx)(e.code,{children:"From"})," for error type conversion."]}),"\n",(0,t.jsx)(e.li,{children:"Encourages writing clean, safe, composable Rust code."}),"\n"]})]})}function h(r={}){const{wrapper:e}={...(0,i.R)(),...r.components};return e?(0,t.jsx)(e,{...r,children:(0,t.jsx)(a,{...r})}):a(r)}}}]);