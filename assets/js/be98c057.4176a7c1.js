"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[2842],{28453(e,n,s){s.d(n,{R:()=>o,x:()=>a});var r=s(96540);const t={},i=r.createContext(t);function o(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(i.Provider,{value:n},e.children)}},95706(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"rest-api-design/Async Processing","title":"Async Processing","description":"Asynchronous processing means the client sends a request, and instead of waiting for the task to finish, the server immediately responds with a task reference or status URL. The client can then poll or wait for notification when the task completes.","source":"@site/docs/rest-api-design/38. Async Processing.md","sourceDirName":"rest-api-design","slug":"/rest-api-design/Async Processing","permalink":"/handbook/docs/rest-api-design/Async Processing","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":40,"frontMatter":{"title":"Async Processing","sidebar_position":40},"sidebar":"restApiSidebar","previous":{"title":"Quotas","permalink":"/handbook/docs/rest-api-design/Quotas"},"next":{"title":"Webhooks","permalink":"/handbook/docs/rest-api-design/Webhooks"}}');var t=s(74848),i=s(28453);const o={title:"Async Processing",sidebar_position:40},a=void 0,c={},l=[{value:"Why Async is Important for Performance &amp; Scalability",id:"why-async-is-important-for-performance--scalability",level:2},{value:"Common Pattern: Task Queue",id:"common-pattern-task-queue",level:2},{value:"Asynchronous Processing Design Tips",id:"asynchronous-processing-design-tips",level:2}];function d(e){const n={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Asynchronous processing means the client sends a request, and instead of waiting for the task to finish, the server immediately responds with a task reference or status URL. The client can then poll or wait for notification when the task completes."}),"\n",(0,t.jsx)(n.h2,{id:"why-async-is-important-for-performance--scalability",children:"Why Async is Important for Performance & Scalability"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Non-blocking operations: The server does not hold resources while the task is running."}),"\n",(0,t.jsx)(n.li,{children:"Improved latency: The client gets a response immediately."}),"\n",(0,t.jsx)(n.li,{children:"Better resource utilization: Long-running tasks are handled in background workers or queues."}),"\n",(0,t.jsx)(n.li,{children:"Supports high throughput: Server can handle many requests concurrently."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"common-pattern-task-queue",children:"Common Pattern: Task Queue"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Client sends request:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:'POST /api/reports\r\nContent-Type: application/json\r\n\r\n{\r\n  "reportType": "monthly_sales",\r\n  "format": "pdf"\r\n}\n'})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsx)(n.li,{children:"Server immediately responds:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:'HTTP/1.1 202 Accepted\r\nContent-Type: application/json\r\nLocation: /api/reports/789/status\r\n\r\n{\r\n  "taskId": "789",\r\n  "status": "pending"\r\n}\n'})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsx)(n.li,{children:"Client polls status:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:"GET /api/reports/789/status\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsx)(n.li,{children:"Server responds:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:'HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{\r\n  "taskId": "789",\r\n  "status": "completed",\r\n  "resultUrl": "/api/reports/789/download"\r\n}\n'})}),"\n",(0,t.jsxs)(n.ol,{start:"4",children:["\n",(0,t.jsx)(n.li,{children:"Client downloads the result:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:"GET /api/reports/789/download\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"202 Accepted"})," \u2192 Server accepted the task but hasn\u2019t completed it."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Location"})," header \u2192 Provides a status endpoint to check progress."]}),"\n",(0,t.jsx)(n.li,{children:"This pattern decouples client request from long-running processing, improving scalability."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"asynchronous-processing-design-tips",children:"Asynchronous Processing Design Tips"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use task queues (e.g., RabbitMQ, Kafka, AWS SQS) for background work."}),"\n",(0,t.jsxs)(n.li,{children:["Track task status: ",(0,t.jsx)(n.code,{children:"pending"}),", ",(0,t.jsx)(n.code,{children:"in_progress"}),", ",(0,t.jsx)(n.code,{children:"completed"}),", ",(0,t.jsx)(n.code,{children:"failed"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Return a ",(0,t.jsx)(n.code,{children:"taskId"})," to allow polling or result retrieval."]}),"\n",(0,t.jsx)(n.li,{children:"Avoid synchronous blocking on long tasks."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);