"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[52367],{28453(e,n,t){t.d(n,{R:()=>r,x:()=>l});var s=t(96540);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},64413(e,n,t){t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"reactjs/Hooks/useState","title":"useState","description":"The useState hook is the most fundamental React Hook. It allows functional components to store, update, and manage state.","source":"@site/docs/reactjs/11. Hooks/8. useState.md","sourceDirName":"reactjs/11. Hooks","slug":"/reactjs/Hooks/useState","permalink":"/handbook/docs/reactjs/Hooks/useState","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{},"sidebar":"reactjsApiSidebar","previous":{"title":"useEffect","permalink":"/handbook/docs/reactjs/Hooks/useEffect"},"next":{"title":"Styling","permalink":"/handbook/docs/reactjs/Styling"}}');var a=t(74848),i=t(28453);const r={},l=void 0,o={},c=[{value:"What is <code>useState</code>",id:"what-is-usestate",level:2},{value:"Why Do We Need <code>useState</code>",id:"why-do-we-need-usestate",level:2},{value:"Syntax of <code>useState</code>",id:"syntax-of-usestate",level:2},{value:"How useState Works Internally (Concept)",id:"how-usestate-works-internally-concept",level:2},{value:"Simple Example \u2013 Counter",id:"simple-example--counter",level:2},{value:"Updating State Based on Previous State",id:"updating-state-based-on-previous-state",level:2},{value:"<code>useState</code> with Objects",id:"usestate-with-objects",level:2},{value:"useState with Arrays",id:"usestate-with-arrays",level:2},{value:"Lazy Initialization (Performance Optimization)",id:"lazy-initialization-performance-optimization",level:2},{value:"Common Mistakes",id:"common-mistakes",level:2}];function d(e){const n={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"useState"})," hook is the most fundamental React Hook. It allows functional components to store, update, and manage state."]}),"\n",(0,a.jsxs)(n.p,{children:["Before Hooks, state was available only in class components. ",(0,a.jsx)(n.code,{children:"useState"})," made state management simple and powerful in function components."]}),"\n",(0,a.jsxs)(n.h2,{id:"what-is-usestate",children:["What is ",(0,a.jsx)(n.code,{children:"useState"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"useState"})," is a React Hook that lets you add state variables to functional components."]}),"\n",(0,a.jsxs)(n.h2,{id:"why-do-we-need-usestate",children:["Why Do We Need ",(0,a.jsx)(n.code,{children:"useState"})]}),"\n",(0,a.jsx)(n.p,{children:"React components:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Render UI based on data (state)"}),"\n",(0,a.jsx)(n.li,{children:"Need to remember values between renders"}),"\n",(0,a.jsx)(n.li,{children:"Must re-render when data changes"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"useState"})," solves this by:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Storing data across renders"}),"\n",(0,a.jsx)(n.li,{children:"Triggering re-render when state updates"}),"\n"]}),"\n",(0,a.jsxs)(n.h2,{id:"syntax-of-usestate",children:["Syntax of ",(0,a.jsx)(n.code,{children:"useState"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'import { useState } from "react";\r\n\r\nconst [value, setValue] = useState(initialValue);\n'})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"value"})," \u2192 current state"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"setValue"})," \u2192 function to update state"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"initialValue"})," \u2192 initial state (only used on first render)"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"how-usestate-works-internally-concept",children:"How useState Works Internally (Concept)"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"React stores the state"}),"\n",(0,a.jsxs)(n.li,{children:["When setState is called:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"React schedules a re-render"}),"\n",(0,a.jsx)(n.li,{children:"Component runs again"}),"\n",(0,a.jsx)(n.li,{children:"New state value is used"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"State updates are asynchronous and batched."}),"\n",(0,a.jsx)(n.h2,{id:"simple-example--counter",children:"Simple Example \u2013 Counter"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'import { useState } from "react";\r\n\r\nfunction Counter() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    <div>\r\n      <h2>Count: {count}</h2>\r\n\r\n      <button onClick={() => setCount(count + 1)}>+</button>\r\n      <button onClick={() => setCount(count - 1)}>-</button>\r\n      <button onClick={() => setCount(0)}>Reset</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Counter;\n'})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"count"})," stores the current value"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"setCount"})," updates state"]}),"\n",(0,a.jsx)(n.li,{children:"Updating state causes re-render"}),"\n",(0,a.jsx)(n.li,{children:"UI updates automatically"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"updating-state-based-on-previous-state",children:"Updating State Based on Previous State"}),"\n",(0,a.jsx)(n.p,{children:"Wrong way (can cause bugs)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"setCount(count + 1);\r\nsetCount(count + 1);\n"})}),"\n",(0,a.jsx)(n.p,{children:"Correct way"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"setCount((prevCount) => prevCount + 1);\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Uses previous state safely"}),"\n",(0,a.jsx)(n.li,{children:"Avoids stale values"}),"\n",(0,a.jsx)(n.li,{children:"Recommended for async updates"}),"\n"]}),"\n",(0,a.jsxs)(n.h2,{id:"usestate-with-objects",children:[(0,a.jsx)(n.code,{children:"useState"})," with Objects"]}),"\n",(0,a.jsx)(n.p,{children:"Initial State"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'const [user, setUser] = useState({\r\n  name: "John",\r\n  age: 25,\r\n});\n'})}),"\n",(0,a.jsx)(n.p,{children:"Updating Object State"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"setUser((prevUser) => ({\r\n  ...prevUser,\r\n  age: 26,\r\n}));\n"})}),"\n",(0,a.jsx)(n.p,{children:"Explanation"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"React does not merge objects automatically"}),"\n",(0,a.jsx)(n.li,{children:"Spread operator prevents mutation"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"usestate-with-arrays",children:"useState with Arrays"}),"\n",(0,a.jsx)(n.p,{children:"Initial State"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const [items, setItems] = useState([]);\n"})}),"\n",(0,a.jsx)(n.p,{children:"Add Item"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"setItems((prevItems) => [...prevItems, newItem]);\n"})}),"\n",(0,a.jsx)(n.p,{children:"Remove Item"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"setItems((prevItems) => prevItems.filter((item) => item.id !== id));\n"})}),"\n",(0,a.jsx)(n.p,{children:"Explanation"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Never mutate arrays directly"}),"\n",(0,a.jsx)(n.li,{children:"Always return a new array"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"lazy-initialization-performance-optimization",children:"Lazy Initialization (Performance Optimization)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const [count, setCount] = useState(() => {\r\n  return expensiveCalculation();\r\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:"Explanation"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Function runs only once"}),"\n",(0,a.jsx)(n.li,{children:"Improves performance for heavy initialization"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"common-mistakes",children:"Common Mistakes"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Mutating state directly"}),"\n",(0,a.jsx)(n.li,{children:"Expecting immediate state updates"}),"\n",(0,a.jsx)(n.li,{children:"Forgetting to copy objects/arrays"}),"\n",(0,a.jsx)(n.li,{children:"Overusing state"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);