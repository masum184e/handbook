"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[37080],{28453(e,n,r){r.d(n,{R:()=>l,x:()=>a});var s=r(96540);const t={},i=s.createContext(t);function l(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(i.Provider,{value:n},e.children)}},36405(e,n,r){r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>o,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"rust/Data Structure/Enums","title":"Enums","description":"An enum (enumeration) in Rust lets you define a type that can be one of several different variants, where each variant can store different types of data.","source":"@site/docs/rust/11. Data Structure/7. Enums.md","sourceDirName":"rust/11. Data Structure","slug":"/rust/Data Structure/Enums","permalink":"/handbook/docs/rust/Data Structure/Enums","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{}}');var t=r(74848),i=r(28453);const l={},a=void 0,d={},c=[{value:"Key Characteristics of Enums",id:"key-characteristics-of-enums",level:2},{value:"Creating Enum Values",id:"creating-enum-values",level:2},{value:"Enums with Data (Very Important)",id:"enums-with-data-very-important",level:2},{value:"Variants Carrying Values",id:"variants-carrying-values",level:3},{value:"Creating Values",id:"creating-values",level:3},{value:"Pattern Matching with Enums",id:"pattern-matching-with-enums",level:2},{value:"Using <code>match</code>",id:"using-match",level:3},{value:"Enums vs Structs",id:"enums-vs-structs",level:2},{value:"Enums with Methods (impl)",id:"enums-with-methods-impl",level:2},{value:"<code>Option&lt;T&gt;</code> \u2013 The Most Common Enum",id:"optiont--the-most-common-enum",level:2},{value:"<code>Result&lt;T, E&gt;</code> \u2013 Error Handling Enum",id:"resultt-e--error-handling-enum",level:2},{value:"Enums with if let",id:"enums-with-if-let",level:2},{value:"Enums and Ownership",id:"enums-and-ownership",level:2},{value:"Memory Layout of Enums (Conceptual)",id:"memory-layout-of-enums-conceptual",level:2},{value:"Summary",id:"summary",level:2}];function h(e){const n={blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"An enum (enumeration) in Rust lets you define a type that can be one of several different variants, where each variant can store different types of data."}),"\n",(0,t.jsx)(n.p,{children:"Think of an enum as:"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"\u201cA value that must be exactly one of a known set of possibilities.\u201d"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"enum Direction {\r\n    North,\r\n    South,\r\n    East,\r\n    West,\r\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["A variable of type ",(0,t.jsx)(n.code,{children:"Direction"})," can be only one of these four values."]}),"\n",(0,t.jsx)(n.h2,{id:"key-characteristics-of-enums",children:"Key Characteristics of Enums"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Feature"}),(0,t.jsx)(n.th,{children:"Enum"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Variants"}),(0,t.jsx)(n.td,{children:"Multiple"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Data in variants"}),(0,t.jsx)(n.td,{children:"Optional"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Types per variant"}),(0,t.jsx)(n.td,{children:"Different allowed"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Safety"}),(0,t.jsx)(n.td,{children:"Compile-time checked"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Pattern matching"}),(0,t.jsx)(n.td,{children:"Powerful"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Memory"}),(0,t.jsx)(n.td,{children:"Size = largest variant"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"creating-enum-values",children:"Creating Enum Values"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"let d1 = Direction::North;\r\nlet d2 = Direction::West;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"EnumName::Variant"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"enums-with-data-very-important",children:"Enums with Data (Very Important)"}),"\n",(0,t.jsx)(n.h3,{id:"variants-carrying-values",children:"Variants Carrying Values"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"enum Message {\r\n    Quit,\r\n    Write(String),\r\n    Move { x: i32, y: i32 },\r\n    ChangeColor(i32, i32, i32),\r\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Each variant stores different data types."}),"\n",(0,t.jsx)(n.h3,{id:"creating-values",children:"Creating Values"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let m1 = Message::Quit;\r\nlet m2 = Message::Write(String::from("Hello"));\r\nlet m3 = Message::Move { x: 10, y: 20 };\r\nlet m4 = Message::ChangeColor(255, 0, 0);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"pattern-matching-with-enums",children:"Pattern Matching with Enums"}),"\n",(0,t.jsxs)(n.h3,{id:"using-match",children:["Using ",(0,t.jsx)(n.code,{children:"match"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'fn process_message(msg: Message) {\r\n    match msg {\r\n        Message::Quit => println!("Quit"),\r\n        Message::Write(text) => println!("Text: {}", text),\r\n        Message::Move { x, y } => println!("Move to {}, {}", x, y),\r\n        Message::ChangeColor(r, g, b) =>\r\n            println!("Color: {}, {}, {}", r, g, b),\r\n    }\r\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"match"})," is exhaustive \u2014 all cases must be handled."]}),"\n",(0,t.jsx)(n.h2,{id:"enums-vs-structs",children:"Enums vs Structs"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Feature"}),(0,t.jsx)(n.th,{children:"Enum"}),(0,t.jsx)(n.th,{children:"Struct"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Multiple shapes"}),(0,t.jsx)(n.td,{children:"\u2705"}),(0,t.jsx)(n.td,{children:"\u274c"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Named fields"}),(0,t.jsx)(n.td,{children:"Optional"}),(0,t.jsx)(n.td,{children:"\u2705"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Best for"}),(0,t.jsx)(n.td,{children:"Variants"}),(0,t.jsx)(n.td,{children:"Single structure"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"Use enums when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A value can be one of many forms"}),"\n",(0,t.jsx)(n.li,{children:"Each form has different data"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"enums-with-methods-impl",children:"Enums with Methods (impl)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'impl Message {\r\n    fn call(&self) {\r\n        match self {\r\n            Message::Quit => println!("Quit"),\r\n            Message::Write(text) => println!("Writing {}", text),\r\n            _ => println!("Other message"),\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Usage:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"m2.call();\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"optiont--the-most-common-enum",children:[(0,t.jsx)(n.code,{children:"Option<T>"})," \u2013 The Most Common Enum"]}),"\n",(0,t.jsx)(n.p,{children:"Rust does not have null. Instead:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"enum Option<T> {\r\n    Some(T),\r\n    None,\r\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let name: Option<String> = Some(String::from("Rust"));\r\nlet empty: Option<String> = None;\n'})}),"\n",(0,t.jsx)(n.p,{children:"Using Option"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'match name {\r\n    Some(value) => println!("Name: {}", value),\r\n    None => println!("No name"),\r\n}\n'})}),"\n",(0,t.jsxs)(n.h2,{id:"resultt-e--error-handling-enum",children:[(0,t.jsx)(n.code,{children:"Result<T, E>"})," \u2013 Error Handling Enum"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"enum Result<T, E> {\r\n    Ok(T),\r\n    Err(E),\r\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'fn divide(a: i32, b: i32) -> Result<i32, String> {\r\n    if b == 0 {\r\n        Err(String::from("Cannot divide by zero"))\r\n    } else {\r\n        Ok(a / b)\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Usage:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'match divide(10, 2) {\r\n    Ok(result) => println!("Result: {}", result),\r\n    Err(err) => println!("Error: {}", err),\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"enums-with-if-let",children:"Enums with if let"}),"\n",(0,t.jsx)(n.p,{children:"For simpler cases:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let msg = Message::Quit;\r\n\r\nif let Message::Quit = msg {\r\n    println!("Exiting...");\r\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Cleaner than ",(0,t.jsx)(n.code,{children:"match"})," when you only care about one case."]}),"\n",(0,t.jsx)(n.h2,{id:"enums-and-ownership",children:"Enums and Ownership"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let msg = Message::Write(String::from("Hello"));\r\n\r\nmatch msg {\r\n    Message::Write(text) => println!("{}", text),\r\n    _ => (),\r\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"text"})," is moved here."]}),"\n",(0,t.jsx)(n.h2,{id:"memory-layout-of-enums-conceptual",children:"Memory Layout of Enums (Conceptual)"}),"\n",(0,t.jsx)(n.p,{children:"Enums store:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A tag (which variant?)"}),"\n",(0,t.jsx)(n.li,{children:"Data for the largest variant"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Efficient and predictable."}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Enums define a type with multiple variants"}),"\n",(0,t.jsx)(n.li,{children:"Variants can hold different data"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"match"})," ensures all cases are handled"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Option"})," and ",(0,t.jsx)(n.code,{children:"Result"})," are enums"]}),"\n",(0,t.jsx)(n.li,{children:"Extremely powerful and safe"}),"\n"]})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}}}]);