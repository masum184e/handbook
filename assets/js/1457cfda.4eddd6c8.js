"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[4202],{2273(e,n,r){r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"typescript/Advance Types","title":"Advance Types","description":"Literal Types","source":"@site/docs/typescript/5. Advance Types.md","sourceDirName":"typescript","slug":"/typescript/Advance Types","permalink":"/handbook/docs/typescript/Advance Types","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{},"sidebar":"typescriptSidebar","previous":{"title":"Objects","permalink":"/handbook/docs/typescript/Objects"},"next":{"title":"Generics","permalink":"/handbook/docs/typescript/Generics"}}');var s=r(4848),t=r(8453);const l={},a=void 0,d={},o=[{value:"Literal Types",id:"literal-types",level:2},{value:"Type Narrowing",id:"type-narrowing",level:2},{value:"Ways to Narrow Types",id:"ways-to-narrow-types",level:3},{value:"Narrowing with typeof",id:"narrowing-with-typeof",level:3},{value:"Narrowing with <code>instanceof</code>",id:"narrowing-with-instanceof",level:3},{value:"Narrowing with Type Guards (Custom Functions)",id:"narrowing-with-type-guards-custom-functions",level:3},{value:"Mapped Types",id:"mapped-types",level:2},{value:"Basic Mapped Types",id:"basic-mapped-types",level:3},{value:"Built-in Mapped Types (<code>Readonly</code>, <code>Partial</code>, <code>Required</code>)",id:"built-in-mapped-types-readonly-partial-required",level:3},{value:"Remapping Keys",id:"remapping-keys",level:3},{value:"Conditional Types",id:"conditional-types",level:2},{value:"Basic Conditional Type",id:"basic-conditional-type",level:3},{value:"Extracting Return Types",id:"extracting-return-types",level:3},{value:"Conditional Type with Unions (Distributive Behavior)",id:"conditional-type-with-unions-distributive-behavior",level:3},{value:"Filtering Types",id:"filtering-types",level:3},{value:"Conditional Type with <code>infer</code>",id:"conditional-type-with-infer",level:3},{value:"Utility Types",id:"utility-types",level:2},{value:"<code>Partial&lt;T&gt;</code>",id:"partialt",level:3},{value:"<code>Required&lt;T&gt;</code>",id:"requiredt",level:3},{value:"<code>Readonly&lt;T&gt;</code>",id:"readonlyt",level:3},{value:"<code>Pick&lt;T, K&gt;</code>",id:"pickt-k",level:3},{value:"<code>Omit&lt;T, K&gt;</code>",id:"omitt-k",level:3},{value:"<code>Record&lt;K, T&gt;</code>",id:"recordk-t",level:3},{value:"<code>Exclude&lt;T, U&gt;</code>",id:"excludet-u",level:3},{value:"<code>Extract&lt;T, U&gt;</code>",id:"extractt-u",level:3}];function c(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"literal-types",children:"Literal Types"}),"\n",(0,s.jsxs)(n.p,{children:["In TypeScript, Literal Types allow you to specify exact values that a variable can hold, rather than just a general type like ",(0,s.jsx)(n.code,{children:"string"})," or ",(0,s.jsx)(n.code,{children:"number"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"string"})," type means any string (",(0,s.jsx)(n.code,{children:'"hello"'}),", ",(0,s.jsx)(n.code,{children:'"world"'}),", ",(0,s.jsx)(n.code,{children:'"foo"'}),")."]}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"string literal type"})," means only one specific string (like ",(0,s.jsx)(n.code,{children:'"hello"'}),")."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This is extremely useful when you want to restrict values to a limited set of possibilities."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'let direction: "north" | "south" | "east" | "west";\r\n\r\ndirection = "north"; // \u2705 allowed\r\ndirection = "south"; // \u2705 allowed\r\ndirection = "up"; // \u274c Error: Type \'"up"\' is not assignable\n'})}),"\n",(0,s.jsx)(n.h2,{id:"type-narrowing",children:"Type Narrowing"}),"\n",(0,s.jsxs)(n.p,{children:["In TypeScript, narrowing means reducing a broad type (like ",(0,s.jsx)(n.code,{children:"string | number"}),") into a more specific type at runtime based on some checks."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'function printLength(value: string | number) {\r\n  if (typeof value === "string") {\r\n    // TypeScript knows value is a string here\r\n    console.log(value.length);\r\n  } else {\r\n    // Here, value must be a number\r\n    console.log(value.toFixed(2));\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"ways-to-narrow-types",children:"Ways to Narrow Types"}),"\n",(0,s.jsx)(n.p,{children:"There are several techniques:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"typeof"})," checks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"instanceof"})," checks"]}),"\n",(0,s.jsxs)(n.li,{children:["Custom Type Guards (",(0,s.jsx)(n.code,{children:"value is Type"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"narrowing-with-typeof",children:"Narrowing with typeof"}),"\n",(0,s.jsxs)(n.p,{children:["The typeof operator is used to check primitive types (",(0,s.jsx)(n.code,{children:"string"}),", ",(0,s.jsx)(n.code,{children:"number"}),", ",(0,s.jsx)(n.code,{children:"boolean"}),", ",(0,s.jsx)(n.code,{children:"bigint"}),", ",(0,s.jsx)(n.code,{children:"symbol"}),", ",(0,s.jsx)(n.code,{children:"undefined"}),", and ",(0,s.jsx)(n.code,{children:"object"}),")."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'function padLeft(value: string, padding: string | number) {\r\n  if (typeof padding === "number") {\r\n    return " ".repeat(padding) + value; // padding is number\r\n  } else {\r\n    return padding + value; // padding is string\r\n  }\r\n}\r\n\r\nconsole.log(padLeft("Hello", 4)); // "    Hello"\r\nconsole.log(padLeft("Hello", ">> ")); // ">> Hello"\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"typeof"})," works great for primitives."]}),"\n",(0,s.jsxs)(n.li,{children:["It won\u2019t help for objects or classes \u2014 that\u2019s where ",(0,s.jsx)(n.code,{children:"instanceof"})," comes in."]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"narrowing-with-instanceof",children:["Narrowing with ",(0,s.jsx)(n.code,{children:"instanceof"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"instanceof"})," is used to check whether an object is created from a particular class or constructor function."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'class Dog {\r\n  bark() {\r\n    console.log("Woof!");\r\n  }\r\n}\r\n\r\nclass Cat {\r\n  meow() {\r\n    console.log("Meow!");\r\n  }\r\n}\r\n\r\nfunction makeSound(animal: Dog | Cat) {\r\n  if (animal instanceof Dog) {\r\n    animal.bark(); // animal is narrowed to Dog\r\n  } else {\r\n    animal.meow(); // animal is narrowed to Cat\r\n  }\r\n}\r\n\r\nmakeSound(new Dog()); // Woof!\r\nmakeSound(new Cat()); // Meow!\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"instanceof"})," when dealing with classes and objects."]}),"\n",(0,s.jsxs)(n.li,{children:["It doesn\u2019t work for primitives (use ",(0,s.jsx)(n.code,{children:"typeof"})," instead)."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"narrowing-with-type-guards-custom-functions",children:"Narrowing with Type Guards (Custom Functions)"}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes, you need your own checks for more complex types.\r\nA type guard is a function that returns a type predicate (",(0,s.jsx)(n.code,{children:"param is Type"}),")."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type Fish = { swim: () => void };\r\ntype Bird = { fly: () => void };\r\n\r\nfunction isFish(animal: Fish | Bird): animal is Fish {\r\n  return (animal as Fish).swim !== undefined;\r\n}\r\n\r\nfunction move(animal: Fish | Bird) {\r\n  if (isFish(animal)) {\r\n    animal.swim(); // animal is narrowed to Fish\r\n  } else {\r\n    animal.fly(); // animal is narrowed to Bird\r\n  }\r\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"isFish"})," is a user-defined type guard."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"animal is Fish"})," return type tells TypeScript that when this function returns ",(0,s.jsx)(n.code,{children:"true"}),", the variable is of type ",(0,s.jsx)(n.code,{children:"Fish"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"mapped-types",children:"Mapped Types"}),"\n",(0,s.jsx)(n.p,{children:"A Mapped Type lets you create a new type by transforming each property of an existing type according to some rule."}),"\n",(0,s.jsx)(n.p,{children:"Think of it as: Take a type \u2192 iterate over its keys \u2192 create a new type with modified properties."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type OptionsFlags<Type> = {\r\n  [Property in keyof Type]: boolean;\r\n};\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"keyof Type"})," \u2192 gets all property names of ",(0,s.jsx)(n.code,{children:"Type"})," as a union."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Property in keyof Type"})," \u2192 iterate over each key."]}),"\n",(0,s.jsx)(n.li,{children:"The mapped type assigns new property types."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"basic-mapped-types",children:"Basic Mapped Types"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type Features = {\r\n  darkMode: () => void;\r\n  multiLanguage: () => void;\r\n};\r\n\r\ntype FeatureFlags = {\r\n  [K in keyof Features]: boolean;\r\n};\r\n\r\n// Equivalent to:\r\ntype FeatureFlagsManual = {\r\n  darkMode: boolean;\r\n  multiLanguage: boolean;\r\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Every property of ",(0,s.jsx)(n.code,{children:"Features"})," got transformed into ",(0,s.jsx)(n.code,{children:"boolean"}),"."]}),"\n",(0,s.jsxs)(n.h3,{id:"built-in-mapped-types-readonly-partial-required",children:["Built-in Mapped Types (",(0,s.jsx)(n.code,{children:"Readonly"}),", ",(0,s.jsx)(n.code,{children:"Partial"}),", ",(0,s.jsx)(n.code,{children:"Required"}),")"]}),"\n",(0,s.jsx)(n.p,{children:"TypeScript provides some utility types built using mapped types."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"ReadOnly"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type Readonly<T> = {\r\n  readonly [P in keyof T]: T[P];\r\n};\r\n\r\ntype User = {\r\n  id: number;\r\n  name: string;\r\n};\r\n\r\ntype ReadonlyUser = Readonly<User>;\r\n\r\n// Equivalent:\r\ntype ReadonlyUserManual = {\r\n  readonly id: number;\r\n  readonly name: string;\r\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Partial"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type Partial<T> = {\r\n  [P in keyof T]?: T[P];\r\n};\r\n\r\ntype UserPartial = Partial<User>;\r\n\r\n// Equivalent:\r\ntype UserPartialManual = {\r\n  id?: number;\r\n  name?: string;\r\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"All properties are now optional."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Required"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type Required<T> = {\r\n  [P in keyof T]-?: T[P];\r\n};\r\n\r\ntype UserOptional = {\r\n  id?: number;\r\n  name?: string;\r\n};\r\n\r\ntype UserRequired = Required<UserOptional>;\r\n\r\n// Equivalent:\r\ntype UserRequiredManual = {\r\n  id: number;\r\n  name: string;\r\n};\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"-?"})," removes the optional modifier."]}),"\n",(0,s.jsx)(n.li,{children:"So all properties are required."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"remapping-keys",children:"Remapping Keys"}),"\n",(0,s.jsxs)(n.p,{children:["You can also remap keys using ",(0,s.jsx)(n.code,{children:"as"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type Getters<T> = {\r\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\r\n};\r\n\r\ntype Person = {\r\n  name: string;\r\n  age: number;\r\n};\r\n\r\ntype PersonGetters = Getters<Person>;\r\n\r\n// Equivalent:\r\ntype PersonGettersManual = {\r\n  getName: () => string;\r\n  getAge: () => number;\r\n};\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Each key is transformed into a new key (",(0,s.jsx)(n.code,{children:"getName"}),", ",(0,s.jsx)(n.code,{children:"getAge"}),")."]}),"\n",(0,s.jsx)(n.li,{children:"Each value becomes a function returning the original property type."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"conditional-types",children:"Conditional Types"}),"\n",(0,s.jsx)(n.p,{children:"A Conditional Type looks like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"T extends U ? X : Y\n"})}),"\n",(0,s.jsx)(n.p,{children:"Meaning:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"T"})," can be assigned to ",(0,s.jsx)(n.code,{children:"U"})," \u2192 return ",(0,s.jsx)(n.code,{children:"X"})]}),"\n",(0,s.jsxs)(n.li,{children:["Otherwise \u2192 return ",(0,s.jsx)(n.code,{children:"Y"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This is checked at compile-time, not at runtime."}),"\n",(0,s.jsx)(n.h3,{id:"basic-conditional-type",children:"Basic Conditional Type"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'type IsString<T> = T extends string ? "Yes" : "No";\r\n\r\ntype A = IsString<string>; // "Yes"\r\ntype B = IsString<number>; // "No"\n'})}),"\n",(0,s.jsx)(n.p,{children:"You can use this to create type-level conditions."}),"\n",(0,s.jsx)(n.h3,{id:"extracting-return-types",children:"Extracting Return Types"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type GetReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\r\n\r\ntype A = GetReturnType<() => number>; // number\r\ntype B = GetReturnType<(x: string) => boolean>; // boolean\r\ntype C = GetReturnType<string>; // never\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"infer R"})," \u2192 captures the return type of the function."]}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"T"})," is a function, return its return type. Otherwise \u2192 ",(0,s.jsx)(n.code,{children:"never"}),".\r\nThis is how TypeScript\u2019s built-in ",(0,s.jsx)(n.code,{children:"ReturnType<T>"})," works."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"conditional-type-with-unions-distributive-behavior",children:"Conditional Type with Unions (Distributive Behavior)"}),"\n",(0,s.jsx)(n.p,{children:"Conditional types are distributive over unions."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type ToArray<T> = T extends any ? T[] : never;\r\n\r\ntype A = ToArray<number>; // number[]\r\ntype B = ToArray<number | string>; // number[] | string[]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When you pass ",(0,s.jsx)(n.code,{children:"number | string"}),", TypeScript distributes: ",(0,s.jsx)(n.code,{children:"ToArray<number> | ToArray<string>"})," \u2192 ",(0,s.jsx)(n.code,{children:"number[] | string[]"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"This is powerful, but sometimes you don\u2019t want distributive behavior \u2192 you can wrap in square brackets:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type ToArrayNonDistributive<T> = [T] extends [any] ? T[] : never;\r\n\r\ntype C = ToArrayNonDistributive<number | string>; // (number | string)[]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"filtering-types",children:"Filtering Types"}),"\n",(0,s.jsx)(n.p,{children:"You can use conditional types to filter properties."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'type Exclude<T, U> = T extends U ? never : T;\r\n\r\ntype A = Exclude<"a" | "b" | "c", "a">; // "b" | "c"\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:['``"a"',(0,s.jsx)(n.code,{children:"extends"}),'"a"',(0,s.jsx)(n.code,{children:"\u2192 becomes"}),"never` \u2192 excluded."]}),"\n",(0,s.jsxs)(n.li,{children:['``"b"',(0,s.jsx)(n.code,{children:"and"}),'"c"` remain.']}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"conditional-type-with-infer",children:["Conditional Type with ",(0,s.jsx)(n.code,{children:"infer"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"infer"})," keyword lets you extract a type inside a conditional."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type FirstElement<T> = T extends [infer U, ...any[]] ? U : never;\r\n\r\ntype A = FirstElement<[string, number, boolean]>; // string\r\ntype B = FirstElement<[]>; // never\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"T"})," is a tuple, extract the first element type."]}),"\n",(0,s.jsxs)(n.li,{children:["If not, return ",(0,s.jsx)(n.code,{children:"never"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"utility-types",children:"Utility Types"}),"\n",(0,s.jsx)(n.h3,{id:"partialt",children:(0,s.jsx)(n.code,{children:"Partial<T>"})}),"\n",(0,s.jsx)(n.p,{children:"Makes all properties optional."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type User = {\r\n  id: number;\r\n  name: string;\r\n  age: number;\r\n};\r\n\r\ntype PartialUser = Partial<User>;\r\n// Equivalent:\r\ntype PartialUserManual = {\r\n  id?: number;\r\n  name?: string;\r\n  age?: number;\r\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"requiredt",children:(0,s.jsx)(n.code,{children:"Required<T>"})}),"\n",(0,s.jsxs)(n.p,{children:["Makes all properties required (opposite of ",(0,s.jsx)(n.code,{children:"Partial"}),")."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type UserOptional = {\r\n  id?: number;\r\n  name?: string;\r\n};\r\n\r\ntype UserRequired = Required<UserOptional>;\r\n// Equivalent:\r\ntype UserRequiredManual = {\r\n  id: number;\r\n  name: string;\r\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"readonlyt",children:(0,s.jsx)(n.code,{children:"Readonly<T>"})}),"\n",(0,s.jsx)(n.p,{children:"Makes all properties read-only."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type User = {\r\n  id: number;\r\n  name: string;\r\n};\r\n\r\ntype ReadonlyUser = Readonly<User>;\r\n// Equivalent:\r\ntype ReadonlyUserManual = {\r\n  readonly id: number;\r\n  readonly name: string;\r\n};\r\n\r\nconst user: ReadonlyUser = { id: 1, name: \"Alice\" };\r\nuser.id = 2; // \u274c Error: Cannot assign to 'id'\n"})}),"\n",(0,s.jsx)(n.h3,{id:"pickt-k",children:(0,s.jsx)(n.code,{children:"Pick<T, K>"})}),"\n",(0,s.jsx)(n.p,{children:"Creates a type by picking a subset of properties."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'type User = {\r\n  id: number;\r\n  name: string;\r\n  age: number;\r\n};\r\n\r\ntype UserPreview = Pick<User, "id" | "name">;\r\n// Equivalent:\r\ntype UserPreviewManual = {\r\n  id: number;\r\n  name: string;\r\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"omitt-k",children:(0,s.jsx)(n.code,{children:"Omit<T, K>"})}),"\n",(0,s.jsx)(n.p,{children:"Creates a type by removing specific properties."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'type User = {\r\n  id: number;\r\n  name: string;\r\n  age: number;\r\n};\r\n\r\ntype UserWithoutAge = Omit<User, "age">;\r\n// Equivalent:\r\ntype UserWithoutAgeManual = {\r\n  id: number;\r\n  name: string;\r\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"recordk-t",children:(0,s.jsx)(n.code,{children:"Record<K, T>"})}),"\n",(0,s.jsx)(n.p,{children:"Constructs a type with keys K and values T."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'type Roles = "admin" | "editor" | "viewer";\r\n\r\ntype RolePermissions = Record<Roles, boolean>;\r\n// Equivalent:\r\ntype RolePermissionsManual = {\r\n  admin: boolean;\r\n  editor: boolean;\r\n  viewer: boolean;\r\n};\r\n\r\nconst permissions: RolePermissions = {\r\n  admin: true,\r\n  editor: false,\r\n  viewer: true,\r\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"excludet-u",children:(0,s.jsx)(n.code,{children:"Exclude<T, U>"})}),"\n",(0,s.jsx)(n.p,{children:"Excludes types from a union."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'type Letters = "a" | "b" | "c";\r\n\r\ntype WithoutA = Exclude<Letters, "a">;\r\n// "b" | "c"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"extractt-u",children:(0,s.jsx)(n.code,{children:"Extract<T, U>"})}),"\n",(0,s.jsx)(n.p,{children:"Extracts types that are assignable to U."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'type Letters = "a" | "b" | "c";\r\n\r\ntype OnlyA = Extract<Letters, "a" | "d">;\r\n// "a"\n'})}),"\n",(0,s.jsx)(n.p,{children:"Opposite of Exclude."})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453(e,n,r){r.d(n,{R:()=>l,x:()=>a});var i=r(6540);const s={},t=i.createContext(s);function l(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);