"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[61476],{11776(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"reactjs/Expensive Computation","title":"Expensive Computation","description":"useMemo is a React hook used to cache the result of an expensive computation so that it doesn\u2019t run again on every render unless its dependencies change.","source":"@site/docs/reactjs/24. Expensive Computation.md","sourceDirName":"reactjs","slug":"/reactjs/Expensive Computation","permalink":"/handbook/docs/reactjs/Expensive Computation","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":25,"frontMatter":{"sidebar_position":25},"sidebar":"reactjsApiSidebar","previous":{"title":"Memoizing Components","permalink":"/handbook/docs/reactjs/Memoizing Components"},"next":{"title":"Optimizing Event Handlers","permalink":"/handbook/docs/reactjs/Optimizing Event Handlers"}}');var t=s(74848),i=s(28453);const r={sidebar_position:25},l=void 0,c={},a=[{value:"When computations become \u201cexpensive\u201d",id:"when-computations-become-expensive",level:2},{value:"Example without <code>useMemo</code> (problem)",id:"example-without-usememo-problem",level:2},{value:"Optimized version using <code>useMemo</code>",id:"optimized-version-using-usememo",level:2},{value:"How <code>useMemo</code> works internally (simplified)",id:"how-usememo-works-internally-simplified",level:2},{value:"Common real-world example: filtering a large list",id:"common-real-world-example-filtering-a-large-list",level:2},{value:"<code>useMemo</code> vs <code>useCallback</code>",id:"usememo-vs-usecallback",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"useMemo"})," is a React hook used to cache the result of an expensive computation so that it doesn\u2019t run again on every render unless its dependencies change."]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Recalculate values only when the inputs change, not on every render."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["By default, React re-runs all code inside a component every time it re-renders\u2014even if the calculation result would be the same. ",(0,t.jsx)(n.code,{children:"useMemo"})," prevents that waste."]}),"\n",(0,t.jsx)(n.h2,{id:"when-computations-become-expensive",children:"When computations become \u201cexpensive\u201d"}),"\n",(0,t.jsx)(n.p,{children:"A computation is expensive when it:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Iterates over large arrays (filtering, sorting, reducing)"}),"\n",(0,t.jsx)(n.li,{children:"Performs complex math"}),"\n",(0,t.jsx)(n.li,{children:"Runs frequently due to unrelated state changes"}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"example-without-usememo-problem",children:["Example without ",(0,t.jsx)(n.code,{children:"useMemo"})," (problem)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'function ExpensiveComponent({ items }) {\r\n  const [count, setCount] = React.useState(0);\r\n\r\n  const total = items.reduce((sum, item) => {\r\n    console.log("Calculating total...");\r\n    return sum + item.price;\r\n  }, 0);\r\n\r\n  return (\r\n    <>\r\n      <h2>Total: {total}</h2>\r\n      <button onClick={() => setCount(count + 1)}>Re-render ({count})</button>\r\n    </>\r\n  );\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"What\u2019s happening?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Clicking the button updates ",(0,t.jsx)(n.code,{children:"count"})]}),"\n",(0,t.jsx)(n.li,{children:"Component re-renders"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"reduce"})," runs again \u274c"]}),"\n",(0,t.jsxs)(n.li,{children:["Even though ",(0,t.jsx)(n.code,{children:"items"})," never changed"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"optimized-version-using-usememo",children:["Optimized version using ",(0,t.jsx)(n.code,{children:"useMemo"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'function ExpensiveComponent({ items }) {\r\n  const [count, setCount] = React.useState(0);\r\n\r\n  const total = React.useMemo(() => {\r\n    console.log("Calculating total...");\r\n    return items.reduce((sum, item) => sum + item.price, 0);\r\n  }, [items]);\r\n\r\n  return (\r\n    <>\r\n      <h2>Total: {total}</h2>\r\n      <button onClick={() => setCount(count + 1)}>Re-render ({count})</button>\r\n    </>\r\n  );\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Why this works"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"useMemo"})," remembers the computed value"]}),"\n",(0,t.jsxs)(n.li,{children:["The function runs only when ",(0,t.jsx)(n.code,{children:"items"})," changes"]}),"\n",(0,t.jsxs)(n.li,{children:["Updating ",(0,t.jsx)(n.code,{children:"count"})," no longer triggers recalculation"]}),"\n",(0,t.jsx)(n.li,{children:"Faster renders, less CPU usage"}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"how-usememo-works-internally-simplified",children:["How ",(0,t.jsx)(n.code,{children:"useMemo"})," works internally (simplified)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"useMemo(() => computeValue(), [dep1, dep2]);\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"dep1"})," or ",(0,t.jsx)(n.code,{children:"dep2"})," changed \u2192 recompute"]}),"\n",(0,t.jsx)(n.li,{children:"Otherwise \u2192 return cached value"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"common-real-world-example-filtering-a-large-list",children:"Common real-world example: filtering a large list"}),"\n",(0,t.jsxs)(n.p,{children:["Without ",(0,t.jsx)(n.code,{children:"useMemo"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"const filteredUsers = users.filter((user) => user.active);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["With ",(0,t.jsx)(n.code,{children:"useMemo"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"const filteredUsers = React.useMemo(() => {\r\n  return users.filter((user) => user.active);\r\n}, [users]);\n"})}),"\n",(0,t.jsx)(n.p,{children:"Only recalculates when users changes."}),"\n",(0,t.jsxs)(n.h2,{id:"usememo-vs-usecallback",children:[(0,t.jsx)(n.code,{children:"useMemo"})," vs ",(0,t.jsx)(n.code,{children:"useCallback"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"useMemo"})," \u2192 memoizes a value"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"useCallback"})," \u2192 memoizes a function"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"const value = useMemo(() => compute(), [deps]);\r\nconst fn = useCallback(() => doSomething(), [deps]);\n"})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453(e,n,s){s.d(n,{R:()=>r,x:()=>l});var o=s(96540);const t={},i=o.createContext(t);function r(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);