"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[24049],{14772(e,n,i){i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>o,frontMatter:()=>t,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"rust/Lifetimes","title":"Lifetimes","description":"A lifetime describes the scope during which a reference is valid.","source":"@site/docs/rust/8. Lifetimes.md","sourceDirName":"rust","slug":"/rust/Lifetimes","permalink":"/handbook/docs/rust/Lifetimes","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{}}');var r=i(74848),l=i(28453);const t={},c=void 0,a={},d=[{value:"Why Lifetimes Exist",id:"why-lifetimes-exist",level:2},{value:"Lifetime Basics (Implicit Lifetimes)",id:"lifetime-basics-implicit-lifetimes",level:2},{value:"When Lifetimes Become Necessary",id:"when-lifetimes-become-necessary",level:2},{value:"Explicit Lifetime Annotations (Basic)",id:"explicit-lifetime-annotations-basic",level:2},{value:"Important Rule (This Is Key)",id:"important-rule-this-is-key",level:2},{value:"Lifetime Elision Rules (Compiler Magic)",id:"lifetime-elision-rules-compiler-magic",level:2},{value:"Rule 1: One input reference \u2192 output uses same lifetime",id:"rule-1-one-input-reference--output-uses-same-lifetime",level:3},{value:"Rule 2: <code>&amp;self</code> in methods gets its own lifetime",id:"rule-2-self-in-methods-gets-its-own-lifetime",level:3},{value:"Lifetimes with Structs (Intermediate)",id:"lifetimes-with-structs-intermediate",level:2},{value:"Struct Holding References",id:"struct-holding-references",level:3},{value:"Lifetimes in <code>impl</code> Blocks",id:"lifetimes-in-impl-blocks",level:2},{value:"Multiple Lifetimes (Intermediate)",id:"multiple-lifetimes-intermediate",level:2},{value:"Lifetimes + Mutable References",id:"lifetimes--mutable-references",level:2},{value:"Lifetime Bounds (Advanced)",id:"lifetime-bounds-advanced",level:2},{value:"Lifetimes with Traits (Advanced)",id:"lifetimes-with-traits-advanced",level:2},{value:"<code>&#39;static</code> Lifetime (Special Case)",id:"static-lifetime-special-case",level:2},{value:"Advanced: Lifetime vs Ownership (Key Insight)",id:"advanced-lifetime-vs-ownership-key-insight",level:2},{value:"Mental Model That Actually Works",id:"mental-model-that-actually-works",level:2},{value:"Why Lifetimes Matter",id:"why-lifetimes-matter",level:2}];function h(e){const n={br:"br",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"A lifetime describes the scope during which a reference is valid."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Every reference in Rust has a lifetime"}),"\n",(0,r.jsx)(n.li,{children:"Most of the time, the compiler infers it"}),"\n",(0,r.jsx)(n.li,{children:"Sometimes, you must explicitly tell the compiler how lifetimes relate"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Lifetimes do not change how long values live\r\nThey only describe relationships between references"}),"\n",(0,r.jsx)(n.h2,{id:"why-lifetimes-exist",children:"Why Lifetimes Exist"}),"\n",(0,r.jsx)(n.p,{children:"Without lifetimes, this would be allowed:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let r: &i32;\r\n\r\n{\r\n    let x = 5;\r\n    r = &x;\r\n}\r\n\r\nprintln!("{}", r); // \u274c use-after-free\n'})}),"\n",(0,r.jsx)(n.p,{children:"Rust prevents this by tracking lifetimes at compile time."}),"\n",(0,r.jsx)(n.h2,{id:"lifetime-basics-implicit-lifetimes",children:"Lifetime Basics (Implicit Lifetimes)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'fn print(s: &String) {\r\n    println!("{}", s);\r\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"You didn\u2019t write lifetimes, but Rust sees:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn print<'a>(s: &'a String)\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"'a"})," = lifetime of the reference"]}),"\n",(0,r.jsx)(n.li,{children:"The reference must be valid for the duration of the function call"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"when-lifetimes-become-necessary",children:"When Lifetimes Become Necessary"}),"\n",(0,r.jsx)(n.p,{children:"The Problem Case"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn longest(x: &str, y: &str) -> &str {\r\n    if x.len() > y.len() { x } else { y }\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"\u274c Compiler error: missing lifetime specifier"}),"\n",(0,r.jsx)(n.p,{children:"Why?"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Rust doesn\u2019t know whether the return value refers to ",(0,r.jsx)(n.code,{children:"x"})," or ",(0,r.jsx)(n.code,{children:"y"})]}),"\n",(0,r.jsx)(n.li,{children:"It needs to know how long the returned reference is valid"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"explicit-lifetime-annotations-basic",children:"Explicit Lifetime Annotations (Basic)"}),"\n",(0,r.jsx)(n.p,{children:"Correct Version"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\r\n    if x.len() > y.len() { x } else { y }\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"What this means"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"'a"})," is a generic lifetime parameter"]}),"\n",(0,r.jsxs)(n.li,{children:["The returned reference is valid as long as both ",(0,r.jsx)(n.code,{children:"x"})," and ",(0,r.jsx)(n.code,{children:"y"})," are valid"]}),"\n",(0,r.jsx)(n.li,{children:"The actual lifetime will be the shorter of the two at runtime"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let s1 = String::from("short");\r\nlet s2 = String::from("much longer");\r\n\r\nlet result = longest(&s1, &s2);\r\nprintln!("{}", result);\n'})}),"\n",(0,r.jsx)(n.p,{children:"Safe, guaranteed."}),"\n",(0,r.jsx)(n.h2,{id:"important-rule-this-is-key",children:"Important Rule (This Is Key)"}),"\n",(0,r.jsx)(n.p,{children:"A function cannot return a reference to a value it owns"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'fn bad() -> &String {\r\n    let s = String::from("hello");\r\n    &s // \u274c illegal\r\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Why?"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"s"})," is dropped at the end of the function"]}),"\n",(0,r.jsx)(n.li,{children:"The reference would dangle"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Lifetimes don\u2019t \u201cextend\u201d data\u2014they only describe reality."}),"\n",(0,r.jsx)(n.h2,{id:"lifetime-elision-rules-compiler-magic",children:"Lifetime Elision Rules (Compiler Magic)"}),"\n",(0,r.jsx)(n.p,{children:"Rust has rules that let you skip lifetime annotations in common cases."}),"\n",(0,r.jsx)(n.h3,{id:"rule-1-one-input-reference--output-uses-same-lifetime",children:"Rule 1: One input reference \u2192 output uses same lifetime"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn first(s: &str) -> &str {\r\n    s\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Expanded form:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn first<'a>(s: &'a str) -> &'a str\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"rule-2-self-in-methods-gets-its-own-lifetime",children:["Rule 2: ",(0,r.jsx)(n.code,{children:"&self"})," in methods gets its own lifetime"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"impl String {\r\n    fn len_ref(&self) -> &usize {\r\n        // hypothetical example\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Rust knows the output is tied to self."}),"\n",(0,r.jsx)(n.h2,{id:"lifetimes-with-structs-intermediate",children:"Lifetimes with Structs (Intermediate)"}),"\n",(0,r.jsx)(n.h3,{id:"struct-holding-references",children:"Struct Holding References"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"struct ImportantExcerpt<'a> {\r\n    part: &'a str,\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ImportantExcerpt"})," cannot outlive the string it references"]}),"\n",(0,r.jsx)(n.p,{children:"Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let novel = String::from("Call me Ishmael...");\r\nlet excerpt = ImportantExcerpt {\r\n    part: &novel[0..4],\r\n};\r\n\r\nprintln!("{}", excerpt.part);\n'})}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"novel"})," is dropped first \u2192 compile error."]}),"\n",(0,r.jsxs)(n.h2,{id:"lifetimes-in-impl-blocks",children:["Lifetimes in ",(0,r.jsx)(n.code,{children:"impl"})," Blocks"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"impl<'a> ImportantExcerpt<'a> {\r\n    fn level(&self) -> i32 {\r\n        3\r\n    }\r\n\r\n    fn part(&self) -> &str {\r\n        self.part\r\n    }\r\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"&self"})," uses the same lifetime ",(0,r.jsx)(n.code,{children:"'a"})]}),"\n",(0,r.jsx)(n.li,{children:"Returned reference is guaranteed valid"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"multiple-lifetimes-intermediate",children:"Multiple Lifetimes (Intermediate)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn mix<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {\r\n    x\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This is valid because:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Return value only depends on ",(0,r.jsx)(n.code,{children:"x"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"y"}),"\u2019s lifetime is irrelevant to the output"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"But this would NOT compile:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn bad<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {\r\n    y // \u274c lifetime mismatch\r\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"lifetimes--mutable-references",children:"Lifetimes + Mutable References"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn replace<'a>(s: &'a mut String) -> &'a mut String {\r\n    s.push_str(\"!\");\r\n    s\r\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Only one mutable reference exists"}),"\n",(0,r.jsx)(n.li,{children:"Lifetime ensures no other borrows overlap"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"lifetime-bounds-advanced",children:"Lifetime Bounds (Advanced)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"'a: 'b"})," (Outlives Relationship)"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn example<'a, 'b>(x: &'a str, y: &'b str)\r\nwhere\r\n    'a: 'b,\r\n{\r\n    // 'a lives at least as long as 'b\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Used when one reference must outlive another."}),"\n",(0,r.jsx)(n.h2,{id:"lifetimes-with-traits-advanced",children:"Lifetimes with Traits (Advanced)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use std::fmt::Display;\r\n\r\nfn announce<'a, T>(x: &'a str, ann: T) -> &'a str\r\nwhere\r\n    T: Display,\r\n{\r\n    println!(\"Announcement: {}\", ann);\r\n    x\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Combines:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Lifetime parameters"}),"\n",(0,r.jsx)(n.li,{children:"Generic type parameters"}),"\n",(0,r.jsx)(n.li,{children:"Trait bounds"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"static-lifetime-special-case",children:[(0,r.jsx)(n.code,{children:"'static"})," Lifetime (Special Case)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"'static"})," = valid for the entire program"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'let s: &\'static str = "I live forever";\n'})}),"\n",(0,r.jsx)(n.p,{children:"Why?"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"String literals are embedded in the binary"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Common Uses"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'fn takes_static(s: &\'static str) {\r\n    println!("{}", s);\r\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"'static"})," does NOT mean \u201cno lifetime issues\u201d",(0,r.jsx)(n.br,{}),"\n","It means \u201cthis reference never becomes invalid\u201d"]}),"\n",(0,r.jsx)(n.h2,{id:"advanced-lifetime-vs-ownership-key-insight",children:"Advanced: Lifetime vs Ownership (Key Insight)"}),"\n",(0,r.jsx)(n.p,{children:"This does NOT work:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn make_ref<'a>() -> &'a String {\r\n    let s = String::from(\"hello\");\r\n    &s\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Why?"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Lifetimes don\u2019t create ownership"}),"\n",(0,r.jsx)(n.li,{children:"You can\u2019t return references to dropped values"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Fix it by returning ownership:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'fn make_string() -> String {\r\n    String::from("hello")\r\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"mental-model-that-actually-works",children:"Mental Model That Actually Works"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Ownership: who owns the data?"}),"\n",(0,r.jsx)(n.li,{children:"Borrowing: who can access it?"}),"\n",(0,r.jsx)(n.li,{children:"Lifetimes: how long is that access valid?"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Think of lifetimes as labels, not timers."}),"\n",(0,r.jsx)(n.h2,{id:"why-lifetimes-matter",children:"Why Lifetimes Matter"}),"\n",(0,r.jsx)(n.p,{children:"Lifetimes guarantee:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No dangling references"}),"\n",(0,r.jsx)(n.li,{children:"No use-after-free"}),"\n",(0,r.jsx)(n.li,{children:"Thread-safe borrowing"}),"\n",(0,r.jsx)(n.li,{children:"Zero runtime cost"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"And all of this is enforced at compile time."})]})}function o(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},28453(e,n,i){i.d(n,{R:()=>t,x:()=>c});var s=i(96540);const r={},l=s.createContext(r);function t(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(l.Provider,{value:n},e.children)}}}]);