"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[5435],{27008(e,n,r){r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"dsa/Concepts/Backtracking","title":"Backtracking","description":"Backtracking is an algorithmic technique used to solve problems by trying out all possible solutions and eliminating (backtracking from) the ones that don\u2019t satisfy the problem\u2019s conditions.","source":"@site/docs/dsa/1. Concepts/6. Backtracking.md","sourceDirName":"dsa/1. Concepts","slug":"/dsa/Concepts/Backtracking","permalink":"/handbook/docs/dsa/Concepts/Backtracking","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Backtracking","sidebar_position":6},"sidebar":"dsaSidebar","previous":{"title":"Recursion","permalink":"/handbook/docs/dsa/Concepts/Recursion"},"next":{"title":"Dynamic Programming","permalink":"/handbook/docs/dsa/Concepts/Dynamic Programming"}}');var i=r(74848),c=r(28453);const s={title:"Backtracking",sidebar_position:6},o=void 0,a={},l=[{value:"When do we use Backtracking?",id:"when-do-we-use-backtracking",level:2},{value:"Backtracking Process",id:"backtracking-process",level:2},{value:"General Template",id:"general-template",level:2},{value:"Iterative Template of Backtracking",id:"iterative-template-of-backtracking",level:3},{value:"Recursive Template of Backtracking",id:"recursive-template-of-backtracking",level:3},{value:"Example Problem of Backtracking",id:"example-problem-of-backtracking",level:2},{value:"Generate All Binary Strings of Length <code>n</code>",id:"generate-all-binary-strings-of-length-n",level:3},{value:"N-Queens",id:"n-queens",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Backtracking is an algorithmic technique used to solve problems by trying out all possible solutions and eliminating (backtracking from) the ones that don\u2019t satisfy the problem\u2019s conditions."}),"\n",(0,i.jsx)(n.p,{children:"It is often described as a depth-first search (DFS) with undo:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You explore a path (make a choice)."}),"\n",(0,i.jsx)(n.li,{children:"If the path leads to a valid solution, keep going."}),"\n",(0,i.jsx)(n.li,{children:"If the path turns out to be invalid, go back (undo the choice) and try another path."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In short: Try \u2192 Check \u2192 Undo \u2192 Try Next."}),"\n",(0,i.jsx)(n.h2,{id:"when-do-we-use-backtracking",children:"When do we use Backtracking?"}),"\n",(0,i.jsx)(n.p,{children:"Backtracking is commonly used in problems where:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"You need to generate all solutions (e.g., permutations, combinations)."}),"\n",(0,i.jsx)(n.li,{children:"You need to find one valid solution (e.g., Sudoku solver, N-Queens)."}),"\n",(0,i.jsx)(n.li,{children:"You need to optimize and stop early when an invalid choice is detected."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"backtracking-process",children:"Backtracking Process"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Choose \u2013 Select a possible option."}),"\n",(0,i.jsx)(n.li,{children:"Explore \u2013 Recurse with the chosen option."}),"\n",(0,i.jsx)(n.li,{children:"Unchoose (Backtrack) \u2013 If it doesn\u2019t work, undo the choice and try another."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This is usually implemented with recursion."}),"\n",(0,i.jsx)(n.h2,{id:"general-template",children:"General Template"}),"\n",(0,i.jsx)(n.h3,{id:"iterative-template-of-backtracking",children:"Iterative Template of Backtracking"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Recursive backtracking function\r\nvoid backtrack(vector<int>& current, vector<int>& nums, vector<vector<int>>& result) {\r\n    // Base case: if the current solution is complete\r\n    if (current.size() == nums.size()) {\r\n        result.push_back(current);  // Save the solution\r\n        return;\r\n    }\r\n\r\n    // Loop through all possible choices\r\n    for (int i = 0; i < nums.size(); i++) {\r\n        // Skip the choice if it's already used (check for duplicates, or already in the current solution)\r\n        if (/* condition to check if nums[i] is already in current */) continue;\r\n\r\n        // Make the choice\r\n        current.push_back(nums[i]);\r\n\r\n        // Recur to the next level\r\n        backtrack(current, nums, result);\r\n\r\n        // Undo the choice (backtrack)\r\n        current.pop_back();\r\n    }\r\n}\r\n\r\n// Driver function\r\nvector<vector<int>> solve(vector<int>& nums) {\r\n    vector<vector<int>> result;  // This will hold all the valid solutions\r\n    vector<int> current;         // This holds the current solution\r\n    backtrack(current, nums, result);\r\n    return result;\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"recursive-template-of-backtracking",children:"Recursive Template of Backtracking"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Recursive backtracking function\r\nvoid backtrack(int index, vector<int>& current, vector<int>& nums, vector<vector<int>>& result) {\r\n    // Base case: if the current solution is complete (e.g., size equals to nums)\r\n    if (current.size() == nums.size()) {\r\n        result.push_back(current);  // Store the solution\r\n        return;\r\n    }\r\n\r\n    // Recursive case: explore the next possible choice\r\n    if (index >= nums.size()) {\r\n        return;  // Base case when index exceeds the array bounds\r\n    }\r\n\r\n    // Option 1: Include nums[index] in the current solution\r\n    current.push_back(nums[index]);\r\n    backtrack(index + 1, current, nums, result);  // Recursively move to the next step\r\n\r\n    // Option 2: Exclude nums[index] and try without it\r\n    current.pop_back();\r\n    backtrack(index + 1, current, nums, result);  // Recursively move to the next step\r\n}\r\n\r\n// Driver function\r\nvector<vector<int>> solve(vector<int>& nums) {\r\n    vector<vector<int>> result;  // This will hold all the valid solutions\r\n    vector<int> current;         // This holds the current solution\r\n    backtrack(0, current, nums, result);  // Start the recursion from the first index\r\n    return result;\r\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"example-problem-of-backtracking",children:"Example Problem of Backtracking"}),"\n",(0,i.jsxs)(n.h3,{id:"generate-all-binary-strings-of-length-n",children:["Generate All Binary Strings of Length ",(0,i.jsx)(n.code,{children:"n"})]}),"\n",(0,i.jsxs)(n.p,{children:["Suppose we want to generate all possible binary strings of length ",(0,i.jsx)(n.code,{children:"n"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Step-by-Step Approach"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["At each position, we have two choices: put ",(0,i.jsx)(n.code,{children:"0"})," or ",(0,i.jsx)(n.code,{children:"1"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"Place a digit and recursively move to the next position."}),"\n",(0,i.jsxs)(n.li,{children:["If we reach length ",(0,i.jsx)(n.code,{children:"n"}),", print the string."]}),"\n",(0,i.jsx)(n.li,{children:"If not, backtrack and try the other option."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"n-queens",children:"N-Queens"}),"\n",(0,i.jsxs)(n.p,{children:["Place ",(0,i.jsx)(n.code,{children:"N"})," queens on an ",(0,i.jsx)(n.code,{children:"N x N"})," chessboard such that:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No two queens attack each other."}),"\n",(0,i.jsx)(n.li,{children:"A queen can attack another queen in the same row, column, or diagonal."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The task: Print all possible arrangements."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why Backtracking?"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"At each row, we try placing a queen in one column."}),"\n",(0,i.jsx)(n.li,{children:"If it\u2019s safe (no queen in same column or diagonal), we continue to the next row."}),"\n",(0,i.jsx)(n.li,{children:"If not safe, we backtrack (remove queen) and try the next column."}),"\n",(0,i.jsx)(n.li,{children:"If we reach row N, we found a solution."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Step-by-Step Process"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Start with the first row."}),"\n",(0,i.jsxs)(n.li,{children:["For each column in that row:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Check if placing a queen is safe."}),"\n",(0,i.jsx)(n.li,{children:"If safe \u2192 place queen and move to next row."}),"\n",(0,i.jsx)(n.li,{children:"If not safe \u2192 try next column."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"If all rows are filled, print solution."}),"\n",(0,i.jsx)(n.li,{children:"If stuck, backtrack (remove queen) and try a different column."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453(e,n,r){r.d(n,{R:()=>s,x:()=>o});var t=r(96540);const i={},c=t.createContext(i);function s(e){const n=t.useContext(c);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(c.Provider,{value:n},e.children)}}}]);