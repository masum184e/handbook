"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[5616],{28453(e,n,i){i.d(n,{R:()=>r,x:()=>c});var s=i(96540);const o={},t=s.createContext(o);function r(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(t.Provider,{value:n},e.children)}},91735(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"javascript/Hoisting","title":"Hoisting","description":"It\'s a mechanism where variables and function declarations are moved to the top of their containing scope during the compile phase, before the code is executed. This means that you can use functions and variables before they are declared in the code.","source":"@site/docs/javascript/10. Hoisting.md","sourceDirName":"javascript","slug":"/javascript/Hoisting","permalink":"/handbook/docs/javascript/Hoisting","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"sidebar_position":11},"sidebar":"javascriptSidebar","previous":{"title":"Composition","permalink":"/handbook/docs/javascript/Composition"},"next":{"title":"Temporal Dead Zone","permalink":"/handbook/docs/javascript/Temporal Dead Zone"}}');var o=i(74848),t=i(28453);const r={sidebar_position:11},c=void 0,l={},a=[{value:"Types of Hoisting",id:"types-of-hoisting",level:2},{value:"How IIFE Interacts With Hoisting",id:"how-iife-interacts-with-hoisting",level:2},{value:"How IIFE Interacts With Hoisting",id:"how-iife-interacts-with-hoisting-1",level:2},{value:"Step 1: Function Expression vs Function Declaration",id:"step-1-function-expression-vs-function-declaration",level:3},{value:"Step 1: Function Expression vs Function Declaration",id:"step-1-function-expression-vs-function-declaration-1",level:3},{value:"Step 2: IIFE Creates a New Scope",id:"step-2-iife-creates-a-new-scope",level:3},{value:"Step 2: IIFE Creates a New Scope",id:"step-2-iife-creates-a-new-scope-1",level:3},{value:"Step 3: IIFE and let/const",id:"step-3-iife-and-letconst",level:3},{value:"Step 4: Named IIFE Hoisting",id:"step-4-named-iife-hoisting",level:3},{value:"Key Points about hoisting with IIFE",id:"key-points-about-hoisting-with-iife",level:3},{value:"How Redeclaration affect",id:"how-redeclaration-affect",level:2},{value:"Function Scope",id:"function-scope",level:3},{value:"Block Scope",id:"block-scope",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"It's a mechanism where variables and function declarations are moved to the top of their containing scope during the compile phase, before the code is executed. This means that you can use functions and variables before they are declared in the code."}),"\n",(0,o.jsxs)(n.p,{children:["However, ",(0,o.jsx)(n.strong,{children:"only declarations are hoisted, not initializations"}),". The declaration is moved to the top, but the assignment or initialization stays in its place."]}),"\n",(0,o.jsx)(n.h2,{id:"types-of-hoisting",children:"Types of Hoisting"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"1.Variable Hoisting"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["Variables declared with ",(0,o.jsx)(n.code,{children:"var"})," are hoisted to the top of their scope but are initialized with ",(0,o.jsx)(n.code,{children:"undefined"})," until they are assigned a value."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"let"})," and ",(0,o.jsx)(n.code,{children:"const"}),' declarations are hoisted but are not initialized. They are in a "temporal dead zone" (TDZ) from the start of the block until the declaration is encountered.\r\n',(0,o.jsx)(n.strong,{children:"1.Variable Hoisting"}),":"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["Variables declared with ",(0,o.jsx)(n.code,{children:"var"})," are hoisted to the top of their scope but are initialized with ",(0,o.jsx)(n.code,{children:"undefined"})," until they are assigned a value."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"let"})," and ",(0,o.jsx)(n.code,{children:"const"}),' declarations are hoisted but are not initialized. They are in a "temporal dead zone" (TDZ) from the start of the block until the declaration is encountered.']}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"2.Function Hoisting"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Function declarations are fully hoisted. This means you can call the function even before it is declared in the code."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["Function expressions assigned to variables (using ",(0,o.jsx)(n.code,{children:"var"}),", ",(0,o.jsx)(n.code,{children:"let"}),", or ",(0,o.jsx)(n.code,{children:"const"}),") are not hoisted in the same way as function declarations\r\n",(0,o.jsx)(n.strong,{children:"2.Function Hoisting"}),":"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Function declarations are fully hoisted. This means you can call the function even before it is declared in the code."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["Function expressions assigned to variables (using ",(0,o.jsx)(n.code,{children:"var"}),", ",(0,o.jsx)(n.code,{children:"let"}),", or ",(0,o.jsx)(n.code,{children:"const"}),") are not hoisted in the same way as function declarations"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'greet(); // Output: Hello, World!\r\n\r\nfunction greet() {\r\n  console.log("Hello, World!");\r\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Function Expression:"})}),"\n",(0,o.jsxs)(n.p,{children:["Function expressions are not fully hoisted, because variable stores ",(0,o.jsx)(n.code,{children:"undefined"})," at creation phase. It stored the function body during execution phase. It's just an another variable assigned ",(0,o.jsx)(n.code,{children:"undefined"}),". That's why ",(0,o.jsx)(n.strong,{children:"calling"})," something ",(0,o.jsx)(n.code,{children:"undefined"})," will cause an error. We can use it as variable that will show ",(0,o.jsx)(n.code,{children:"undefined"})," but will not cause an error."]}),"\n",(0,o.jsxs)(n.p,{children:["Function expressions are not fully hoisted, because variable stores ",(0,o.jsx)(n.code,{children:"undefined"})," at creation phase. It stored the function body during execution phase. It's just an another variable assigned ",(0,o.jsx)(n.code,{children:"undefined"}),". That's why ",(0,o.jsx)(n.strong,{children:"calling"})," something ",(0,o.jsx)(n.code,{children:"undefined"})," will cause an error. We can use it as variable that will show ",(0,o.jsx)(n.code,{children:"undefined"})," but will not cause an error."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'sayHello(); // TypeError: sayHello is not a function\r\n\r\nvar sayHello = function () {\r\n  console.log("Hello!");\r\n};\n'})}),"\n",(0,o.jsx)(n.h2,{id:"how-iife-interacts-with-hoisting",children:"How IIFE Interacts With Hoisting"}),"\n",(0,o.jsx)(n.h2,{id:"how-iife-interacts-with-hoisting-1",children:"How IIFE Interacts With Hoisting"}),"\n",(0,o.jsx)(n.h3,{id:"step-1-function-expression-vs-function-declaration",children:"Step 1: Function Expression vs Function Declaration"}),"\n",(0,o.jsx)(n.h3,{id:"step-1-function-expression-vs-function-declaration-1",children:"Step 1: Function Expression vs Function Declaration"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Function declaration (",(0,o.jsx)(n.code,{children:"function foo(){}"}),") is hoisted."]}),"\n",(0,o.jsxs)(n.li,{children:["Function expression (",(0,o.jsx)(n.code,{children:"const foo = function(){}"})," or ",(0,o.jsx)(n.code,{children:"(function(){}))"})," is not hoisted in the same way \u2014 it behaves like a variable assignment."]}),"\n",(0,o.jsxs)(n.li,{children:["Function declaration (",(0,o.jsx)(n.code,{children:"function foo(){}"}),") is hoisted."]}),"\n",(0,o.jsxs)(n.li,{children:["Function expression (",(0,o.jsx)(n.code,{children:"const foo = function(){}"})," or ",(0,o.jsx)(n.code,{children:"(function(){}))"})," is not hoisted in the same way \u2014 it behaves like a variable assignment."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'foo(); // Works\r\nfunction foo() {\r\n  console.log("declaration");\r\n}\r\n\r\nbar(); // \u274c TypeError: bar is not a function\r\nvar bar = function () {\r\n  console.log("expression");\r\n};\n'})}),"\n",(0,o.jsx)(n.p,{children:"So in an IIFE, since it\u2019s a function expression, only the variable (if assigned) is hoisted, not the function body."}),"\n",(0,o.jsx)(n.h3,{id:"step-2-iife-creates-a-new-scope",children:"Step 2: IIFE Creates a New Scope"}),"\n",(0,o.jsx)(n.p,{children:"When an IIFE runs:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"It creates a new execution context (like calling any function)."}),"\n",(0,o.jsxs)(n.li,{children:["Inside it, hoisting rules apply again (vars hoisted to function scope, ",(0,o.jsx)(n.code,{children:"let"}),"/",(0,o.jsx)(n.code,{children:"const"})," in TDZ)."]}),"\n",(0,o.jsx)(n.li,{children:"This protects outer/global scope from variable pollution."}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'foo(); // Works\r\n  function foo() {\r\n  console.log("declaration");\r\n  }\r\n\r\nbar(); // \u274c TypeError: bar is not a function\r\nvar bar = function () {\r\nconsole.log("expression");\r\n};\r\n\n'})}),"\n",(0,o.jsx)(n.p,{children:"So in an IIFE, since it\u2019s a function expression, only the variable (if assigned) is hoisted, not the function body."}),"\n",(0,o.jsx)(n.h3,{id:"step-2-iife-creates-a-new-scope-1",children:"Step 2: IIFE Creates a New Scope"}),"\n",(0,o.jsx)(n.p,{children:"When an IIFE runs:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"It creates a new execution context (like calling any function)."}),"\n",(0,o.jsxs)(n.li,{children:["Inside it, hoisting rules apply again (vars hoisted to function scope, ",(0,o.jsx)(n.code,{children:"let"}),"/",(0,o.jsx)(n.code,{children:"const"})," in TDZ)."]}),"\n",(0,o.jsx)(n.li,{children:"This protects outer/global scope from variable pollution."}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"var x = 1;\r\n\r\n(function () {\r\n  console.log(x); // undefined (var is hoisted inside IIFE)\r\n  var x = 2;\r\n  console.log(x); // 2\r\n})();\r\n\r\nconsole.log(x); // 1 (outer scope unaffected)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Inside the IIFE, ",(0,o.jsx)(n.code,{children:"var x"})," is hoisted to the top of the IIFE\u2019s scope, shadowing the global x."]}),"\n",(0,o.jsx)(n.h3,{id:"step-3-iife-and-letconst",children:"Step 3: IIFE and let/const"}),"\n",(0,o.jsxs)(n.p,{children:["Using ",(0,o.jsx)(n.code,{children:"let"}),"/",(0,o.jsx)(n.code,{children:"const"})," inside an IIFE prevents leakage into the global scope, and they are still hoisted into the IIFE\u2019s scope but in TDZ."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"(function () {\r\n  // console.log(y); // \u274c ReferenceError (TDZ)\r\n  let y = 10;\r\n  console.log(y); // 10\r\n})();\r\n\r\n// console.log(y); // \u274c ReferenceError (not defined outside IIFE)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"step-4-named-iife-hoisting",children:"Step 4: Named IIFE Hoisting"}),"\n",(0,o.jsx)(n.p,{children:"IIFEs can be named, but the name is scoped only inside the IIFE."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'(function greet() {\r\n  console.log("Hello!");\r\n  // console.log(greet); // function reference available inside\r\n})();\r\n\r\n// console.log(greet); // \u274c ReferenceError (not defined outside)\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Here, ",(0,o.jsx)(n.code,{children:"greet"})," is hoisted inside the IIFE only, not globally."]}),"\n",(0,o.jsx)(n.h3,{id:"key-points-about-hoisting-with-iife",children:"Key Points about hoisting with IIFE"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"IIFE itself is a function expression \u2192 not hoisted like declarations."}),"\n"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"You can\u2019t call it before it appears."}),"\n"]}),"\n",(0,o.jsxs)(n.ol,{start:"2",children:["\n",(0,o.jsx)(n.li,{children:"Inside IIFE, normal hoisting rules apply:"}),"\n"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"var"})," hoisted (initialized ",(0,o.jsx)(n.code,{children:"undefined"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"function declarations"})," fully hoisted."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"let"}),"/",(0,o.jsx)(n.code,{children:"const"})," hoisted into TDZ."]}),"\n"]}),"\n",(0,o.jsxs)(n.ol,{start:"3",children:["\n",(0,o.jsx)(n.li,{children:"IIFE provides a scope barrier \u2192 prevents hoisted vars/functions from leaking into global scope."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"how-redeclaration-affect",children:"How Redeclaration affect"}),"\n",(0,o.jsx)(n.h3,{id:"function-scope",children:"Function Scope"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"var declarations are function-scoped (or global if outside a function)."}),"\n",(0,o.jsx)(n.li,{children:"Hoisting behavior: The variable is hoisted to the top of its scope and initialized with undefined."}),"\n",(0,o.jsx)(n.li,{children:"Because of this, JavaScript allows redeclaration in the same scope (it just ignores the second declaration)."}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"block-scope",children:"Block Scope"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"let"})," is block-scoped (only visible inside ",(0,o.jsx)(n.code,{children:"{ ... }"}),")."]}),"\n",(0,o.jsx)(n.li,{children:"Variables in a block are in a temporal dead zone (TDZ) until initialized."}),"\n",(0,o.jsxs)(n.li,{children:["Redeclaration in the same block is forbidden, because JS must avoid ",(0,o.jsx)(n.strong,{children:"ambiguity"})," about which variable is being referenced."]}),"\n",(0,o.jsx)(n.li,{children:"This is a compile-time error."}),"\n",(0,o.jsx)(n.li,{children:"TDZ + block scoping ensures safer, predictable behavior."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);