"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[4872],{9809(n,i,e){e.r(i),e.d(i,{assets:()=>d,contentTitle:()=>c,default:()=>a,frontMatter:()=>l,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"redis/Lua Scripting","title":"Lua Scripting","description":"Redis includes a built-in Lua interpreter that allows you to run server-side scripts using the command:","source":"@site/docs/redis/15. Lua Scripting.md","sourceDirName":"redis","slug":"/redis/Lua Scripting","permalink":"/handbook/docs/redis/Lua Scripting","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":15,"frontMatter":{}}');var s=e(74848),t=e(28453);const l={},c=void 0,d={},o=[{value:"Why Lua Scripting Matters for Performance",id:"why-lua-scripting-matters-for-performance",level:2},{value:"Without optimization",id:"without-optimization",level:3},{value:"With Lua scripting",id:"with-lua-scripting",level:3},{value:"Atomic Increment with Logic",id:"atomic-increment-with-logic",level:2},{value:"Why Lua is Faster Than Multi-Command Client Logic",id:"why-lua-is-faster-than-multi-command-client-logic",level:2},{value:"Lua Scripting vs MULTI/EXEC",id:"lua-scripting-vs-multiexec",level:2},{value:"Lua Scripting vs Pipelining",id:"lua-scripting-vs-pipelining",level:2},{value:"Compare Lua, MULTI/EXEC, and Pipelining",id:"compare-lua-multiexec-and-pipelining",level:2},{value:"Approach 1: Without Optimization (3 round trips)",id:"approach-1-without-optimization-3-round-trips",level:3},{value:"Approach 2: Pipelining (1 round trip)",id:"approach-2-pipelining-1-round-trip",level:3},{value:"Approach 3: MULTI/EXEC (Atomic but more round trips)",id:"approach-3-multiexec-atomic-but-more-round-trips",level:3},{value:"Approach 4: Lua Scripting (Best)",id:"approach-4-lua-scripting-best",level:3},{value:"Between Lua, MULTI/EXEC, and Pipelining",id:"between-lua-multiexec-and-pipelining",level:2}];function h(n){const i={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.p,{children:"Redis includes a built-in Lua interpreter that allows you to run server-side scripts using the command:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-sh",children:"EVAL <script> <numkeys> key1 key2 arg1 arg2 ...\n"})}),"\n",(0,s.jsx)(i.h2,{id:"why-lua-scripting-matters-for-performance",children:"Why Lua Scripting Matters for Performance"}),"\n",(0,s.jsx)(i.p,{children:"When you execute multiple Redis commands from your application:"}),"\n",(0,s.jsx)(i.h3,{id:"without-optimization",children:"Without optimization"}),"\n",(0,s.jsx)(i.p,{children:"Your app \u2192 Redis \u2192 app \u2192 Redis (many round trips)"}),"\n",(0,s.jsx)(i.p,{children:"This creates:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"high latency"}),"\n",(0,s.jsx)(i.li,{children:"many network packets"}),"\n",(0,s.jsx)(i.li,{children:"slow client-side logic"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"with-lua-scripting",children:"With Lua scripting"}),"\n",(0,s.jsx)(i.p,{children:"Your app \u2192 Redis (one script) \u2192 Redis runs everything internally"}),"\n",(0,s.jsx)(i.p,{children:"Huge performance improvements because:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"0 network round trips inside script"}),"\n",(0,s.jsx)(i.li,{children:"Atomicity guaranteed"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"atomic-increment-with-logic",children:"Atomic Increment with Logic"}),"\n",(0,s.jsx)(i.p,{children:"Suppose you want: Increment a counter only if a limit is not exceeded."}),"\n",(0,s.jsx)(i.p,{children:"Without Lua (multiple round trips):"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"GET counter"})}),"\n",(0,s.jsx)(i.li,{children:"compute in app"}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.code,{children:"SET counter newValue"})}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"This can cause race conditions in concurrent environments."}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-sh",children:"EVAL \"\r\nlocal current = redis.call('GET', KEYS[1])\r\nif not current then\r\n  redis.call('SET', KEYS[1], 1)\r\n  return 1\r\nelseif tonumber(current) < tonumber(ARGV[1]) then\r\n  redis.call('INCR', KEYS[1])\r\n  return redis.call('GET', KEYS[1])\r\nelse\r\n  return current\r\nend\r\n\" 1 counter 10\n"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"KEYS[1]"})," = ",(0,s.jsx)(i.code,{children:'"counter"'})]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"ARGV[1]"})," = ",(0,s.jsx)(i.code,{children:"10"})," (limit)"]}),"\n",(0,s.jsxs)(i.li,{children:["Logic:","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"If counter doesn't exist \u2192 set to 1"}),"\n",(0,s.jsx)(i.li,{children:"If under limit \u2192 increment"}),"\n",(0,s.jsx)(i.li,{children:"If over limit \u2192 return current value"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.li,{children:"All done atomically and in one server-side script"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"why-lua-is-faster-than-multi-command-client-logic",children:"Why Lua is Faster Than Multi-Command Client Logic"}),"\n",(0,s.jsx)(i.p,{children:"Because Redis runs Lua scripts without releasing the CPU until finished."}),"\n",(0,s.jsx)(i.p,{children:"This makes it:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Safer (no race conditions)"}),"\n",(0,s.jsx)(i.li,{children:"Faster (no network calls)"}),"\n",(0,s.jsx)(i.li,{children:"More powerful (conditional logic on server)"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"lua-scripting-vs-multiexec",children:"Lua Scripting vs MULTI/EXEC"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Feature"}),(0,s.jsx)(i.th,{children:"Lua Scripting"}),(0,s.jsx)(i.th,{children:"MULTI/EXEC"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Atomic?"})}),(0,s.jsx)(i.td,{children:"\u2714 Entire script atomic"}),(0,s.jsx)(i.td,{children:"\u2714 Entire transaction atomic"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Conditional logic?"})}),(0,s.jsx)(i.td,{children:"\u2714 Fully flexible"}),(0,s.jsx)(i.td,{children:"\u274c No logic inside transaction (client must compute)"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Network round trips"})}),(0,s.jsx)(i.td,{children:"\u2714 1 round trip"}),(0,s.jsx)(i.td,{children:"\u274c Multiple (commands are queued)"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Performance"})}),(0,s.jsx)(i.td,{children:"\u2b50 Fastest for multi-ops"}),(0,s.jsx)(i.td,{children:"\u26a1 Fast"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Error behavior"})}),(0,s.jsx)(i.td,{children:"Script runs fully or errors early"}),(0,s.jsx)(i.td,{children:"Errors only on EXEC"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Server-side loops?"})}),(0,s.jsx)(i.td,{children:"\u2714 Yes"}),(0,s.jsx)(i.td,{children:"\u274c No"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Ideal for"})}),(0,s.jsx)(i.td,{children:"complex logic, repeated patterns"}),(0,s.jsx)(i.td,{children:"simple atomic sequences"})]})]})]}),"\n",(0,s.jsx)(i.h2,{id:"lua-scripting-vs-pipelining",children:"Lua Scripting vs Pipelining"}),"\n",(0,s.jsx)(i.p,{children:"Pipelining sends multiple commands in one batch but:"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Feature"}),(0,s.jsx)(i.th,{children:"Lua Scripting"}),(0,s.jsx)(i.th,{children:"Pipelining"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Atomic"})}),(0,s.jsx)(i.td,{children:"\u2714 Yes"}),(0,s.jsx)(i.td,{children:"\u274c No"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Conditional logic"})}),(0,s.jsx)(i.td,{children:"\u2714 Yes"}),(0,s.jsx)(i.td,{children:"\u274c No"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Network round trips"})}),(0,s.jsx)(i.td,{children:"\u2714 1"}),(0,s.jsx)(i.td,{children:"\u2714 1"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Executes server-side?"})}),(0,s.jsx)(i.td,{children:"\u2714 Yes"}),(0,s.jsx)(i.td,{children:"\u274c No (just client batching)"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Order guarantee"})}),(0,s.jsx)(i.td,{children:"\u2714 Yes"}),(0,s.jsx)(i.td,{children:"\u2714 Yes"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Ideal for"})}),(0,s.jsx)(i.td,{children:"stateful logic"}),(0,s.jsx)(i.td,{children:"high-volume simple commands"})]})]})]}),"\n",(0,s.jsx)(i.h2,{id:"compare-lua-multiexec-and-pipelining",children:"Compare Lua, MULTI/EXEC, and Pipelining"}),"\n",(0,s.jsx)(i.p,{children:"Requirement: Increment three keys and return their sum"}),"\n",(0,s.jsx)(i.h3,{id:"approach-1-without-optimization-3-round-trips",children:"Approach 1: Without Optimization (3 round trips)"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"INCR k1\r\nINCR k2\r\nINCR k3\n"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"3 network round trips"}),"\n",(0,s.jsx)(i.li,{children:"3 server executions"}),"\n",(0,s.jsx)(i.li,{children:"client computes sum"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"approach-2-pipelining-1-round-trip",children:"Approach 2: Pipelining (1 round trip)"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"INCR k1\r\nINCR k2\r\nINCR k3\n"})}),"\n",(0,s.jsx)(i.p,{children:"Sent as a pipeline \u2192 1 round trip"}),"\n",(0,s.jsx)(i.p,{children:"BUT:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Still 3 server operations"}),"\n",(0,s.jsx)(i.li,{children:"No atomicity"}),"\n",(0,s.jsx)(i.li,{children:"Client computes last step"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"approach-3-multiexec-atomic-but-more-round-trips",children:"Approach 3: MULTI/EXEC (Atomic but more round trips)"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"MULTI\r\nINCR k1\r\nINCR k2\r\nINCR k3\r\nEXEC\n"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"\u2714 atomic"}),"\n",(0,s.jsx)(i.li,{children:"\u274c 2 network round trips (MULTI + EXEC)"}),"\n",(0,s.jsx)(i.li,{children:"\u274c cannot compute sum server-side"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"approach-4-lua-scripting-best",children:"Approach 4: Lua Scripting (Best)"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"EVAL \"\r\nlocal a = redis.call('INCR', KEYS[1])\r\nlocal b = redis.call('INCR', KEYS[2])\r\nlocal c = redis.call('INCR', KEYS[3])\r\nreturn a + b + c\r\n\" 3 k1 k2 k3\n"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"1 round trip"}),"\n",(0,s.jsx)(i.li,{children:"All increments occur inside Redis"}),"\n",(0,s.jsx)(i.li,{children:"Sum computed server-side"}),"\n",(0,s.jsx)(i.li,{children:"Atomic"}),"\n",(0,s.jsx)(i.li,{children:"Fastest option"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"between-lua-multiexec-and-pipelining",children:"Between Lua, MULTI/EXEC, and Pipelining"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"If you need\u2026"}),(0,s.jsx)(i.th,{children:"Use"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Complex logic"}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Lua"})})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Atomicity + logic"}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Lua"})})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Many simple commands with no logic"}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Pipelining"})})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Strict atomic multi-command bundle"}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"MULTI/EXEC"})})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Server-side computation (loops, conditionals)"}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Lua"})})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Minimizing network latency"}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Lua or Pipelining"})})]})]})]})]})}function a(n={}){const{wrapper:i}={...(0,t.R)(),...n.components};return i?(0,s.jsx)(i,{...n,children:(0,s.jsx)(h,{...n})}):h(n)}},28453(n,i,e){e.d(i,{R:()=>l,x:()=>c});var r=e(96540);const s={},t=r.createContext(s);function l(n){const i=r.useContext(t);return r.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function c(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:l(n.components),r.createElement(t.Provider,{value:i},n.children)}}}]);