"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[9707],{28453(e,i,n){n.d(i,{R:()=>l,x:()=>a});var s=n(96540);const t={},r=s.createContext(t);function l(e){const i=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(r.Provider,{value:i},e.children)}},60636(e,i,n){n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"system-design/Rate Limiting","title":"Rate Limiting","description":"Rate limiting is a technique used in system design to control the number of requests a user or system can make to a resource within a given time window. It protects services from abuse, overload, and ensures fair resource usage","source":"@site/docs/system-design/8. Rate Limiting.md","sourceDirName":"system-design","slug":"/system-design/Rate Limiting","permalink":"/handbook/docs/system-design/Rate Limiting","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"systemDesignSidebar","previous":{"title":"Load Balancer","permalink":"/handbook/docs/system-design/Load Balancer"},"next":{"title":"Replication","permalink":"/handbook/docs/system-design/Replication/Replication"}}');var t=n(74848),r=n(28453);const l={sidebar_position:9},a=void 0,o={},d=[{value:"Why Use Rate Limiting?",id:"why-use-rate-limiting",level:2},{value:"Where Rate Limiting Applied",id:"where-rate-limiting-applied",level:2},{value:"Rate Limiting Algorithms",id:"rate-limiting-algorithms",level:2},{value:"Example of Rate Limiting",id:"example-of-rate-limiting",level:2},{value:"GitHub API Example",id:"github-api-example",level:2},{value:"Node.js Example of Rate Limiting",id:"nodejs-example-of-rate-limiting",level:2},{value:"How It Works",id:"how-it-works",level:3},{value:"Headers for Clients",id:"headers-for-clients",level:3},{value:"Tech Stack for Rate Limiting",id:"tech-stack-for-rate-limiting",level:2},{value:"Best Practices of Rate Limiting",id:"best-practices-of-rate-limiting",level:2},{value:"What Happens Without Rate Limiting?",id:"what-happens-without-rate-limiting",level:2}];function c(e){const i={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.p,{children:"Rate limiting is a technique used in system design to control the number of requests a user or system can make to a resource within a given time window. It protects services from abuse, overload, and ensures fair resource usage"}),"\n",(0,t.jsx)(i.h2,{id:"why-use-rate-limiting",children:"Why Use Rate Limiting?"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Prevent Abuse: Throttle bots, scrapers, or malicious users."}),"\n",(0,t.jsx)(i.li,{children:"Protect Backend Resources: Databases, APIs, or microservices."}),"\n",(0,t.jsx)(i.li,{children:"Ensure Fair Usage: Distribute resources fairly among users."}),"\n",(0,t.jsx)(i.li,{children:"Avoid Cost Spikes: Especially in cloud-based services (e.g., APIs with metered billing)."}),"\n",(0,t.jsx)(i.li,{children:"Maintain System Stability: Prevent cascading failures by not overloading services."}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"where-rate-limiting-applied",children:"Where Rate Limiting Applied"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"API Gateways"}),"\n",(0,t.jsx)(i.li,{children:"Load Balancers"}),"\n",(0,t.jsx)(i.li,{children:"Microservices"}),"\n",(0,t.jsx)(i.li,{children:"Reverse Proxies (e.g., NGINX, Envoy)"}),"\n",(0,t.jsx)(i.li,{children:"Databases (at query level)"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"rate-limiting-algorithms",children:"Rate Limiting Algorithms"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Algorithm"}),(0,t.jsx)(i.th,{children:"Description"}),(0,t.jsx)(i.th,{children:"Pros"}),(0,t.jsx)(i.th,{children:"Cons"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.strong,{children:"Token Bucket"})}),(0,t.jsx)(i.td,{children:"Tokens are added at fixed rate; requests consume tokens."}),(0,t.jsx)(i.td,{children:"Smooth flow; allows bursts"}),(0,t.jsx)(i.td,{children:"Slightly complex"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.strong,{children:"Leaky Bucket"})}),(0,t.jsx)(i.td,{children:"Requests added to queue; processed at fixed rate"}),(0,t.jsx)(i.td,{children:"Smoother output rate"}),(0,t.jsx)(i.td,{children:"May drop bursts"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.strong,{children:"Fixed Window"})}),(0,t.jsx)(i.td,{children:"Count resets every window (e.g., every minute)"}),(0,t.jsx)(i.td,{children:"Simple"}),(0,t.jsx)(i.td,{children:"Traffic spikes at edges"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.strong,{children:"Sliding Window Log"})}),(0,t.jsx)(i.td,{children:"Logs timestamps of requests, checks time window"}),(0,t.jsx)(i.td,{children:"Accurate"}),(0,t.jsx)(i.td,{children:"High memory usage"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.strong,{children:"Sliding Window Counter"})}),(0,t.jsx)(i.td,{children:"Counts spread over sub-windows"}),(0,t.jsx)(i.td,{children:"Balance between accuracy & memory"}),(0,t.jsx)(i.td,{children:"Slightly complex"})]})]})]}),"\n",(0,t.jsx)(i.h2,{id:"example-of-rate-limiting",children:"Example of Rate Limiting"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Scenario:"})," You have a public REST API. To avoid abuse, you allow:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"100 requests per user per minute."}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Design with Token Bucket (Example):"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Each user gets a bucket with capacity = 100 tokens."}),"\n",(0,t.jsx)(i.li,{children:"1 token = 1 API request."}),"\n",(0,t.jsx)(i.li,{children:"Tokens refill at 100/min (\u22481.67 tokens/sec)."}),"\n",(0,t.jsxs)(i.li,{children:["If the bucket is empty \u2192 Reject request with ",(0,t.jsx)(i.code,{children:"429 Too Many Requests"}),"."]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Flow:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"User A makes 5 requests -> consumes 5 tokens\r\nBucket has 95 left\r\nIf User A sends 101 requests in a minute -> last one is rejected\n"})}),"\n",(0,t.jsx)(i.h2,{id:"github-api-example",children:"GitHub API Example"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Unauthenticated users:"})," 60 requests/hour."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Authenticated users:"})," 5000 requests/hour."]}),"\n",(0,t.jsx)(i.li,{children:"Clients get headers like:"}),"\n"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-yaml",children:"X-RateLimit-Limit: 5000\r\nX-RateLimit-Remaining: 4990\r\nX-RateLimit-Reset: 1664579460\n"})}),"\n",(0,t.jsx)(i.h2,{id:"nodejs-example-of-rate-limiting",children:"Node.js Example of Rate Limiting"}),"\n",(0,t.jsx)(i.p,{children:"Each client (IP) gets:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.code,{children:"maxTokens = 5"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.code,{children:"refillRate = 1 token every 12 seconds"})}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Tokens are stored per IP in Redis with timestamp and count."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-js",children:'const express = require("express");\r\nconst Redis = require("ioredis");\r\n\r\nconst app = express();\r\nconst redis = new Redis(); // Connects to Redis at localhost:6379\r\n\r\nconst RATE_LIMIT = {\r\n  MAX_TOKENS: 5,\r\n  REFILL_INTERVAL_MS: 60 * 1000,\r\n};\r\n\r\nfunction getKey(ip) {\r\n  return `rate_limit:${ip}`;\r\n}\r\n\r\nasync function rateLimiter(req, res, next) {\r\n  const ip = req.ip;\r\n  const key = getKey(ip);\r\n\r\n  const now = Date.now();\r\n\r\n  // Get existing token info from Redis\r\n  const data = await redis.hgetall(key);\r\n  let tokens = parseInt(data.tokens || RATE_LIMIT.MAX_TOKENS);\r\n  let lastRefill = parseInt(data.lastRefill || now);\r\n\r\n  // Calculate time since last refill\r\n  const timeElapsed = now - lastRefill;\r\n  const refillTokens = Math.floor(\r\n    (timeElapsed / RATE_LIMIT.REFILL_INTERVAL_MS) * RATE_LIMIT.MAX_TOKENS\r\n  );\r\n\r\n  tokens = Math.min(RATE_LIMIT.MAX_TOKENS, tokens + refillTokens);\r\n  lastRefill = refillTokens > 0 ? now : lastRefill;\r\n\r\n  if (tokens > 0) {\r\n    tokens--;\r\n    await redis.hmset(key, {\r\n      tokens,\r\n      lastRefill,\r\n    });\r\n    await redis.expire(key, 60); // auto-expire in 60 sec\r\n    next();\r\n  } else {\r\n    res.set("Retry-After", 60);\r\n    res.status(429).send("Rate limit exceeded. Try again later.");\r\n  }\r\n}\r\n\r\napp.use(rateLimiter);\r\n\r\napp.get("/", (req, res) => {\r\n  res.send("Hello! You are within the rate limit.");\r\n});\r\n\r\napp.listen(3000, () => {\r\n  console.log("Server running on http://localhost:3000");\r\n});\n'})}),"\n",(0,t.jsx)(i.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"First-time users start with 5 tokens."}),"\n",(0,t.jsx)(i.li,{children:"Each request consumes 1 token."}),"\n",(0,t.jsx)(i.li,{children:"Redis keeps track of tokens + last refill time."}),"\n",(0,t.jsx)(i.li,{children:"Tokens are refilled proportionally every minute."}),"\n",(0,t.jsx)(i.li,{children:"If tokens are 0 \u2192 respond with HTTP 429."}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"headers-for-clients",children:"Headers for Clients"}),"\n",(0,t.jsx)(i.p,{children:"To improve UX, you can add headers like:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-shell",children:"res.set('X-RateLimit-Limit', 5);\r\nres.set('X-RateLimit-Remaining', tokens);\n"})}),"\n",(0,t.jsx)(i.h2,{id:"tech-stack-for-rate-limiting",children:"Tech Stack for Rate Limiting"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"API Gateway"})," (e.g., Amazon API Gateway, Kong, Apigee): Applies user-level rate limiting."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Redis:"})," Stores counters per user (good for distributed systems)."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"NGINX:"})," Can enforce rate limiting via limit_req_zone."]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"best-practices-of-rate-limiting",children:"Best Practices of Rate Limiting"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Implement graceful degradation (e.g., retries, backoff)."}),"\n",(0,t.jsxs)(i.li,{children:["Provide users with rate limit headers (e.g., ",(0,t.jsx)(i.code,{children:"X-RateLimit-Limit"}),", ",(0,t.jsx)(i.code,{children:"X-RateLimit-Remaining"}),")."]}),"\n",(0,t.jsx)(i.li,{children:"Log and monitor rejected requests to detect abuse or misconfigurations."}),"\n",(0,t.jsx)(i.li,{children:"Use exponential backoff in clients to reduce retry pressure."}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"what-happens-without-rate-limiting",children:"What Happens Without Rate Limiting?"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Denial-of-Service (DoS) risk."}),"\n",(0,t.jsx)(i.li,{children:"Cost explosion from excessive compute/API calls."}),"\n",(0,t.jsx)(i.li,{children:"Poor performance for legitimate users."}),"\n",(0,t.jsx)(i.li,{children:"Data inconsistency under high concurrent writes."}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);