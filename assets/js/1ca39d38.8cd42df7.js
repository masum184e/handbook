"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[65961],{28453(e,n,s){s.d(n,{R:()=>t,x:()=>r});var c=s(96540);const i={},l=c.createContext(i);function t(e){const n=c.useContext(l);return c.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),c.createElement(l.Provider,{value:n},e.children)}},93728(e,n,s){s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>t,metadata:()=>c,toc:()=>a});const c=JSON.parse('{"id":"reactjs/Optimizing Event Handlers","title":"Optimizing Event Handlers","description":"useCallback is a React hook used to memoize functions (including event handlers) so their reference stays the same between renders\u2014unless their dependencies change. This helps prevent unnecessary re-renders, especially when functions are passed as props to child components.","source":"@site/docs/reactjs/25. Optimizing Event Handlers.md","sourceDirName":"reactjs","slug":"/reactjs/Optimizing Event Handlers","permalink":"/handbook/docs/reactjs/Optimizing Event Handlers","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":26,"frontMatter":{"sidebar_position":26},"sidebar":"reactjsApiSidebar","previous":{"title":"Expensive Computation","permalink":"/handbook/docs/reactjs/Expensive Computation"},"next":{"title":"Lazy Loading","permalink":"/handbook/docs/reactjs/Lazy Loading"}}');var i=s(74848),l=s(28453);const t={sidebar_position:26},r=void 0,o={},a=[{value:"Example without <code>useCallback</code> (problem)",id:"example-without-usecallback-problem",level:2},{value:"Optimized version using <code>useCallback</code>",id:"optimized-version-using-usecallback",level:2},{value:"Example with dependencies (realistic case)",id:"example-with-dependencies-realistic-case",level:2},{value:"Common real-world use case: list items",id:"common-real-world-use-case-list-items",level:2},{value:"<code>useCallback</code> vs <code>useMemo</code>",id:"usecallback-vs-usememo",level:2},{value:"When to use <code>useCallback</code>",id:"when-to-use-usecallback",level:2}];function d(e){const n={blockquote:"blockquote",br:"br",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"useCallback"})," is a React hook used to memoize functions (including event handlers) so their reference stays the same between renders\u2014unless their dependencies change. This helps prevent unnecessary re-renders, especially when functions are passed as props to child components."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Functions are objects in JavaScript.",(0,i.jsx)(n.br,{}),"\n","Every render creates a new function reference."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Even if a function\u2019s logic doesn\u2019t change, React sees it as \u201cnew,\u201d which can cause:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Memoized children (",(0,i.jsx)(n.code,{children:"React.memo"}),") to re-render"]}),"\n",(0,i.jsx)(n.li,{children:"Unnecessary updates in deeply nested components"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"useCallback"})," solves this by caching the function."]}),"\n",(0,i.jsxs)(n.h2,{id:"example-without-usecallback-problem",children:["Example without ",(0,i.jsx)(n.code,{children:"useCallback"})," (problem)"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'function Parent() {\r\n  const [count, setCount] = React.useState(0);\r\n\r\n  const handleClick = () => {\r\n    console.log("Clicked!");\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <button onClick={() => setCount(count + 1)}>Count: {count}</button>\r\n      <Child onClick={handleClick} />\r\n    </>\r\n  );\r\n}\r\n\r\nconst Child = React.memo(function Child({ onClick }) {\r\n  console.log("Child rendered");\r\n  return <button onClick={onClick}>Child Button</button>;\r\n});\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Clicking Count updates state"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Parent"})," re-renders (expected)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"handleClick"})," is re-created \u274c"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Child"})," re-renders even though behavior didn\u2019t change"]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"optimized-version-using-usecallback",children:["Optimized version using ",(0,i.jsx)(n.code,{children:"useCallback"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'function Parent() {\r\n  const [count, setCount] = React.useState(0);\r\n\r\n  const handleClick = React.useCallback(() => {\r\n    console.log("Clicked!");\r\n  }, []);\r\n\r\n  return (\r\n    <>\r\n      <button onClick={() => setCount(count + 1)}>Count: {count}</button>\r\n      <Child onClick={handleClick} />\r\n    </>\r\n  );\r\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"useCallback"})," returns the same function reference"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"React.memo"})," sees unchanged props"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Child"})," skips re-rendering"]}),"\n",(0,i.jsx)(n.li,{children:"Cleaner, faster UI updates"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"example-with-dependencies-realistic-case",children:"Example with dependencies (realistic case)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"function Parent() {\r\n  const [count, setCount] = React.useState(0);\r\n\r\n  const handleClick = React.useCallback(() => {\r\n    console.log(`Count is ${count}`);\r\n  }, [count]);\r\n\r\n  return (\r\n    <>\r\n      <button onClick={() => setCount(count + 1)}>Count: {count}</button>\r\n      <Child onClick={handleClick} />\r\n    </>\r\n  );\r\n}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["When ",(0,i.jsx)(n.code,{children:"count"})," changes, ",(0,i.jsx)(n.code,{children:"handleClick"})," must change"]}),"\n",(0,i.jsx)(n.li,{children:"React re-creates the function intentionally"}),"\n",(0,i.jsx)(n.li,{children:"This is correct behavior, not a performance issue"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"common-real-world-use-case-list-items",children:"Common real-world use case: list items"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"const handleDelete = React.useCallback((id) => {\r\n  setItems((items) => items.filter((item) => item.id !== id));\r\n}, []);\r\n\r\nreturn items.map((item) => (\r\n  <Item key={item.id} item={item} onDelete={handleDelete} />\r\n));\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"usecallback-vs-usememo",children:[(0,i.jsx)(n.code,{children:"useCallback"})," vs ",(0,i.jsx)(n.code,{children:"useMemo"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"useCallback(fn, deps)"})," \u2248 ",(0,i.jsx)(n.code,{children:"useMemo(() => fn, deps)"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"const memoizedFn = useCallback(() => doSomething(), []);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Memoizes the function reference, not the result."}),"\n",(0,i.jsxs)(n.h2,{id:"when-to-use-usecallback",children:["When to use ",(0,i.jsx)(n.code,{children:"useCallback"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Use it when","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Passing handlers to memoized components"}),"\n",(0,i.jsx)(n.li,{children:"Components render frequently"}),"\n",(0,i.jsx)(n.li,{children:"Large component trees"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Avoid it when","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Function is local only"}),"\n",(0,i.jsx)(n.li,{children:"Component is simple"}),"\n",(0,i.jsx)(n.li,{children:"No measurable performance gain"}),"\n"]}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);