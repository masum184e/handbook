"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[18937],{12517(e,s,n){n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>l,default:()=>o,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"rust/Data Structure/HasMap","title":"HasMap","description":"A HashMap stores data as key\u2013value pairs, allowing you to look up values quickly using keys.","source":"@site/docs/rust/11. Data Structure/5. HasMap.md","sourceDirName":"rust/11. Data Structure","slug":"/rust/Data Structure/HasMap","permalink":"/handbook/docs/rust/Data Structure/HasMap","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{},"sidebar":"rustApiSidebar","previous":{"title":"Tuples","permalink":"/handbook/docs/rust/Data Structure/Tuples"},"next":{"title":"Structs","permalink":"/handbook/docs/rust/Data Structure/Structs"}}');var t=n(74848),i=n(28453);const a={},l=void 0,c={},d=[{value:"Key Characteristics of HashMap",id:"key-characteristics-of-hashmap",level:2},{value:"Creating HashMaps",id:"creating-hashmaps",level:2},{value:"Using <code>new()</code>:",id:"using-new",level:3},{value:"From Vectors (using <code>collect()</code>)",id:"from-vectors-using-collect",level:3},{value:"Inserting and Updating Values",id:"inserting-and-updating-values",level:2},{value:"Insert",id:"insert",level:3},{value:"Overwriting Existing Value",id:"overwriting-existing-value",level:3},{value:"Insert Only If Key Doesn\u2019t Exist (entry)",id:"insert-only-if-key-doesnt-exist-entry",level:3},{value:"Accessing Values",id:"accessing-values",level:2},{value:"Using <code>get()</code>",id:"using-get",level:3},{value:"Using Index Syntax (Panics)",id:"using-index-syntax-panics",level:3},{value:"Iterating Over a HashMap",id:"iterating-over-a-hashmap",level:2},{value:"HashMaps and Ownership",id:"hashmaps-and-ownership",level:2},{value:"Ownership Is Transferred on Insert",id:"ownership-is-transferred-on-insert",level:3},{value:"Using References as Keys",id:"using-references-as-keys",level:3},{value:"Updating Values Based on Old Value",id:"updating-values-based-on-old-value",level:2},{value:"HashMap with Custom Types",id:"hashmap-with-custom-types",level:2},{value:"Keys Must Implement Traits",id:"keys-must-implement-traits",level:3},{value:"HashMap vs Vec of Tuples",id:"hashmap-vs-vec-of-tuples",level:2}];function h(e){const s={blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.p,{children:"A HashMap stores data as key\u2013value pairs, allowing you to look up values quickly using keys."}),"\n",(0,t.jsx)(s.p,{children:"Think of it like:"}),"\n",(0,t.jsxs)(s.blockquote,{children:["\n",(0,t.jsx)(s.p,{children:"A dictionary: word \u2192 meaning\r\nA phonebook: name \u2192 phone number"}),"\n"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:"use std::collections::HashMap;\r\n\r\nlet mut scores = HashMap::new();\n"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"K"})," \u2192 key type"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"V"})," \u2192 value type"]}),"\n",(0,t.jsx)(s.li,{children:"Stored on the heap"}),"\n",(0,t.jsx)(s.li,{children:"Keys must be hashable"}),"\n"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:'use std::collections::HashMap;\r\n\r\nlet mut scores = HashMap::new();\r\nscores.insert("Alice", 90);\r\nscores.insert("Bob", 85);\n'})}),"\n",(0,t.jsx)(s.p,{children:"Maps names to scores."}),"\n",(0,t.jsx)(s.h2,{id:"key-characteristics-of-hashmap",children:"Key Characteristics of HashMap"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Feature"}),(0,t.jsx)(s.th,{children:"HashMap"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Storage"}),(0,t.jsx)(s.td,{children:"Key\u2013Value pairs"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Access time"}),(0,t.jsx)(s.td,{children:"O(1) average"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Order"}),(0,t.jsx)(s.td,{children:"\u274c Not guaranteed"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Duplicate keys"}),(0,t.jsx)(s.td,{children:"\u274c Not allowed"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Memory"}),(0,t.jsx)(s.td,{children:"Heap"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Mutability"}),(0,t.jsx)(s.td,{children:"Optional"})]})]})]}),"\n",(0,t.jsx)(s.h2,{id:"creating-hashmaps",children:"Creating HashMaps"}),"\n",(0,t.jsxs)(s.h3,{id:"using-new",children:["Using ",(0,t.jsx)(s.code,{children:"new()"}),":"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:"let mut map: HashMap<String, i32> = HashMap::new();\n"})}),"\n",(0,t.jsxs)(s.h3,{id:"from-vectors-using-collect",children:["From Vectors (using ",(0,t.jsx)(s.code,{children:"collect()"}),")"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:'use std::collections::HashMap;\r\n\r\nlet keys = vec!["a", "b", "c"];\r\nlet values = vec![1, 2, 3];\r\n\r\nlet map: HashMap<_, _> =\r\n    keys.into_iter().zip(values).collect();\n'})}),"\n",(0,t.jsx)(s.h2,{id:"inserting-and-updating-values",children:"Inserting and Updating Values"}),"\n",(0,t.jsx)(s.h3,{id:"insert",children:"Insert"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:'let mut scores = HashMap::new();\r\nscores.insert("Alice", 90);\n'})}),"\n",(0,t.jsx)(s.h3,{id:"overwriting-existing-value",children:"Overwriting Existing Value"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:'scores.insert("Alice", 95); // replaces 90\n'})}),"\n",(0,t.jsx)(s.h3,{id:"insert-only-if-key-doesnt-exist-entry",children:"Insert Only If Key Doesn\u2019t Exist (entry)"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:'scores.entry("Bob").or_insert(80);\n'})}),"\n",(0,t.jsx)(s.p,{children:"Very useful pattern."}),"\n",(0,t.jsx)(s.h2,{id:"accessing-values",children:"Accessing Values"}),"\n",(0,t.jsxs)(s.h3,{id:"using-get",children:["Using ",(0,t.jsx)(s.code,{children:"get()"})]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:'match scores.get("Alice") {\r\n    Some(score) => println!("Score: {}", score),\r\n    None => println!("Not found"),\r\n}\n'})}),"\n",(0,t.jsxs)(s.p,{children:["Returns ",(0,t.jsx)(s.code,{children:"Option<&V>"})]}),"\n",(0,t.jsx)(s.h3,{id:"using-index-syntax-panics",children:"Using Index Syntax (Panics)"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:'let score = scores["Alice"];\n'})}),"\n",(0,t.jsx)(s.p,{children:"Panics if key doesn\u2019t exist."}),"\n",(0,t.jsx)(s.h2,{id:"iterating-over-a-hashmap",children:"Iterating Over a HashMap"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:'for (name, score) in &scores {\r\n    println!("{}: {}", name, score);\r\n}\n'})}),"\n",(0,t.jsx)(s.p,{children:"Order is random."}),"\n",(0,t.jsx)(s.h2,{id:"hashmaps-and-ownership",children:"HashMaps and Ownership"}),"\n",(0,t.jsx)(s.h3,{id:"ownership-is-transferred-on-insert",children:"Ownership Is Transferred on Insert"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:'let name = String::from("Alice");\r\nlet mut map = HashMap::new();\r\n\r\nmap.insert(name, 90);\r\n// name is no longer usable\n'})}),"\n",(0,t.jsx)(s.h3,{id:"using-references-as-keys",children:"Using References as Keys"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:'let mut map: HashMap<&str, i32> = HashMap::new();\r\nmap.insert("Alice", 90);\n'})}),"\n",(0,t.jsx)(s.p,{children:"String literals live for the entire program."}),"\n",(0,t.jsx)(s.h2,{id:"updating-values-based-on-old-value",children:"Updating Values Based on Old Value"}),"\n",(0,t.jsx)(s.p,{children:"Classic Word Count Example"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:'use std::collections::HashMap;\r\n\r\nlet text = "hello rust hello world";\r\nlet mut map = HashMap::new();\r\n\r\nfor word in text.split_whitespace() {\r\n    let count = map.entry(word).or_insert(0);\r\n    *count += 1;\r\n}\n'})}),"\n",(0,t.jsx)(s.p,{children:"Result:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"hello \u2192 2\r\nrust  \u2192 1\r\nworld \u2192 1\n"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Removing Entries: ",(0,t.jsx)(s.code,{children:'scores.remove("Bob");'})]}),"\n",(0,t.jsx)(s.li,{children:"Checking for Keys"}),"\n"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:'if scores.contains_key("Alice") {\r\n    println!("Alice exists");\r\n}\n'})}),"\n",(0,t.jsx)(s.h2,{id:"hashmap-with-custom-types",children:"HashMap with Custom Types"}),"\n",(0,t.jsx)(s.p,{children:"Using Structs as Values"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:'struct User {\r\n    age: i32,\r\n}\r\n\r\nlet mut users = HashMap::new();\r\nusers.insert("Alice", User { age: 25 });\n'})}),"\n",(0,t.jsx)(s.h3,{id:"keys-must-implement-traits",children:"Keys Must Implement Traits"}),"\n",(0,t.jsxs)(s.p,{children:["Keys must implement: ",(0,t.jsx)(s.code,{children:"Eq"}),", ",(0,t.jsx)(s.code,{children:"Hash"})]}),"\n",(0,t.jsx)(s.p,{children:"Most basic types already do."}),"\n",(0,t.jsx)(s.h2,{id:"hashmap-vs-vec-of-tuples",children:"HashMap vs Vec of Tuples"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Feature"}),(0,t.jsx)(s.th,{children:"HashMap"}),(0,t.jsx)(s.th,{children:(0,t.jsx)(s.code,{children:"Vec<(K, V)>"})})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Lookup"}),(0,t.jsx)(s.td,{children:"Fast"}),(0,t.jsx)(s.td,{children:"Slow"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Order"}),(0,t.jsx)(s.td,{children:"Unordered"}),(0,t.jsx)(s.td,{children:"Ordered"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Best for"}),(0,t.jsx)(s.td,{children:"Frequent search"}),(0,t.jsx)(s.td,{children:"Small datasets"})]})]})]})]})}function o(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},28453(e,s,n){n.d(s,{R:()=>a,x:()=>l});var r=n(96540);const t={},i=r.createContext(t);function a(e){const s=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(i.Provider,{value:s},e.children)}}}]);