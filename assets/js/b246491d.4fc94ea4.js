"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[6055],{5814(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"typescript/Types","title":"Types","description":"Type Annotations","source":"@site/docs/typescript/2. Types.md","sourceDirName":"typescript","slug":"/typescript/Types","permalink":"/handbook/docs/typescript/Types","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"typescriptSidebar","previous":{"title":"Functions","permalink":"/handbook/docs/typescript/Functions"},"next":{"title":"Objects","permalink":"/handbook/docs/typescript/Objects"}}');var i=s(4848),t=s(8453);const d={sidebar_position:4},l=void 0,c={},o=[{value:"Type Annotations",id:"type-annotations",level:2},{value:"<code>unknown</code>",id:"unknown",level:3},{value:"Type Inferences",id:"type-inferences",level:2},{value:"Basic Example",id:"basic-example",level:3},{value:"Common Scenarios of Type Inference",id:"common-scenarios-of-type-inference",level:3},{value:"Type Widening",id:"type-widening",level:3},{value:"Union Types",id:"union-types",level:2},{value:"Intersection Types",id:"intersection-types",level:2},{value:"Union vs Intersection",id:"union-vs-intersection",level:3},{value:"Readonly properties",id:"readonly-properties",level:2},{value:"<code>readonly</code> with Arrays",id:"readonly-with-arrays",level:3},{value:"<code>readonly</code> vs <code>const</code>",id:"readonly-vs-const",level:3},{value:"<code>Readonly&lt;T&gt;</code> Utility Type",id:"readonlyt-utility-type",level:3},{value:"<code>readonly</code> at Declaration",id:"readonly-at-declaration",level:3},{value:"Type Aliases",id:"type-aliases",level:2},{value:"Differences between Type Aliases and Interfaces",id:"differences-between-type-aliases-and-interfaces",level:3}];function a(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"type-annotations",children:"Type Annotations"}),"\n",(0,i.jsx)(n.p,{children:"In TypeScript, a type annotation tells the compiler what type of value a variable, parameter, or function will hold.\r\nIt improves type safety by catching errors during compilation rather than at runtime."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"let variableName: type = value;\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Category"})}),(0,i.jsxs)(n.th,{children:[(0,i.jsx)(n.strong,{children:"Type"})," / ",(0,i.jsx)(n.strong,{children:"Feature"})]}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Example"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Use Case"})}),(0,i.jsx)(n.th,{})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Primitives"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:'let name: string = "Masum";'})}),(0,i.jsx)(n.td,{children:"Text data"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"number"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"let age: number = 25;"})}),(0,i.jsx)(n.td,{children:"Numbers (int/float)"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"boolean"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"let isActive: boolean = true;"})}),(0,i.jsx)(n.td,{children:"True/false"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bigint"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"let big: bigint = 123n;"})}),(0,i.jsx)(n.td,{children:"Arbitrary large integers"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"symbol"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:'let id: symbol = Symbol("id");'})}),(0,i.jsx)(n.td,{children:"Unique IDs"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"null"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"let empty: null = null;"})}),(0,i.jsx)(n.td,{children:"Explicit empty value"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"undefined"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"let notDef: undefined = undefined;"})}),(0,i.jsx)(n.td,{children:"Variable not initialized"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Special"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"any"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:'let anything: any = "hi";'})}),(0,i.jsx)(n.td,{children:"Opt-out of type checking (unsafe)"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"unknown"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:'let value: unknown = "hi";'})}),(0,i.jsxs)(n.td,{children:["Safer alternative to ",(0,i.jsx)(n.code,{children:"any"})]}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"never"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:'function fail(): never { throw new Error("x"); }'})}),(0,i.jsx)(n.td,{children:"Functions that never return"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"void"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"function log(msg: string): void {}"})}),(0,i.jsx)(n.td,{children:"No return value"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Objects"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"object"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"let obj: object = { x: 10 };"})}),(0,i.jsx)(n.td,{children:"Non-primitive types"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Interface"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"interface User { id: number; name: string }"})}),(0,i.jsx)(n.td,{children:"Define object shape"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Class"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"class Person { constructor(public n: string) {} }"})}),(0,i.jsx)(n.td,{children:"OOP style"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Type alias"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"type Point = { x: number; y: number };"})}),(0,i.jsx)(n.td,{children:"Custom named type"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Collections"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Array"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"let nums: number[] = [1,2,3];"})}),(0,i.jsx)(n.td,{children:"Ordered lists"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Tuple"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:'let p: [string, number] = ["Alice", 30];'})}),(0,i.jsx)(n.td,{children:"Fixed-length array"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ReadonlyArray"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"let arr: ReadonlyArray<number> = [1,2];"})}),(0,i.jsx)(n.td,{children:"Immutable arrays"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Combinations"})}),(0,i.jsx)(n.td,{children:"**Union (`"}),(0,i.jsx)(n.td,{children:"`)**"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"let id: string | number;"})}),(0,i.jsx)(n.td,{children:"Multiple possible types"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsxs)(n.strong,{children:["Intersection (",(0,i.jsx)(n.code,{children:"&"}),")"]})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"type P = A & B;"})}),(0,i.jsx)(n.td,{children:"Combine multiple types"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Literal types"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:'let dir: "north" | "south";'})}),(0,i.jsx)(n.td,{children:"Restrict to exact values"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Enums & Generics"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Enum"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"enum Role { Admin, User }"})}),(0,i.jsx)(n.td,{children:"Named constants"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Generics"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"function id<T>(x: T): T { return x; }"})}),(0,i.jsx)(n.td,{children:"Reusable, type-safe"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Utility Types"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Partial<T>"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Partial<User>"})}),(0,i.jsx)(n.td,{children:"Make all fields optional"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Required<T>"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Required<User>"})}),(0,i.jsx)(n.td,{children:"Make all fields required"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Readonly<T>"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Readonly<User>"})}),(0,i.jsx)(n.td,{children:"Make fields immutable"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Pick<T,K>"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:'Pick<User,"id">'})}),(0,i.jsx)(n.td,{children:"Pick subset of fields"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Omit<T,K>"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:'Omit<User,"age">'})}),(0,i.jsx)(n.td,{children:"Exclude certain fields"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Record<K,V>"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Record<string, number>"})}),(0,i.jsx)(n.td,{children:"Map keys to values"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Functions"})}),(0,i.jsx)(n.td,{children:"Function type"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"let add: (a:number,b:number)=>number;"})}),(0,i.jsx)(n.td,{children:"Explicit function typing"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Constructor type"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"type C<T> = new (...a:any[]) => T;"})}),(0,i.jsx)(n.td,{children:"Class constructors"}),(0,i.jsx)(n.td,{})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"unknown",children:(0,i.jsx)(n.code,{children:"unknown"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"unknown"})," type is similar to ",(0,i.jsx)(n.code,{children:"any"}),", but safer.\r\nYou can assign anything to ",(0,i.jsx)(n.code,{children:"unknown"}),", but before using it, you must check its type."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'let input: unknown;\r\n\r\ninput = "Hello";\r\ninput = 42;\r\n\r\n// TypeScript requires a type check before using\r\nif (typeof input === "string") {\r\n  console.log(input.toUpperCase()); // Safe \u2705\r\n}\r\n\r\n// Directly calling input.toUpperCase() would be an error \u274c\n'})}),"\n",(0,i.jsxs)(n.p,{children:["With ",(0,i.jsx)(n.code,{children:"unknown"}),", TypeScript forces you to narrow down the type before using it."]}),"\n",(0,i.jsx)(n.h2,{id:"type-inferences",children:"Type Inferences"}),"\n",(0,i.jsx)(n.p,{children:"In TypeScript, Type Inference means that the compiler can automatically determine the type of a variable, function return, or expression even if you don\u2019t explicitly specify it."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why is Type Inference Important?"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Reduces boilerplate \u2192 You don\u2019t need to annotate everything with types."}),"\n",(0,i.jsx)(n.li,{children:"Keeps code clean \u2192 Less clutter from explicit types everywhere."}),"\n",(0,i.jsx)(n.li,{children:"Maintains type safety \u2192 Even without annotations, TypeScript enforces correct usage."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"basic-example",children:"Basic Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'let message = "Hello, TypeScript!";\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Here, you didn\u2019t write ",(0,i.jsx)(n.code,{children:"let message: string"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"TypeScript infers that message is a string because the initial value is a string."}),"\n",(0,i.jsx)(n.li,{children:"So now:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"message = \"Hi!\"; // \u2705 Allowed\r\nmessage = 42; // \u274c Error: Type 'number' is not assignable to type 'string'\n"})}),"\n",(0,i.jsx)(n.h3,{id:"common-scenarios-of-type-inference",children:"Common Scenarios of Type Inference"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Variable Initialization"}),"\n",(0,i.jsx)(n.p,{children:"If you assign a value at declaration, TypeScript infers the type."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"let age = 25; // inferred as number\r\nlet isActive = true; // inferred as boolean\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Function Return Type"}),"\n",(0,i.jsx)(n.p,{children:"If you don\u2019t explicitly declare the return type, TypeScript infers it."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function add(a: number, b: number) {\r\n  return a + b;\r\n}\r\n// inferred return type: number\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You didn\u2019t write ",(0,i.jsx)(n.code,{children:": number"})," after the function, but TypeScript knows the result of ",(0,i.jsx)(n.code,{children:"a + b"})," is a number."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Array Inference"}),"\n",(0,i.jsx)(n.p,{children:"TypeScript infers array types from initial elements."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'let numbers = [1, 2, 3];\r\n// inferred as number[]\r\n\r\nnumbers.push(4); // \u2705 Allowed\r\nnumbers.push("hi"); // \u274c Error: string not assignable to number\n'})}),"\n",(0,i.jsx)(n.p,{children:"If you mix types:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'let mixed = [1, "hello", true];\r\n// inferred as (string | number | boolean)[]\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Contextual Typing"}),"\n",(0,i.jsx)(n.p,{children:"Sometimes inference works from context."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'window.addEventListener("click", (event) => {\r\n  console.log(event.clientX); // event is inferred as MouseEvent\r\n});\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Here, you didn\u2019t type ",(0,i.jsx)(n.code,{children:"event: MouseEvent"}),". TypeScript inferred it because ",(0,i.jsx)(n.code,{children:'"click"'})," handlers receive a ",(0,i.jsx)(n.code,{children:"MouseEvent"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Best Common Type"}),"\n",(0,i.jsx)(n.p,{children:"When multiple types are possible, TypeScript finds a common type."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"let values = [1, 2, null];\r\n// inferred as (number | null)[]\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"type-widening",children:"Type Widening"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If you don\u2019t give a type or initial value, TypeScript infers ",(0,i.jsx)(n.code,{children:"message: any"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"If you don't give a type, Typescripts infers the type as values type."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"When you declare a variable without assignment:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"let data;\r\n// inferred as 'any'\r\ndata = 42; // allowed\r\ndata = \"hi\"; // allowed\n"})}),"\n",(0,i.jsx)(n.p,{children:"If you assign a literal:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'let status = "loading";\r\n// inferred as string (not the literal "loading")\n'})}),"\n",(0,i.jsx)(n.p,{children:"But if you want a literal type:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'const status = "loading";\r\n// inferred as "loading" (literal type)\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Object Literals Losing Strictness"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'let user = { name: "Alice", age: 25 };\r\nuser.location = "USA"; // \u274c Error: Property \'location\' does not exist\n'})}),"\n",(0,i.jsx)(n.p,{children:"But if you use any inference:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'let user: any = {};\r\nuser.name = "Alice"; // \u2705\r\nuser.age = 25; // \u2705\r\nuser.location = "USA"; // \u2705 (but unsafe!)\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"TypeScript loses track of structure."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"null"})," and ",(0,i.jsx)(n.code,{children:"undefined"})," Issues"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'let value = null;\r\n// inferred type: any\r\nvalue = 123; // \u2705 allowed\r\nvalue = "hello"; // \u2705 allowed\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This can cause confusion because ",(0,i.jsx)(n.code,{children:"value"})," doesn\u2019t stay consistent."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tss",children:'let value: number | null = null;\r\nvalue = 123;     // \u2705\r\nvalue = "hi";    // \u274c Error\n'})}),"\n",(0,i.jsx)(n.h2,{id:"union-types",children:"Union Types"}),"\n",(0,i.jsxs)(n.p,{children:["A Union Type allows a value to be one of several possible types.\r\nIt\u2019s written with the ",(0,i.jsx)(n.code,{children:"|"})," (pipe) symbol."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"let value: string | number;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here, ",(0,i.jsx)(n.code,{children:"value"})," can be either a string or a number."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Type Narrowing with Union"})}),"\n",(0,i.jsx)(n.p,{children:"When you use a union, you may need type checks to access type-specific properties."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'function formatId(id: string | number) {\r\n  if (typeof id === "string") {\r\n    return id.toUpperCase(); // \u2705 Works only for string\r\n  }\r\n  return id.toFixed(2); // \u2705 Works only for number\r\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"intersection-types",children:"Intersection Types"}),"\n",(0,i.jsxs)(n.p,{children:["An Intersection Type combines multiple types into one single type that must include all members of those types.\r\nIt\u2019s written with the ",(0,i.jsx)(n.code,{children:"&"})," (ampersand) symbol."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'type A = { name: string };\r\ntype B = { age: number };\r\n\r\ntype Person = A & B;\r\n\r\nconst user: Person = {\r\n  name: "Alice",\r\n  age: 30,\r\n};\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Here, ",(0,i.jsx)(n.code,{children:"Person"})," must have both ",(0,i.jsx)(n.code,{children:"name"})," and ",(0,i.jsx)(n.code,{children:"age"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Intersection with Primitives"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"type Impossible = string & number;\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This type is never possible (a value can\u2019t be both ",(0,i.jsx)(n.code,{children:"string"})," and ",(0,i.jsx)(n.code,{children:"number"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:["So ",(0,i.jsx)(n.code,{children:"Impossible"})," becomes ",(0,i.jsx)(n.code,{children:"never"})," (an impossible type)."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"union-vs-intersection",children:"Union vs Intersection"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Feature"}),(0,i.jsxs)(n.th,{children:["Union (",(0,i.jsx)(n.code,{children:"|"}),") \u2013 OR"]}),(0,i.jsxs)(n.th,{children:["Intersection (",(0,i.jsx)(n.code,{children:"&"}),") \u2013 AND"]})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Meaning"}),(0,i.jsxs)(n.td,{children:["Value can be ",(0,i.jsx)(n.strong,{children:"one of many types"})]}),(0,i.jsxs)(n.td,{children:["Value must satisfy ",(0,i.jsx)(n.strong,{children:"all types"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Usage"}),(0,i.jsxs)(n.td,{children:["Flexibility (e.g., ",(0,i.jsx)(n.code,{children:"id: string | number"}),")"]}),(0,i.jsxs)(n.td,{children:["Combination (e.g., ",(0,i.jsx)(n.code,{children:"User & Admin"}),")"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Symbol"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"|"})," (pipe)"]}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"&"})," (ampersand)"]})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"readonly-properties",children:"Readonly properties"}),"\n",(0,i.jsxs)(n.h3,{id:"readonly-with-arrays",children:[(0,i.jsx)(n.code,{children:"readonly"})," with Arrays"]}),"\n",(0,i.jsxs)(n.p,{children:["TypeScript also supports ",(0,i.jsx)(n.code,{children:"ReadonlyArray<T>"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const numbers: ReadonlyArray<number> = [1, 2, 3];\r\n\r\nnumbers[0] = 10; // \u274c Error\r\nnumbers.push(4); // \u274c Error\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ReadonlyArray<T>"})," means you cannot modify the array\u2019s contents."]}),"\n",(0,i.jsx)(n.li,{children:"You can still read from it."}),"\n",(0,i.jsxs)(n.li,{children:["If you want a mutable array \u2192 use ",(0,i.jsx)(n.code,{children:"number[]"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["If you want an immutable array \u2192 use ",(0,i.jsx)(n.code,{children:"ReadonlyArray<number>"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"readonly-vs-const",children:[(0,i.jsx)(n.code,{children:"readonly"})," vs ",(0,i.jsx)(n.code,{children:"const"})]}),"\n",(0,i.jsxs)(n.p,{children:["Many beginners confuse ",(0,i.jsx)(n.code,{children:"readonly"})," and ",(0,i.jsx)(n.code,{children:"const"}),". They are different:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"const"}),": prevents reassignment of the variable binding (not the object properties)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"readonly"}),": prevents reassignment of the property inside an object or interface."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'const obj = {\r\n  id: 1,\r\n  name: "Alice",\r\n};\r\n\r\nobj.name = "Bob"; // \u2705 allowed (const doesn\'t protect properties)\r\n\r\ntype Person = {\r\n  readonly id: number;\r\n};\r\n\r\nconst person: Person = { id: 1 };\r\nperson.id = 2; // \u274c Error (readonly protects property)\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"readonlyt-utility-type",children:[(0,i.jsx)(n.code,{children:"Readonly<T>"})," Utility Type"]}),"\n",(0,i.jsxs)(n.p,{children:["TypeScript has a built-in ",(0,i.jsx)(n.code,{children:"Readonly<T>"})," utility type that makes all properties of an object immutable."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'interface Student {\r\n  id: number;\r\n  name: string;\r\n}\r\n\r\nconst s: Readonly<Student> = {\r\n  id: 1,\r\n  name: "Masum",\r\n};\r\n\r\ns.id = 2; // \u274c Error\r\ns.name = "Ali"; // \u274c Error\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"readonly-at-declaration",children:[(0,i.jsx)(n.code,{children:"readonly"})," at Declaration"]}),"\n",(0,i.jsx)(n.p,{children:"You can assign a default value directly."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'class Config {\r\n  readonly appName: string = "MyApp"; // initialized at declaration\r\n  readonly version: number;\r\n\r\n  constructor(version: number) {\r\n    this.version = version; // \u2705 allowed\r\n  }\r\n}\r\n\r\nconst config = new Config(1.0);\r\n\r\nconsole.log(config.appName); // MyApp\r\nconsole.log(config.version); // 1\r\n// config.appName = "OtherApp"; // \u274c Error\n'})}),"\n",(0,i.jsx)(n.h2,{id:"type-aliases",children:"Type Aliases"}),"\n",(0,i.jsx)(n.p,{children:"A Type Alias lets you create a new name (alias) for a type.\r\nIt doesn\u2019t create a new type \u2014 it just gives a custom label to an existing type, which makes code more readable, reusable, and maintainable."}),"\n",(0,i.jsxs)(n.p,{children:["You define a type alias with the ",(0,i.jsx)(n.code,{children:"type"})," keyword."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"type AliasName = TypeDefinition;\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'type UserId = string | number;\r\n\r\nlet id1: UserId = "abc123"; // \u2705 allowed\r\nlet id2: UserId = 42; // \u2705 allowed\r\nlet id3: UserId = true; // \u274c Error (boolean not part of UserId)\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"UserId"})," is just an alias for ",(0,i.jsx)(n.code,{children:"string | number"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["This avoids repeating ",(0,i.jsx)(n.code,{children:"string | number"})," everywhere."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Recursive Type Alias"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'type Category = {\r\n  name: string;\r\n  subCategories?: Category[]; // recursive alias\r\n};\r\n\r\nconst category: Category = {\r\n  name: "Electronics",\r\n  subCategories: [{ name: "Phones" }, { name: "Laptops" }],\r\n};\n'})}),"\n",(0,i.jsx)(n.p,{children:"Type Aliases cannot be reopened or changed later (unlike interfaces)."}),"\n",(0,i.jsx)(n.h3,{id:"differences-between-type-aliases-and-interfaces",children:"Differences between Type Aliases and Interfaces"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Definition"}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.code,{children:"type"})," gives a new name to any type (primitive, union, intersection, object, etc.)."]}),"\n",(0,i.jsxs)(n.li,{children:["An ",(0,i.jsx)(n.code,{children:"interface"})," is specifically used to describe the shape of an object (or function, class, etc.)."]}),"\n"]}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Inheritance"}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Interface can be extended using extends:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"interface Point {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\ninterface Point3D extends Point {\r\n  z: number;\r\n}\r\n\r\nconst point: Point3D = { x: 1, y: 2, z: 3 };\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Type aliases can use intersections to achieve similar results:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"type Point = { x: number; y: number };\r\ntype Point3D = Point & { z: number };\r\n\r\nconst point: Point3D = { x: 1, y: 2, z: 3 };\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsx)(n.li,{children:"Declaration Merging"}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Interfaces can merge if you declare them multiple times with the same name:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'interface User {\r\n  name: string;\r\n}\r\n\r\ninterface User {\r\n  age: number;\r\n}\r\n\r\nconst user: User = { name: "Masum", age: 22 }; // \u2705 Works\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Type aliases cannot merge. Declaring the same type twice causes an error:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"type User = { name: string };\r\ntype User = { age: number }; // \u274c Error: Duplicate identifier 'User'\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"4",children:["\n",(0,i.jsx)(n.li,{children:"Other Type Features"}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Type aliases can represent:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Union types ",(0,i.jsx)(n.code,{children:"type ID = string | number;"})]}),"\n",(0,i.jsxs)(n.li,{children:["Tuples ",(0,i.jsx)(n.code,{children:"type PointTuple = [number, number];"})]}),"\n",(0,i.jsxs)(n.li,{children:["Primitive type ",(0,i.jsx)(n.code,{children:"type Name = string;"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Interfaces cannot represent unions, primitives, or tuples. They are only for object shapes, function types, or classes."}),"\n"]}),"\n",(0,i.jsxs)(n.ol,{start:"5",children:["\n",(0,i.jsx)(n.li,{children:"When to use which?"}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"interface"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"When you expect to extend or implement it."}),"\n",(0,i.jsx)(n.li,{children:"When you want declaration merging."}),"\n",(0,i.jsx)(n.li,{children:"Mostly for object-oriented programming patterns."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"type"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"When you need unions, intersections, tuples, or primitives."}),"\n",(0,i.jsx)(n.li,{children:"For more flexible type compositions."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Interface vs Type Alias"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Feature"}),(0,i.jsx)(n.th,{children:"Interface"}),(0,i.jsx)(n.th,{children:"Type Alias"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Object shape"}),(0,i.jsx)(n.td,{children:"\u2705 Yes"}),(0,i.jsx)(n.td,{children:"\u2705 Yes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Extend / Inherit"}),(0,i.jsxs)(n.td,{children:["\u2705 Yes (",(0,i.jsx)(n.code,{children:"extends"}),")"]}),(0,i.jsxs)(n.td,{children:["\u2705 Yes (",(0,i.jsx)(n.code,{children:"&"}),")"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Declaration merging"}),(0,i.jsx)(n.td,{children:"\u2705 Yes"}),(0,i.jsx)(n.td,{children:"\u274c No"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Union / Intersection"}),(0,i.jsx)(n.td,{children:"\u274c No"}),(0,i.jsx)(n.td,{children:"\u2705 Yes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Primitive / Tuple alias"}),(0,i.jsx)(n.td,{children:"\u274c No"}),(0,i.jsx)(n.td,{children:"\u2705 Yes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Flexibility"}),(0,i.jsx)(n.td,{children:"Less flexible"}),(0,i.jsx)(n.td,{children:"More flexible"})]})]})]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453(e,n,s){s.d(n,{R:()=>d,x:()=>l});var r=s(6540);const i={},t=r.createContext(i);function d(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);