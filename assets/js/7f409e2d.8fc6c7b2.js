"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[5544],{6291:(e,n,i)=>{i.d(n,{A:()=>r});const r=i.p+"assets/images/v8engine-d89249d6174d3be622a57b0cb483f734.png"},7133:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"javascript/Browser Execution/Engine","title":"Engine","description":"JavaScript Engine","source":"@site/docs/javascript/Browser Execution/5. Engine.md","sourceDirName":"javascript/Browser Execution","slug":"/javascript/Browser Execution/Engine","permalink":"/handbook/docs/javascript/Browser Execution/Engine","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{},"sidebar":"javascriptSidebar","previous":{"title":"Bundler","permalink":"/handbook/docs/javascript/Browser Execution/Bundler"},"next":{"title":"Runtime","permalink":"/handbook/docs/javascript/Browser Execution/Runtime"}}');var t=i(4848),o=i(8453);const a={},s=void 0,l={},c=[{value:"Parser &amp; Scanner",id:"parser--scanner",level:2},{value:"Ignition (Interpreter)",id:"ignition-interpreter",level:2},{value:"Profiler &amp; Hot Function Detection",id:"profiler--hot-function-detection",level:2},{value:"TurboFan (Optimizing JIT Compiler)",id:"turbofan-optimizing-jit-compiler",level:2},{value:"Hot Function",id:"hot-function",level:3},{value:"Garbage Collector",id:"garbage-collector",level:2},{value:"1. Memory Allocation (Heap)",id:"1-memory-allocation-heap",level:3},{value:"2. Mark-and-Sweep Algorithm",id:"2-mark-and-sweep-algorithm",level:3},{value:"Mark Phase",id:"mark-phase",level:4},{value:"Sweep Phase",id:"sweep-phase",level:4},{value:"3. Generational Garbage Collection (Young vs Old Generation)",id:"3-generational-garbage-collection-young-vs-old-generation",level:3},{value:"Young Generation:",id:"young-generation",level:4},{value:"Old Generation",id:"old-generation",level:4},{value:"4. Garbage Collection Triggers",id:"4-garbage-collection-triggers",level:3},{value:"Minor GC",id:"minor-gc",level:4},{value:"Major GC",id:"major-gc",level:4},{value:"5. Mark-Sweep &amp; Compaction",id:"5-mark-sweep--compaction",level:3},{value:"6. Reference Counting (Used Sparingly)",id:"6-reference-counting-used-sparingly",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"JavaScript Engine",src:i(6291).A+"",width:"960",height:"720"})}),"\n",(0,t.jsx)(n.p,{children:"V8 is Google\u2019s open-source JavaScript engine, written in C++, responsible for compiling and executing JavaScript code."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"It turns JavaScript source code \u2192 machine code that your CPU executes directly."}),"\n",(0,t.jsx)(n.li,{children:"It\u2019s fast because it uses Just-In-Time (JIT) compilation and smart optimizations."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"parser--scanner",children:"Parser & Scanner"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The Scanner tokenizes the JavaScript source (breaks into symbols, identifiers, keywords)."}),"\n",(0,t.jsx)(n.li,{children:"The Parser turns these tokens into an AST (Abstract Syntax Tree) \u2014 a tree-like representation of code structure."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"ignition-interpreter",children:"Ignition (Interpreter)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Ignition is V8\u2019s interpreter."}),"\n",(0,t.jsx)(n.li,{children:"It takes the AST and converts it into bytecode \u2014 a lightweight, low-level representation of your JS."}),"\n",(0,t.jsx)(n.li,{children:"Then, it executes that bytecode."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Bytecode = intermediate form between source code and machine code."}),"\n",(0,t.jsxs)(n.p,{children:["Bytecode of ",(0,t.jsx)(n.code,{children:"let a = 1 + 2;"})," might look like:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"LdaSmi [1]\r\nAddSmi [2]\r\nStaGlobal a\n"})}),"\n",(0,t.jsx)(n.h2,{id:"profiler--hot-function-detection",children:"Profiler & Hot Function Detection"}),"\n",(0,t.jsx)(n.p,{children:"While Ignition runs the code, V8 profiles it \u2014 meaning it keeps track of:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Which functions run often (\u201chot\u201d functions)"}),"\n",(0,t.jsx)(n.li,{children:"What data types are being used"}),"\n",(0,t.jsx)(n.li,{children:"How objects are shaped (hidden classes)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"When a function runs enough times, it\u2019s marked as hot \u2014 and sent to the TurboFan optimizer."}),"\n",(0,t.jsx)(n.h2,{id:"turbofan-optimizing-jit-compiler",children:"TurboFan (Optimizing JIT Compiler)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"TurboFan compiles hot functions into highly optimized machine code."}),"\n",(0,t.jsx)(n.li,{children:"It makes speculative optimizations (based on observed types and patterns)."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"hot-function",children:"Hot Function"}),"\n",(0,t.jsx)(n.p,{children:"A hot function is a function that gets executed many times or runs in performance-critical parts of your program \u2014 so the engine decides to optimize it into machine code for faster performance."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Why the Concept Exists"})}),"\n",(0,t.jsx)(n.p,{children:"JavaScript engines like V8 use JIT (Just-In-Time) compilation:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Code starts running immediately via an interpreter (Ignition in V8)"}),"\n",(0,t.jsx)(n.li,{children:"Meanwhile, the engine watches how your code behaves at runtime"}),"\n",(0,t.jsx)(n.li,{children:"If a function runs many times and behaves predictably (same argument types, same object shapes) \u2192 it\u2019s hot"}),"\n",(0,t.jsx)(n.li,{children:"Then V8 compiles it into optimized machine code using TurboFan"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This way:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Startup is fast (no heavy compilation upfront)"}),"\n",(0,t.jsx)(n.li,{children:"Performance improves automatically for frequently-used code"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"garbage-collector",children:"Garbage Collector"}),"\n",(0,t.jsx)(n.p,{children:"The V8 engine uses a generational garbage collection strategy to optimize memory management. This approach divides memory into two areas: the young generation and the old generation."}),"\n",(0,t.jsx)(n.p,{children:"JavaScript manages memory automatically \u2014 V8 does this using a Generational Garbage"}),"\n",(0,t.jsx)(n.h3,{id:"1-memory-allocation-heap",children:"1. Memory Allocation (Heap)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"When JavaScript objects (like functions, arrays, and objects) are created, they are allocated in the heap memory."}),"\n",(0,t.jsx)(n.li,{children:"The young generation is where new objects are allocated. Initially, most objects are created here."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"2-mark-and-sweep-algorithm",children:"2. Mark-and-Sweep Algorithm"}),"\n",(0,t.jsx)(n.p,{children:"V8 uses a mark-and-sweep algorithm for garbage collection. The process can be broken down into these steps:"}),"\n",(0,t.jsx)(n.h4,{id:"mark-phase",children:"Mark Phase"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The garbage collector starts by identifying root objects. These are objects that are directly accessible by the program (e.g., global variables, objects referenced in the call stack, and variables that are part of the active execution context)."}),"\n",(0,t.jsx)(n.li,{children:"The GC marks all objects that are reachable from the root objects as alive."}),"\n",(0,t.jsx)(n.li,{children:"Any object that cannot be reached from the root objects is considered unreachable and eligible for garbage collection."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"sweep-phase",children:"Sweep Phase"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Once all reachable objects are marked, the garbage collector will sweep through the heap and free the memory of any objects that are not marked as reachable."}),"\n",(0,t.jsx)(n.li,{children:"These freed objects are effectively removed from memory, making space for new allocations."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"3-generational-garbage-collection-young-vs-old-generation",children:"3. Generational Garbage Collection (Young vs Old Generation)"}),"\n",(0,t.jsx)(n.h4,{id:"young-generation",children:"Young Generation:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"This is where newly created objects are allocated. It is designed to quickly collect short-lived objects that will be discarded soon after their creation."}),"\n",(0,t.jsx)(n.li,{children:"The young generation is smaller and is collected more frequently. V8's GC uses a process called minor GC to clean up the young generation."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"old-generation",children:"Old Generation"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Objects that survive multiple collections in the young generation are promoted to the old generation. These are objects that have longer lifespans (e.g., global objects, or objects stored for an extended period)."}),"\n",(0,t.jsx)(n.li,{children:"The old generation is much larger and is collected less frequently, using a major GC."}),"\n",(0,t.jsx)(n.li,{children:"When a major GC happens, the garbage collector may scan through the entire heap, including the old generation."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"4-garbage-collection-triggers",children:"4. Garbage Collection Triggers"}),"\n",(0,t.jsx)(n.h4,{id:"minor-gc",children:"Minor GC"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Occurs frequently and focuses on cleaning up the young generation."}),"\n",(0,t.jsx)(n.li,{children:"Triggered when the young generation becomes full. It is a relatively quick process because only a small portion of memory is being cleaned."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"major-gc",children:"Major GC"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Occurs less frequently but is more expensive, as it scans the entire heap (young and old generations)."}),"\n",(0,t.jsx)(n.li,{children:"Triggered when the old generation becomes full or when the system needs to reclaim memory."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"5-mark-sweep--compaction",children:"5. Mark-Sweep & Compaction"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"After marking objects and sweeping unreachable ones, V8 may also compact memory. Compaction involves moving live objects closer together to reduce memory fragmentation."}),"\n",(0,t.jsx)(n.li,{children:"The goal of compaction is to make the heap more efficient by minimizing gaps between live objects, improving memory usage."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"6-reference-counting-used-sparingly",children:"6. Reference Counting (Used Sparingly)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Although V8 uses mark-and-sweep primarily, earlier versions of the V8 engine used reference counting. This involved counting the number of references to an object."}),"\n",(0,t.jsx)(n.li,{children:"When the reference count drops to zero (i.e., the object is no longer referenced by any variable), it is immediately collected."}),"\n",(0,t.jsx)(n.li,{children:"However, reference counting has its downsides (such as inability to detect circular references), so it's used minimally in V8 today."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>s});var r=i(6540);const t={},o=r.createContext(t);function a(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);