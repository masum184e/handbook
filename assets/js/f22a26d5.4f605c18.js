"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[39337],{28453(e,n,r){r.d(n,{R:()=>t,x:()=>o});var s=r(96540);const i={},l=s.createContext(i);function t(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),s.createElement(l.Provider,{value:n},e.children)}},94370(e,n,r){r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>a,frontMatter:()=>t,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"nodejs/Clustering","title":"Clustering","description":"Node.js runs on a single-threaded event loop, meaning:","source":"@site/docs/nodejs/18. Clustering.md","sourceDirName":"nodejs","slug":"/nodejs/Clustering","permalink":"/handbook/docs/nodejs/Clustering","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":18,"frontMatter":{},"sidebar":"nodejsApiSidebar","previous":{"title":"Cluster","permalink":"/handbook/docs/nodejs/Cluster"},"next":{"title":"Event Loop","permalink":"/handbook/docs/nodejs/Event Loop"}}');var i=r(74848),l=r(28453);const t={},o=void 0,c={},d=[{value:"How Clustering Works",id:"how-clustering-works",level:2},{value:"When to Use Clustering",id:"when-to-use-clustering",level:2},{value:"HTTP Server Using Cluster",id:"http-server-using-cluster",level:2},{value:"Performance Benefits",id:"performance-benefits",level:2},{value:"Example with CPU-Intensive Task",id:"example-with-cpu-intensive-task",level:2}];function h(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Node.js runs on a single-threaded event loop, meaning:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"One Node.js process can only use one CPU core."}),"\n",(0,i.jsx)(n.li,{children:"On a machine with 4, 8, or more cores, the rest stay unused by a single Node app."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Clustering allows you to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Run multiple Node.js processes (workers)."}),"\n",(0,i.jsx)(n.li,{children:"Each worker uses a separate CPU core."}),"\n",(0,i.jsx)(n.li,{children:"All workers share the same server port."}),"\n",(0,i.jsx)(n.li,{children:"This greatly improves throughput, resilience, and scalability."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"how-clustering-works",children:"How Clustering Works"}),"\n",(0,i.jsxs)(n.p,{children:["Node.js provides a built-in ",(0,i.jsx)(n.code,{children:"cluster"})," module:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Master process:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Manages workers."}),"\n",(0,i.jsx)(n.li,{children:"Distributes incoming connections."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Worker processes:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Each runs its own event loop."}),"\n",(0,i.jsx)(n.li,{children:"Handles incoming requests independently."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The OS load-balances requests across workers."}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use-clustering",children:"When to Use Clustering"}),"\n",(0,i.jsx)(n.p,{children:"Use clustering when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You have a CPU-bound or high-traffic Node.js server."}),"\n",(0,i.jsx)(n.li,{children:"You are deploying on a multi-core machine."}),"\n",(0,i.jsx)(n.li,{children:"You want better fault tolerance (workers can restart if they crash)."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"http-server-using-cluster",children:"HTTP Server Using Cluster"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const cluster = require("cluster");\r\nconst http = require("http");\r\nconst os = require("os");\r\n\r\nconst numCPUs = os.cpus().length;\r\n\r\nif (cluster.isMaster) {\r\n  console.log(`Master process ${process.pid} is running`);\r\n\r\n  // Fork workers (one per CPU core)\r\n  for (let i = 0; i < numCPUs; i++) {\r\n    cluster.fork();\r\n  }\r\n\r\n  // Restart worker if it dies\r\n  cluster.on("exit", (worker, code, signal) => {\r\n    console.log(`Worker ${worker.process.pid} died. Restarting...`);\r\n    cluster.fork();\r\n  });\r\n} else {\r\n  // Workers share the TCP connection\r\n  http\r\n    .createServer((req, res) => {\r\n      res.writeHead(200);\r\n      res.end(`Handled by worker ${process.pid}\\n`);\r\n    })\r\n    .listen(3000);\r\n\r\n  console.log(`Worker ${process.pid} started`);\r\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Detect master vs worker: ",(0,i.jsx)(n.code,{children:"if (cluster.isMaster) {"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Runs only once."}),"\n",(0,i.jsx)(n.li,{children:"Responsible for creating workers."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Fork workers"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"for (let i = 0; i < numCPUs; i++) {\r\n  cluster.fork();\r\n}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Creates one worker process per CPU core."}),"\n",(0,i.jsx)(n.li,{children:"Each worker runs the same script."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Auto-restart crashed workers"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'cluster.on("exit", (worker) => {\r\n  cluster.fork();\r\n});\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Improves reliability."}),"\n",(0,i.jsx)(n.li,{children:"Keeps the cluster at full capacity."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Worker creates the server"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"http.createServer(...).listen(3000);\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"All workers listen on the same port."}),"\n",(0,i.jsx)(n.li,{children:"The master handles connection distribution automatically."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"performance-benefits",children:"Performance Benefits"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Without Cluster"}),(0,i.jsx)(n.th,{children:"With Cluster"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"1 CPU core used"}),(0,i.jsx)(n.td,{children:"All CPU cores used"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Lower throughput"}),(0,i.jsx)(n.td,{children:"Higher throughput"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Single point of failure"}),(0,i.jsx)(n.td,{children:"Fault-tolerant workers"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"example-with-cpu-intensive-task",children:"Example with CPU-Intensive Task"}),"\n",(0,i.jsx)(n.p,{children:"Suppose your server performs heavy computation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function heavyTask() {\r\n  let sum = 0;\r\n  for (let i = 0; i < 1e9; i++) {\r\n    sum += i;\r\n  }\r\n  return sum;\r\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Without clustering:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"One request blocks the event loop."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"With clustering:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Requests are distributed across multiple workers."}),"\n",(0,i.jsx)(n.li,{children:"Other workers remain responsive."}),"\n"]})]})}function a(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);