"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[23416],{15431(e,r,n){n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>c,default:()=>a,frontMatter:()=>d,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"dsa/Concepts/Graph","title":"Graph","description":"Graph Representation","source":"@site/docs/dsa/1. Concepts/12. Graph.md","sourceDirName":"dsa/1. Concepts","slug":"/dsa/Concepts/Graph","permalink":"/handbook/docs/dsa/Concepts/Graph","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":12,"frontMatter":{"title":"Graph","sidebar_position":12},"sidebar":"dsaSidebar","previous":{"title":"Greedy","permalink":"/handbook/docs/dsa/Concepts/Greedy"},"next":{"title":"Tree","permalink":"/handbook/docs/dsa/Concepts/Tree"}}');var i=n(74848),t=n(28453);const d={title:"Graph",sidebar_position:12},c=void 0,l={},h=[{value:"Graph Representation",id:"graph-representation",level:2},{value:"Adjacency Matrix",id:"adjacency-matrix",level:3},{value:"Adjacency List",id:"adjacency-list",level:3},{value:"Edge List",id:"edge-list",level:3},{value:"Adjacency Set / Map",id:"adjacency-set--map",level:3},{value:"Incidence Matrix",id:"incidence-matrix",level:3},{value:"Quick Comparison",id:"quick-comparison",level:3},{value:"Graph Implementation",id:"graph-implementation",level:2},{value:"C Programming",id:"c-programming",level:3},{value:"C++ Programming",id:"c-programming-1",level:3},{value:"Traversing",id:"traversing",level:2},{value:"DFS",id:"dfs",level:3},{value:"BFS",id:"bfs",level:3},{value:"When to Use BFS vs DFS?",id:"when-to-use-bfs-vs-dfs",level:3},{value:"Complexity",id:"complexity",level:3},{value:"Shortest path using BFS",id:"shortest-path-using-bfs",level:2}];function o(e){const r={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.h2,{id:"graph-representation",children:"Graph Representation"}),"\n",(0,i.jsx)(r.h3,{id:"adjacency-matrix",children:"Adjacency Matrix"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["A 2D V\xd7V array (",(0,i.jsx)(r.code,{children:"matrix[i][j]"}),") where:","\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"1"})," (or weight) \u2192 edge exists between vertex ",(0,i.jsx)(r.code,{children:"i"})," and ",(0,i.jsx)(r.code,{children:"j"}),"."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"0"})," \u2192 no edge."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.li,{children:"Works for directed/undirected, weighted/unweighted graphs."}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"    A                  |   | A | B | C | D |\r\n   / \\                 | - | - | - | - | - |\r\n  B---C                | A | 0 | 1 | 1 | 0 |\r\n       \\      =>       | B | 1 | 0 | 1 | 0 |\r\n        D              | C | 1 | 1 | 0 | 1 |\r\n                       | D | 0 | 0 | 1 | 0 |\n"})}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Pros:"})}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:["Fast edge check: ",(0,i.jsx)(r.code,{children:"O(1)"})," to check if edge ",(0,i.jsx)(r.code,{children:"(u, v)"})," exists."]}),"\n",(0,i.jsx)(r.li,{children:"Simple implementation: Very straightforward."}),"\n",(0,i.jsx)(r.li,{children:"Good for dense graphs: When number of edges E \u2248 V^2."}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Cons:"})}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:["Memory heavy: Requires O(V",(0,i.jsx)("sup",{children:"2"}),") space, even if sparse."]}),"\n",(0,i.jsx)(r.li,{children:"Inefficient for sparse graphs: Most of the matrix might be zeros."}),"\n",(0,i.jsx)(r.li,{children:"Slow to iterate neighbors: Takes O(V) to find all neighbors of a vertex."}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"When to use:"})," Small graphs or dense graphs where checking edge existence quickly is needed."]}),"\n",(0,i.jsx)(r.h3,{id:"adjacency-list",children:"Adjacency List"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Each vertex has a list of neighbors."}),"\n",(0,i.jsx)(r.li,{children:"Usually implemented as an array of lists or vectors."}),"\n",(0,i.jsx)(r.li,{children:"Can store weights if needed."}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"    A\r\n   / \\                 A \u2192 B, C\r\n  B---C                B \u2192 A, C\r\n       \\      =>       C \u2192 A, B, D\r\n        D              D \u2192 C\n"})}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Pros:"})}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsx)(r.li,{children:"Space efficient: Uses O(V+E) space, good for sparse graphs."}),"\n",(0,i.jsx)(r.li,{children:"Easy to iterate neighbors: Only iterate over actual edges, not empty slots."}),"\n",(0,i.jsx)(r.li,{children:"Flexible: Can store weights easily."}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Cons:"})}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsx)(r.li,{children:"Edge existence check is slower: Need to search the list \u2192 O(k), where k = degree of vertex."}),"\n",(0,i.jsx)(r.li,{children:"Slightly more complex implementation than a matrix."}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"When to use:"})," Large sparse graphs, most real-world networks (social networks, maps)."]}),"\n",(0,i.jsx)(r.h3,{id:"edge-list",children:"Edge List"}),"\n",(0,i.jsx)(r.p,{children:"A list of all edges. Each edge is stored as a pair (u, v) or (u, v, w) if weighted."}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"    A\r\n   / \\                 (A, B)\r\n  B---C                (A, C)\r\n       \\      =>       (B, C)\r\n        D              (C, D)\n"})}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Pros:"})}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsx)(r.li,{children:"Simple and compact: Good for storing edges only."}),"\n",(0,i.jsx)(r.li,{children:"Easy to implement algorithms like Kruskal\u2019s (MST)."}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Cons:"})}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsx)(r.li,{children:"Slow to check edge existence: O(E) search needed."}),"\n",(0,i.jsx)(r.li,{children:"Hard to iterate neighbors of a vertex efficiently."}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"When to use:"})," Algorithms that process edges directly, e.g., Kruskal\u2019s MST, or input/output of edges."]}),"\n",(0,i.jsx)(r.h3,{id:"adjacency-set--map",children:"Adjacency Set / Map"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Similar to adjacency list but uses hash sets/maps instead of lists."}),"\n",(0,i.jsxs)(r.li,{children:["Example: ",(0,i.jsx)(r.code,{children:"unordered_map<int, unordered_set<int>>"})," in C++."]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Pros:"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Fast edge check: O(1) average for set/map."}),"\n",(0,i.jsx)(r.li,{children:"Space efficient for sparse graphs."}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Cons:"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"More memory overhead than simple lists."}),"\n",(0,i.jsx)(r.li,{children:"Slightly slower iteration than plain arrays/lists."}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"When to use:"})," Sparse graphs when you need fast existence checks for edges."]}),"\n",(0,i.jsx)(r.h3,{id:"incidence-matrix",children:"Incidence Matrix"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["A V\xd7E matrix: ",(0,i.jsx)(r.code,{children:"matrix[i][j] = 1"})," if vertex ",(0,i.jsx)(r.code,{children:"i"})," is incident to edge ",(0,i.jsx)(r.code,{children:"j"}),"."]}),"\n",(0,i.jsx)(r.li,{children:"Rarely used except in special graph algorithms."}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Pros:"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Mathematically elegant; good for theoretical analysis."}),"\n",(0,i.jsx)(r.li,{children:"Can represent multi-graphs easily."}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Cons:"})}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsx)(r.li,{children:"Memory heavy: O(V\xd7E)"}),"\n",(0,i.jsx)(r.li,{children:"Not practical for most programming problems."}),"\n",(0,i.jsx)(r.li,{children:"Edge iteration and neighbor finding is slower."}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"When to use:"})," Academic or theoretical problems, multi-graphs, or algorithms needing incidence info."]}),"\n",(0,i.jsx)(r.h3,{id:"quick-comparison",children:"Quick Comparison"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Representation"}),(0,i.jsx)(r.th,{children:"Space Complexity"}),(0,i.jsx)(r.th,{children:"Edge Check"}),(0,i.jsx)(r.th,{children:"Neighbor Iteration"}),(0,i.jsx)(r.th,{children:"Best For"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Adjacency Matrix"}),(0,i.jsx)(r.td,{children:"O(V\xb2)"}),(0,i.jsx)(r.td,{children:"O(1)"}),(0,i.jsx)(r.td,{children:"O(V)"}),(0,i.jsx)(r.td,{children:"Dense graph, fast edge check"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Adjacency List"}),(0,i.jsx)(r.td,{children:"O(V+E)"}),(0,i.jsx)(r.td,{children:"O(k)"}),(0,i.jsx)(r.td,{children:"O(k)"}),(0,i.jsx)(r.td,{children:"Sparse graph, iterate neighbors"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Edge List"}),(0,i.jsx)(r.td,{children:"O(E)"}),(0,i.jsx)(r.td,{children:"O(E)"}),(0,i.jsx)(r.td,{children:"O(E)"}),(0,i.jsx)(r.td,{children:"Edge-centric algorithms"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Adjacency Set/Map"}),(0,i.jsx)(r.td,{children:"O(V+E)"}),(0,i.jsx)(r.td,{children:"O(1) avg"}),(0,i.jsx)(r.td,{children:"O(k)"}),(0,i.jsx)(r.td,{children:"Sparse graph, fast edge check"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Incidence Matrix"}),(0,i.jsx)(r.td,{children:"O(V*E)"}),(0,i.jsx)(r.td,{children:"O(V)"}),(0,i.jsx)(r.td,{children:"O(E)"}),(0,i.jsx)(r.td,{children:"Multi-graphs, theoretical work"})]})]})]}),"\n",(0,i.jsx)(r.h2,{id:"graph-implementation",children:"Graph Implementation"}),"\n",(0,i.jsx)(r.h3,{id:"c-programming",children:"C Programming"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:"struct Node {\r\n    int vertex;\r\n    struct Node* next;\r\n};\r\n\r\n// Graph structure\r\nstruct Graph {\r\n    int numVertices;\r\n    struct Node** adjLists;\r\n    bool* visited;\r\n};\r\n\r\n// Create a node\r\nstruct Node* createNode(int v) {\r\n    struct Node* newNode = malloc(sizeof(struct Node));\r\n    newNode->vertex = v;\r\n    newNode->next = NULL;\r\n    return newNode;\r\n}\r\n\r\n// Create a graph\r\nstruct Graph* createGraph(int vertices) {\r\n    struct Graph* graph = malloc(sizeof(struct Graph));\r\n    graph->numVertices = vertices;\r\n    graph->adjLists = malloc(vertices * sizeof(struct Node*));\r\n    graph->visited = malloc(vertices * sizeof(bool));\r\n\r\n    for (int i = 0; i < vertices; i++) {\r\n        graph->adjLists[i] = NULL;\r\n        graph->visited[i] = false;\r\n    }\r\n    return graph;\r\n}\r\n\r\n// Add edge (undirected)\r\nvoid addEdge(struct Graph* graph, int src, int dest) {\r\n    // Add edge src -> dest\r\n    struct Node* newNode = createNode(dest);\r\n    newNode->next = graph->adjLists[src];\r\n    graph->adjLists[src] = newNode;\r\n\r\n    // Add edge dest -> src\r\n    newNode = createNode(src);\r\n    newNode->next = graph->adjLists[dest];\r\n    graph->adjLists[dest] = newNode;\r\n}\r\n\r\nint main() {\r\n    struct Graph* graph = createGraph(4);\r\n\r\n    addEdge(graph, 0, 1);\r\n    addEdge(graph, 0, 2);\r\n    addEdge(graph, 1, 2);\r\n    addEdge(graph, 2, 3);\r\n}\n"})}),"\n",(0,i.jsx)(r.h3,{id:"c-programming-1",children:"C++ Programming"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:"class Graph {\r\n    int V;                    // Number of vertices\r\n    vector<list<int>> adj;    // Adjacency list\r\n\r\npublic:\r\n    Graph(int V) {\r\n        this->V = V;\r\n        adj.resize(V);\r\n    }\r\n\r\n    // Add edge (undirected)\r\n    void addEdge(int v, int w) {\r\n        adj[v].push_back(w);\r\n        adj[w].push_back(v);\r\n    }\r\n};\r\n\r\nint main() {\r\n    Graph g(4);\r\n\r\n    g.addEdge(0, 1);\r\n    g.addEdge(0, 2);\r\n    g.addEdge(1, 2);\r\n    g.addEdge(2, 3);\r\n}\n"})}),"\n",(0,i.jsx)(r.h2,{id:"traversing",children:"Traversing"}),"\n",(0,i.jsx)(r.h3,{id:"dfs",children:"DFS"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Recursive/Iterative:"})," Required 3 parameter(adj list, visited nodes, current node)"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:'void dfs(int start) {\r\n    vector<bool> visited(V, false);\r\n    stack<int> s;\r\n\r\n    visited[start] = true;\r\n    s.push(start);\r\n\r\n    cout << "DFS: ";\r\n    while (!s.empty()) {\r\n        int v = s.top();\r\n        s.pop();\r\n        cout << v << " ";\r\n\r\n        for (int neighbor : adj[v]) {\r\n            if (!visited[neighbor]) {\r\n                visited[neighbor] = true;\r\n                s.push(neighbor);\r\n            }\r\n        }\r\n\r\n        cout << endl;\r\n    }\r\n};\n'})}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Itertive:"})," In ",(0,i.jsx)(r.strong,{children:"stack"})," which element insert first, pop out at last, which ",(0,i.jsx)(r.strong,{children:"reverse"})," the order. So iterate the list from last and insert into stack, whish will pop out at last as well, this way the order of traversing maintain properly."]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:'// 1D Array\r\nvoid dfs_helper(int v, vector<bool>& visited) {\r\n    visited[v] = true;\r\n    cout << v << " ";\r\n\r\n    for (int neighbor : adj[v]) {\r\n        if (!visited[neighbor]){\r\n            dfs_helper(neighbor, visited);\r\n        }\r\n    }\r\n}\r\nvoid dfs(int start) {\r\n    vector<bool> visited(V, false);\r\n    cout << "DFS: ";\r\n    dfs_helper(start, visited);\r\n    cout << endl;\r\n}\r\n\r\n// 2D Array\r\nvector<pair<int,int>> directions = {\r\n  {1, 0},   // down\r\n  {-1, 0},  // up\r\n  {0, 1},   // right\r\n  {0, -1}   // left\r\n };\r\n\r\nvoid dfs(vector<vector<int>>& grid, int r, int c) {\r\n  // Boundary & validity check\r\n  if (r < 0 || c < 0 || r >= rows || c >= cols || grid[r][c] == 0)\r\n      return;\r\n\r\n  // Mark as visited\r\n  grid[r][c] = 0;\r\n\r\n  cout << "(" << r << "," << c << ") ";\r\n\r\n  // Explore neighbors\r\n  for (auto dir : directions) {\r\n      dfs(grid, r + dir.first, c + dir.second);\r\n  }\r\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Characterstics:"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["It is useful for tasks like ",(0,i.jsx)(r.strong,{children:"cycle detection"}),", ",(0,i.jsx)(r.strong,{children:"topological sorting"}),", and ",(0,i.jsx)(r.strong,{children:"maze solving"}),"."]}),"\n",(0,i.jsx)(r.li,{children:"Find path without shortest path requirement"}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"bfs",children:"BFS"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Iterative:"})," Just replace stack with queue in dfs, rest is same."]}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:'// 1D Array\r\nvoid bfs(int start) {\r\n    vector<bool> visited(V, false);\r\n    queue<int> q;\r\n\r\n    visited[start] = true;\r\n    q.push(start);\r\n\r\n    cout << "BFS: ";\r\n    while (!q.empty()) {\r\n        int v = q.front();\r\n        q.pop();\r\n        cout << v << " ";\r\n\r\n        for (int neighbor : adj[v]) {\r\n            if (!visited[neighbor]) {\r\n                visited[neighbor] = true;\r\n                s.push(neighbor);\r\n            }\r\n        }\r\n\r\n        cout << endl;\r\n    }\r\n};\r\n\r\n// 2D Array\r\nvector<pair<int,int>> directions = {\r\n    {1, 0},\r\n    {-1, 0},\r\n    {0, 1},\r\n    {0, -1}\r\n};\r\n\r\nvoid bfs(vector<vector<int>>& grid, int startR, int startC) {\r\n    int rows = grid.size();\r\n    int cols = grid[0].size();\r\n\r\n    queue<pair<int,int>> q;\r\n    q.push({startR, startC});\r\n    grid[startR][startC] = 0;  // mark visited\r\n\r\n    while (!q.empty()) {\r\n        auto [r, c] = q.front();\r\n        q.pop();\r\n\r\n        cout << "(" << r << "," << c << ") ";\r\n\r\n        for (auto dir : directions) {\r\n            int newR = r + dir.first;\r\n            int newC = c + dir.second;\r\n\r\n            if (newR >= 0 && newC >= 0 &&\r\n                newR < rows && newC < cols &&\r\n                grid[newR][newC] == 1) {\r\n\r\n                grid[newR][newC] = 0;\r\n                q.push({newR, newC});\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Characterstics:"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Explores neighbors before children(layer by layer)"}),"\n",(0,i.jsxs)(r.li,{children:["Finds ",(0,i.jsx)(r.strong,{children:"shortest path"})," in an ",(0,i.jsx)(r.strong,{children:"unweighted"})," graph"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"when-to-use-bfs-vs-dfs",children:"When to Use BFS vs DFS?"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:(0,i.jsx)(r.strong,{children:"Aspect"})}),(0,i.jsx)(r.th,{children:(0,i.jsx)(r.strong,{children:"BFS"})}),(0,i.jsx)(r.th,{children:(0,i.jsx)(r.strong,{children:"DFS"})})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Shortest Path?"})}),(0,i.jsx)(r.td,{children:"\u2705 Yes (unweighted graphs)"}),(0,i.jsx)(r.td,{children:"\u274c No"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Memory Usage"})}),(0,i.jsx)(r.td,{children:"\ud83d\udfe0 High (stores full layer)"}),(0,i.jsx)(r.td,{children:"\ud83d\udfe2 Lower (stores one path)"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Graph Type?"})}),(0,i.jsx)(r.td,{children:"\ud83d\udfe2 Wide, shallow graphs"}),(0,i.jsx)(r.td,{children:"\ud83d\udfe2 Deep, narrow graphs"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Cycle Detection?"})}),(0,i.jsx)(r.td,{children:"\ud83d\udfe2 Yes"}),(0,i.jsx)(r.td,{children:"\ud83d\udfe2 Yes"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Connected Components?"})}),(0,i.jsx)(r.td,{children:"\ud83d\udfe2 Yes"}),(0,i.jsx)(r.td,{children:"\ud83d\udfe2 Yes"})]})]})]}),"\n",(0,i.jsx)(r.h3,{id:"complexity",children:"Complexity"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"V: Number of vertices (nodes)"}),"\n",(0,i.jsx)(r.li,{children:"E: Number of edges (connections)"}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Time Complexity:"})," O(V + E)"]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Space Complexity:"})," O(V)"]}),"\n",(0,i.jsx)(r.h2,{id:"shortest-path-using-bfs",children:"Shortest path using BFS"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"BFS explores all nodes at distance 1 first, then distance 2, and so on."}),"\n",(0,i.jsx)(r.li,{children:"The first time you reach a node, you have found the shortest path from the source."}),"\n",(0,i.jsx)(r.li,{children:"To extract the path, you need to track the parent of each node."}),"\n",(0,i.jsxs)(r.li,{children:["Create a ",(0,i.jsx)(r.code,{children:"visited"})," array to mark visited nodes."]}),"\n",(0,i.jsxs)(r.li,{children:["Create a ",(0,i.jsx)(r.code,{children:"parent"})," array to store the predecessor of each node.","\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"parent[v] = u"})," the node from which you reached ",(0,i.jsx)(r.code,{children:"v"}),"."]}),"\n"]}),"\n"]}),"\n"]})]})}function a(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},28453(e,r,n){n.d(r,{R:()=>d,x:()=>c});var s=n(96540);const i={},t=s.createContext(i);function d(e){const r=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),s.createElement(t.Provider,{value:r},e.children)}}}]);