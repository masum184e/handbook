"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[5869],{28453(e,n,s){s.d(n,{R:()=>a,x:()=>t});var i=s(96540);const r={},l=i.createContext(r);function a(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(l.Provider,{value:n},e.children)}},62003(e,n,s){s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"system-design/Scalability","title":"Scalability","description":"Scaling in system design refers to the ability of a system to handle increased load or demand by growing in capacity. As your application gains users, handles more requests, or processes more data, scaling ensures it continues to perform well and meet user expectations.","source":"@site/docs/system-design/17. Scalability.md","sourceDirName":"system-design","slug":"/system-design/Scalability","permalink":"/handbook/docs/system-design/Scalability","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":18,"frontMatter":{"sidebar_position":18},"sidebar":"systemDesignSidebar","previous":{"title":"TLS Handshake","permalink":"/handbook/docs/system-design/TLS Handshake"},"next":{"title":"Decentralization","permalink":"/handbook/docs/system-design/Decentralization"}}');var r=s(74848),l=s(28453);const a={sidebar_position:18},t=void 0,o={},c=[{value:"Vertical Scaling (Scaling Up)",id:"vertical-scaling-scaling-up",level:2},{value:"Benefits of Vertical Scalling",id:"benefits-of-vertical-scalling",level:3},{value:"Limitations of Vertical Scalling",id:"limitations-of-vertical-scalling",level:3},{value:"Example of Vertical Scaling",id:"example-of-vertical-scaling",level:3},{value:"After Vertical Scaling",id:"after-vertical-scaling",level:4},{value:"Vertical Scaling for Databases",id:"vertical-scaling-for-databases",level:3},{value:"Performance Comparison of Vertical Scalling",id:"performance-comparison-of-vertical-scalling",level:3},{value:"Horizontal Scaling (Scaling Out)",id:"horizontal-scaling-scaling-out",level:2},{value:"Benefits of Horizontal Scaling",id:"benefits-of-horizontal-scaling",level:3},{value:"Limitations of Horizontal Scaling",id:"limitations-of-horizontal-scaling",level:3},{value:"Horizontal Scaling Architecture",id:"horizontal-scaling-architecture",level:3},{value:"Example of Horizontal Scalling",id:"example-of-horizontal-scalling",level:3},{value:"Step 1: Create a Stateless Node.js App",id:"step-1-create-a-stateless-nodejs-app",level:4},{value:"Step 2: Run Multiple Instances (e.g., Using <code>cluster</code> or Docker)",id:"step-2-run-multiple-instances-eg-using-cluster-or-docker",level:4},{value:"Other Components You Might Add",id:"other-components-you-might-add",level:3},{value:"Strategies to Implement Scaling",id:"strategies-to-implement-scaling",level:2},{value:"Stateless Services",id:"stateless-services",level:3},{value:"Load Balancing",id:"load-balancing",level:3},{value:"Database Scaling",id:"database-scaling",level:3},{value:"Example of Scaling",id:"example-of-scaling",level:2},{value:"Scenario:",id:"scenario",level:3},{value:"Solution:",id:"solution",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Scaling in system design refers to the ability of a system to handle increased load or demand by growing in capacity. As your application gains users, handles more requests, or processes more data, scaling ensures it continues to perform well and meet user expectations."}),"\n",(0,r.jsx)(n.h2,{id:"vertical-scaling-scaling-up",children:"Vertical Scaling (Scaling Up)"}),"\n",(0,r.jsx)(n.p,{children:"Vertical Scaling (also called scaling up) means increasing the capacity of a single machine/server to handle more load. Instead of adding more servers (like in horizontal scaling), you upgrade the existing machine with:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"More powerful CPU"}),"\n",(0,r.jsx)(n.li,{children:"More RAM"}),"\n",(0,r.jsx)(n.li,{children:"Faster SSD storage"}),"\n",(0,r.jsx)(n.li,{children:"Better network bandwidth"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Vertical scaling is often used in:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Monolithic applications"}),"\n",(0,r.jsx)(n.li,{children:"Databases (before sharding/replication)"}),"\n",(0,r.jsx)(n.li,{children:"Early-stage startups where architecture is still simple"}),"\n",(0,r.jsx)(n.li,{children:"Systems with tight dependencies or shared state (where horizontal scaling is hard)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"benefits-of-vertical-scalling",children:"Benefits of Vertical Scalling"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Advantage"}),(0,r.jsx)(n.th,{children:"Explanation"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"\u2705 Simpler architecture"}),(0,r.jsx)(n.td,{children:"No need to manage multiple nodes or distributed systems"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"\u2705 No code changes"}),(0,r.jsx)(n.td,{children:"App continues to run without refactoring"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"\u2705 Faster to implement"}),(0,r.jsx)(n.td,{children:"Just upgrade the hardware or instance type"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"\u2705 Useful for databases"}),(0,r.jsx)(n.td,{children:"Databases benefit from more memory and CPU"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"limitations-of-vertical-scalling",children:"Limitations of Vertical Scalling"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Limitation"}),(0,r.jsx)(n.th,{children:"Explanation"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Hardware limit"}),(0,r.jsx)(n.td,{children:"You can only scale up to the most powerful machine available"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Downtime possible"}),(0,r.jsx)(n.td,{children:"Upgrading may require rebooting the server"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Cost increases steeply"}),(0,r.jsx)(n.td,{children:"Higher-tier machines cost disproportionately more"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"No fault tolerance"}),(0,r.jsx)(n.td,{children:"Single point of failure if the machine crashes"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"example-of-vertical-scaling",children:"Example of Vertical Scaling"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Scenario:"})," You built a Node.js-based blog platform. It runs on a single server (2 vCPU, 4 GB RAM). As traffic increases, your app slows down\u2014especially under heavy request bursts."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solution:"})," You vertically scale by upgrading to a more powerful instance (8 vCPU, 16 GB RAM)."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'// server.js\r\nconst express = require("express");\r\nconst app = express();\r\n\r\napp.get("/", (req, res) => {\r\n  // Simulate heavy computation\r\n  let sum = 0;\r\n  for (let i = 0; i < 1e7; i++) sum += i;\r\n  res.send("Welcome to my blog!");\r\n});\r\n\r\napp.listen(3000, () => console.log("Server started on port 3000"));\n'})}),"\n",(0,r.jsx)(n.p,{children:"On a low-memory, low-CPU server, requests take time and queue up. Users may face timeouts or slow responses."}),"\n",(0,r.jsx)(n.h4,{id:"after-vertical-scaling",children:"After Vertical Scaling"}),"\n",(0,r.jsx)(n.p,{children:"You upgrade the server (e.g., using AWS EC2):"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["From: ",(0,r.jsx)(n.code,{children:"t3.small"})," (2 vCPU, 2GB RAM)"]}),"\n",(0,r.jsxs)(n.li,{children:["To: ",(0,r.jsx)(n.code,{children:"m6i.2xlarge"})," (8 vCPU, 32GB RAM)"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This boosts:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Number of concurrent requests handled"}),"\n",(0,r.jsx)(n.li,{children:"Speed of compute-heavy endpoints"}),"\n",(0,r.jsx)(n.li,{children:"RAM available for Node.js heap and cache"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"No code changes needed."}),"\n",(0,r.jsx)(n.h3,{id:"vertical-scaling-for-databases",children:"Vertical Scaling for Databases"}),"\n",(0,r.jsx)(n.p,{children:"A common use case:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"You're using PostgreSQL with high query volume."}),"\n",(0,r.jsx)(n.li,{children:"Queries are slow due to lack of memory (no room for indexes/cache)."}),"\n",(0,r.jsx)(n.li,{children:"You upgrade the DB instance to get more RAM & CPU."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Tools like Amazon RDS, DigitalOcean Managed DB, or Google Cloud SQL allow one-click vertical scaling."}),"\n",(0,r.jsx)(n.h3,{id:"performance-comparison-of-vertical-scalling",children:"Performance Comparison of Vertical Scalling"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Metric"}),(0,r.jsx)(n.th,{children:"Before Upgrade"}),(0,r.jsx)(n.th,{children:"After Upgrade"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Avg. response time"}),(0,r.jsx)(n.td,{children:"800ms"}),(0,r.jsx)(n.td,{children:"150ms"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Concurrent users"}),(0,r.jsx)(n.td,{children:"100"}),(0,r.jsx)(n.td,{children:"1000+"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Memory usage"}),(0,r.jsx)(n.td,{children:"95% (swap used)"}),(0,r.jsx)(n.td,{children:"50% (no swap)"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"horizontal-scaling-scaling-out",children:"Horizontal Scaling (Scaling Out)"}),"\n",(0,r.jsx)(n.p,{children:"Horizontal Scaling (also called scaling out) is the process of adding more machines or nodes to your system to handle increased load. Instead of upgrading a single machine (vertical scaling), you add more instances of your application or database and distribute traffic or data among them behind a load balancer.."}),"\n",(0,r.jsxs)(n.p,{children:["It require more complex architecture; requires ",(0,r.jsx)(n.strong,{children:"stateless"})," design."]}),"\n",(0,r.jsx)(n.p,{children:"It\u2019s used in:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Web applications serving high traffic (e.g., Netflix, Facebook)"}),"\n",(0,r.jsx)(n.li,{children:"Microservices architectures"}),"\n",(0,r.jsx)(n.li,{children:"Cloud-native systems (Kubernetes, serverless)"}),"\n",(0,r.jsx)(n.li,{children:"Big data processing systems"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"benefits-of-horizontal-scaling",children:"Benefits of Horizontal Scaling"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Advantage"}),(0,r.jsx)(n.th,{children:"Explanation"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"High scalability"}),(0,r.jsx)(n.td,{children:"Add as many servers as needed to meet demand"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"High availability"}),(0,r.jsx)(n.td,{children:"No single point of failure\u2014if one server fails, others handle the load"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Cost efficiency"}),(0,r.jsx)(n.td,{children:"Use many low-cost servers instead of one expensive one"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Fault tolerance"}),(0,r.jsx)(n.td,{children:"Easy to design resilient systems"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Easy automation"}),(0,r.jsx)(n.td,{children:"Works well with autoscaling in cloud environments"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"limitations-of-horizontal-scaling",children:"Limitations of Horizontal Scaling"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Limitation"}),(0,r.jsx)(n.th,{children:"Explanation"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"\ud83d\udeab More complex system"}),(0,r.jsx)(n.td,{children:"Requires load balancing, service discovery, etc."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"\ud83d\udeab Stateless requirement"}),(0,r.jsx)(n.td,{children:"App logic must avoid using local memory for session/state"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"\ud83d\udeab Network overhead"}),(0,r.jsx)(n.td,{children:"Data sharing across nodes adds latency and complexity"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"horizontal-scaling-architecture",children:"Horizontal Scaling Architecture"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"             +-------------------+\r\n             |   Load Balancer   |\r\n             +--------+----------+\r\n                      |\r\n   +------------------+------------------+\r\n   |                  |                  |\r\n+-----+          +-----+            +-----+\r\n| App |          | App |            | App |\r\n| #1  |          | #2  |            | #3  |\r\n+-----+          +-----+            +-----+\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-of-horizontal-scalling",children:"Example of Horizontal Scalling"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Scenario:"})," You built a Node.js API using Express. As traffic increases, a single instance isn\u2019t enough. You need to scale out."]}),"\n",(0,r.jsx)(n.h4,{id:"step-1-create-a-stateless-nodejs-app",children:"Step 1: Create a Stateless Node.js App"}),"\n",(0,r.jsx)(n.p,{children:"You deploy multiple Node.js app instances using a load balancer like NGINX or AWS ELB to distribute incoming HTTP traffic."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'// server.js\r\nconst express = require("express");\r\nconst app = express();\r\n\r\napp.get("/", (req, res) => {\r\n  res.send(`Hello from process ${process.pid}`);\r\n});\r\n\r\napp.listen(3000, () => console.log(`Server running on port 3000`));\n'})}),"\n",(0,r.jsx)(n.p,{children:"You can deploy this app on 3 servers and use a load balancer to route traffic across them."}),"\n",(0,r.jsx)(n.p,{children:"To support horizontal scaling, make sure:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No local in-memory state"}),"\n",(0,r.jsx)(n.li,{children:"Sessions (if any) are stored in Redis or DB"}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"step-2-run-multiple-instances-eg-using-cluster-or-docker",children:["Step 2: Run Multiple Instances (e.g., Using ",(0,r.jsx)(n.code,{children:"cluster"})," or Docker)"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Using ",(0,r.jsx)(n.code,{children:"cluster"})," module (simulates horizontal scaling on one machine):"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'// cluster.js\r\nconst cluster = require("cluster");\r\nconst os = require("os");\r\nconst numCPUs = os.cpus().length;\r\n\r\nif (cluster.isMaster) {\r\n  console.log(`Master ${process.pid} is running`);\r\n  for (let i = 0; i < numCPUs; i++) {\r\n    cluster.fork(); // Spawn worker\r\n  }\r\n} else {\r\n  require("./server"); // Worker runs app\r\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"This runs multiple processes on one machine \u2014 like simulating multiple servers."}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsxs)(n.li,{children:["Real Horizontal Scaling (Multiple Servers + Load Balancer)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Deploy your Node.js app on multiple VMs/containers (e.g., app1, app2, app3)"}),"\n",(0,r.jsx)(n.li,{children:"Use NGINX or cloud load balancer to route traffic across them."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"NGINX config (load balancing):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"http {\r\n  upstream node_backend {\r\n    server 192.168.1.10:3000;\r\n    server 192.168.1.11:3000;\r\n    server 192.168.1.12:3000;\r\n  }\r\n\r\n  server {\r\n    listen 80;\r\n    location / {\r\n      proxy_pass http://node_backend;\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"other-components-you-might-add",children:"Other Components You Might Add"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Session Store:"})," Redis or Memcached (to share sessions across instances)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Service Discovery:"})," If using microservices (e.g., Consul, Eureka)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Containerization:"})," Docker, Kubernetes (to manage scaling and orchestration)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Auto Scaling:"})," AWS Auto Scaling Groups, GCP Instance Groups, or K8s Horizontal Pod Autoscaler"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"strategies-to-implement-scaling",children:"Strategies to Implement Scaling"}),"\n",(0,r.jsx)(n.h3,{id:"stateless-services",children:"Stateless Services"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Ensure your application doesn\u2019t store session or state data in memory. Use external tools like Redis or databases for session storage."}),"\n",(0,r.jsx)(n.li,{children:"This allows easy replication across servers."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"load-balancing",children:"Load Balancing"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Distribute requests across instances."}),"\n",(0,r.jsx)(n.li,{children:"Load balancer uses algorithms like Round Robin, Least Connections, or IP Hashing."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"# Sample NGINX config\r\nupstream backend {\r\n    server app1.example.com;\r\n    server app2.example.com;\r\n    server app3.example.com;\r\n}\r\n\r\nserver {\r\n    listen 80;\r\n    location / {\r\n        proxy_pass http://backend;\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"database-scaling",children:"Database Scaling"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Read Replicas:"})," Separate read traffic from write."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sharding:"})," Partition data across multiple databases."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Caching:"})," Use Redis or Memcached to cache frequent queries."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"example-of-scaling",children:"Example of Scaling"}),"\n",(0,r.jsx)(n.h3,{id:"scenario",children:"Scenario:"}),"\n",(0,r.jsx)(n.p,{children:"You\u2019re building a product catalog service. Initially, you have:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"One Node.js server"}),"\n",(0,r.jsx)(n.li,{children:"One PostgreSQL DB\r\nAs traffic grows, product searches slow down."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"solution",children:"Solution:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scale Node.js horizontally:"})," Use Docker/Kubernetes to spin up multiple Node.js containers."]}),"\n",(0,r.jsx)(n.li,{children:"Introduce Redis Cache:** Cache popular search queries."}),"\n",(0,r.jsx)(n.li,{children:"Use PostgreSQL Read Replicas:** Direct read-heavy operations (like product listings) to replicas."}),"\n",(0,r.jsx)(n.li,{children:"Add Load Balancer:** AWS Application Load Balancer routes traffic across Node.js containers."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);