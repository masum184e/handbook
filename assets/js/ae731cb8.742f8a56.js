"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[9373],{28453(e,n,s){s.d(n,{R:()=>t,x:()=>c});var i=s(96540);const l={},r=i.createContext(l);function t(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:t(e.components),i.createElement(r.Provider,{value:n},e.children)}},79747(e,n,s){s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"rust/Asynchronous/Async I_O","title":"Async I_O","description":"Async I/O means:","source":"@site/docs/rust/Asynchronous/4. Async I_O.md","sourceDirName":"rust/Asynchronous","slug":"/rust/Asynchronous/Async I_O","permalink":"/handbook/docs/rust/Asynchronous/Async I_O","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"rustApiSidebar","previous":{"title":"Async Runtimes","permalink":"/handbook/docs/rust/Asynchronous/Async Runtimes"},"next":{"title":"Streams","permalink":"/handbook/docs/rust/Asynchronous/Streams"}}');var l=s(74848),r=s(28453);const t={},c=void 0,o={},a=[{value:"Why blocking I/O does not scale",id:"why-blocking-io-does-not-scale",level:2},{value:"How async I/O works at the OS level",id:"how-async-io-works-at-the-os-level",level:2},{value:"Async I/O in Rust (API level)",id:"async-io-in-rust-api-level",level:2},{value:"Tokio async TCP example (server)",id:"tokio-async-tcp-example-server",level:2},{value:"What happens step-by-step (deep explanation)",id:"what-happens-step-by-step-deep-explanation",level:2},{value:"Non-blocking file I/O (important caveat)",id:"non-blocking-file-io-important-caveat",level:2},{value:"Timers are also async I/O",id:"timers-are-also-async-io",level:2},{value:"What async I/O is NOT",id:"what-async-io-is-not",level:2},{value:"Common mistakes",id:"common-mistakes",level:2},{value:"Mental model to keep forever",id:"mental-model-to-keep-forever",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.p,{children:"Async I/O means:"}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Performing input/output without blocking the thread while waiting for the OS."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Instead of:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Waiting for data"}),"\n",(0,l.jsx)(n.li,{children:"Parking the thread"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"We:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Ask the OS to notify us when data is ready"}),"\n",(0,l.jsx)(n.li,{children:"Yield control"}),"\n",(0,l.jsx)(n.li,{children:"Resume later"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"This is the foundation of scalable async systems."}),"\n",(0,l.jsx)(n.h2,{id:"why-blocking-io-does-not-scale",children:"Why blocking I/O does not scale"}),"\n",(0,l.jsx)(n.p,{children:"Blocking I/O (classic model)"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"let n = socket.read(&mut buf); // blocks thread\n"})}),"\n",(0,l.jsx)(n.p,{children:"Problems:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"One blocked thread per connection"}),"\n",(0,l.jsx)(n.li,{children:"Thousands of connections = thousands of threads"}),"\n",(0,l.jsx)(n.li,{children:"High memory + context switch overhead"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Async I/O model"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"let n = socket.read(&mut buf).await; // yields\n"})}),"\n",(0,l.jsx)(n.p,{children:"Benefits:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"One thread can manage thousands of sockets"}),"\n",(0,l.jsx)(n.li,{children:"No wasted threads"}),"\n",(0,l.jsx)(n.li,{children:"Predictable latency"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"how-async-io-works-at-the-os-level",children:"How async I/O works at the OS level"}),"\n",(0,l.jsx)(n.p,{children:"Rust does not magically make I/O async."}),"\n",(0,l.jsx)(n.p,{children:"It relies on OS facilities:"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"OS"}),(0,l.jsx)(n.th,{children:"Mechanism"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Linux"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"epoll"})})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"macOS"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"kqueue"})})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Windows"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"IOCP"})})]})]})]}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Register socket with OS"}),"\n",(0,l.jsx)(n.li,{children:"Ask: \u201ctell me when readable/writable\u201d"}),"\n",(0,l.jsx)(n.li,{children:"OS blocks internally"}),"\n",(0,l.jsx)(n.li,{children:"OS sends readiness event"}),"\n",(0,l.jsx)(n.li,{children:"Runtime wakes the future"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"The thread is never blocked waiting for I/O."}),"\n",(0,l.jsx)(n.h2,{id:"async-io-in-rust-api-level",children:"Async I/O in Rust (API level)"}),"\n",(0,l.jsxs)(n.p,{children:["Rust uses: ",(0,l.jsx)(n.code,{children:"AsyncRead"})," , ",(0,l.jsx)(n.code,{children:"AsyncWrite"})]}),"\n",(0,l.jsx)(n.p,{children:"Traits (simplified):"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"trait AsyncRead {\r\n    fn poll_read(\r\n        self: Pin<&mut Self>,\r\n        cx: &mut Context<'_>,\r\n        buf: &mut ReadBuf<'_>,\r\n    ) -> Poll<()>;\r\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["They follow the same ",(0,l.jsx)(n.code,{children:"Future"})," polling rules:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Return ",(0,l.jsx)(n.code,{children:"Pending"})," if not ready"]}),"\n",(0,l.jsx)(n.li,{children:"Register waker"}),"\n",(0,l.jsxs)(n.li,{children:["Return ",(0,l.jsx)(n.code,{children:"Ready"})," when data is available"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"tokio-async-tcp-example-server",children:"Tokio async TCP example (server)"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.code,{children:"Cargo.toml"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-toml",children:'[dependencies]\r\ntokio = { version = "1", features = ["full"] }\n'})}),"\n",(0,l.jsx)(n.p,{children:"Async TCP echo server"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'use tokio::net::{TcpListener, TcpStream};\r\nuse tokio::io::{AsyncReadExt, AsyncWriteExt};\r\n\r\nasync fn handle_client(mut socket: TcpStream) {\r\n    let mut buf = [0; 1024];\r\n\r\n    loop {\r\n        let n = socket.read(&mut buf).await.unwrap();\r\n        if n == 0 {\r\n            break; // client disconnected\r\n        }\r\n\r\n        socket.write_all(&buf[..n]).await.unwrap();\r\n    }\r\n}\r\n\r\n#[tokio::main]\r\nasync fn main() {\r\n    let listener = TcpListener::bind("127.0.0.1:8080").await.unwrap();\r\n\r\n    loop {\r\n        let (socket, _) = listener.accept().await.unwrap();\r\n        tokio::spawn(handle_client(socket));\r\n    }\r\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"what-happens-step-by-step-deep-explanation",children:"What happens step-by-step (deep explanation)"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.code,{children:"listener.accept().await"})}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Registers socket with reactor"}),"\n",(0,l.jsxs)(n.li,{children:["If no client \u2192 returns ",(0,l.jsx)(n.code,{children:"Pending"})]}),"\n",(0,l.jsx)(n.li,{children:"OS waits for connection"}),"\n",(0,l.jsx)(n.li,{children:"OS notifies runtime"}),"\n",(0,l.jsx)(n.li,{children:"Runtime wakes task"}),"\n",(0,l.jsx)(n.li,{children:"Accept resumes"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.code,{children:"socket.read().await"})}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Tries reading from socket"}),"\n",(0,l.jsxs)(n.li,{children:["If no data \u2192 ",(0,l.jsx)(n.code,{children:"Pending"})]}),"\n",(0,l.jsx)(n.li,{children:"Registers waker"}),"\n",(0,l.jsx)(n.li,{children:"OS waits for data"}),"\n",(0,l.jsx)(n.li,{children:"OS signals readiness"}),"\n",(0,l.jsx)(n.li,{children:"Task resumes"}),"\n",(0,l.jsx)(n.li,{children:"Read completes"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Multiple clients"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Each client = one task"}),"\n",(0,l.jsx)(n.li,{children:"Tasks are lightweight"}),"\n",(0,l.jsx)(n.li,{children:"Thousands of connections per thread"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"non-blocking-file-io-important-caveat",children:"Non-blocking file I/O (important caveat)"}),"\n",(0,l.jsx)(n.p,{children:"Files are tricky"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Most OSes do not support async file IO well"}),"\n",(0,l.jsx)(n.li,{children:"Tokio uses blocking threads under the hood"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'use tokio::fs;\r\n\r\nlet content = fs::read_to_string("file.txt").await.unwrap();\n'})}),"\n",(0,l.jsx)(n.p,{children:"This is async from your POV, but internally:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Offloaded to a thread pool"}),"\n",(0,l.jsx)(n.li,{children:"Avoids blocking executor threads"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"timers-are-also-async-io",children:"Timers are also async I/O"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"use tokio::time::{sleep, Duration};\r\n\r\nsleep(Duration::from_secs(1)).await;\n"})}),"\n",(0,l.jsx)(n.p,{children:"Internally:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Timer wheel / heap"}),"\n",(0,l.jsx)(n.li,{children:"OS timer"}),"\n",(0,l.jsx)(n.li,{children:"Waker triggered on timeout"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"what-async-io-is-not",children:"What async I/O is NOT"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Parallel CPU work"}),"\n",(0,l.jsx)(n.li,{children:"Faster computation"}),"\n",(0,l.jsx)(n.li,{children:"Thread replacement"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Async I/O is about waiting efficiently."}),"\n",(0,l.jsx)(n.h2,{id:"common-mistakes",children:"Common mistakes"}),"\n",(0,l.jsx)(n.p,{children:"Blocking calls in async code"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'std::fs::read("file.txt"); // blocks runtime\n'})}),"\n",(0,l.jsxs)(n.p,{children:["Holding locks across ",(0,l.jsx)(n.code,{children:".await"})]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"let guard = mutex.lock().unwrap();\r\ndo_async().await; // DEADLOCK risk\n"})}),"\n",(0,l.jsx)(n.p,{children:"Mixing runtimes"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"Tokio socket \u2260 async-std socket.\n"})}),"\n",(0,l.jsx)(n.h2,{id:"mental-model-to-keep-forever",children:"Mental model to keep forever"}),"\n",(0,l.jsx)(n.p,{children:"Think of async I/O as:"}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"\u201cRegister interest \u2192 yield \u2192 resume on readiness.\u201d"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Or:"}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"\u201cDon\u2019t wait. Ask to be notified.\u201d"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}}}]);