"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[7524],{2020:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"golang/Internal Memory","title":"Internal Memory","description":"When we talk about \\"internal memory\\" in Go (or any language), we\u2019re referring to how data is stored and managed in the computer\u2019s RAM while the program runs.","source":"@site/docs/golang/11. Internal Memory.md","sourceDirName":"golang","slug":"/golang/Internal Memory","permalink":"/handbook/docs/golang/Internal Memory","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":12,"frontMatter":{"sidebar_position":12},"sidebar":"golangSidebar","previous":{"title":"Scoping","permalink":"/handbook/docs/golang/Scoping"},"next":{"title":"Memory Allocation","permalink":"/handbook/docs/golang/Memory Allocation"}}');var t=r(4848),a=r(8453);const l={sidebar_position:12},i=void 0,o={},d=[{value:"Memory Layout",id:"memory-layout",level:2},{value:"Stack",id:"stack",level:2},{value:"Heap",id:"heap",level:2},{value:"Data Segment",id:"data-segment",level:2},{value:"Code Segment",id:"code-segment",level:2},{value:"Stack vs Heap",id:"stack-vs-heap",level:2},{value:"Memory Escape",id:"memory-escape",level:2}];function c(e){const n={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:'When we talk about "internal memory" in Go (or any language), we\u2019re referring to how data is stored and managed in the computer\u2019s RAM while the program runs.'}),"\n",(0,t.jsx)(n.p,{children:"Go divides internal memory into several important areas:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Stack \u2013 Small, fast memory used for function calls and local variables."}),"\n",(0,t.jsx)(n.li,{children:"Heap \u2013 Larger memory area used for dynamically allocated variables."}),"\n",(0,t.jsx)(n.li,{children:"Data Segment \u2013 For global and static variables."}),"\n",(0,t.jsx)(n.li,{children:"Code Segment \u2013 Where compiled machine instructions are stored."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"memory-layout",children:"Memory Layout"}),"\n",(0,t.jsx)(n.p,{children:"When a Go program runs, memory is roughly divided like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"+---------------------+   <- High memory addresses\r\n|   Command Line Args |\r\n+---------------------+\r\n|   Environment Vars  |\r\n+---------------------+\r\n|       Stack         |  <- Each goroutine has its own stack\r\n+---------------------+\r\n|       Heap          |  <- Shared between all goroutines\r\n+---------------------+\r\n|  Global Variables   |\r\n+---------------------+\r\n|   Program Code      |\r\n+---------------------+   <- Low memory addresses\n"})}),"\n",(0,t.jsx)(n.h2,{id:"stack",children:"Stack"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Stores function call frames:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Local variables"}),"\n",(0,t.jsx)(n.li,{children:"Function parameters"}),"\n",(0,t.jsx)(n.li,{children:"Return addresses"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Automatically cleaned up after a function returns."}),"\n",(0,t.jsx)(n.li,{children:"Very fast because it works like a LIFO (Last In, First Out) structure."}),"\n",(0,t.jsx)(n.li,{children:"Limited in size (default goroutine stack starts small, grows automatically)."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"func add(a, b int) int {\r\n    result := a + b // 'result' stored on stack\r\n    return result\r\n}\r\n\r\nfunc main() {\r\n    sum := add(5, 3) // 'sum' stored on stack\r\n    fmt.Println(sum)\r\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"a"}),", ",(0,t.jsx)(n.code,{children:"b"}),", and ",(0,t.jsx)(n.code,{children:"result"})," live in the stack frame of ",(0,t.jsx)(n.code,{children:"add()"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"sum"})," lives in the stack frame of ",(0,t.jsx)(n.code,{children:"main()"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"heap",children:"Heap"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Stores dynamically allocated memory."}),"\n",(0,t.jsx)(n.li,{children:"Managed by Go\u2019s garbage collector."}),"\n",(0,t.jsx)(n.li,{children:"Slower than stack, but size is much bigger."}),"\n",(0,t.jsx)(n.li,{children:"Memory stays allocated until garbage collector removes it."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"func createSlice() *[]int {\r\n    nums := []int{1, 2, 3} // allocated on heap\r\n    return &nums\r\n}\r\n\r\nfunc main() {\r\n    slicePtr := createSlice()\r\n    fmt.Println(*slicePtr)\r\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"nums"})," escapes to the heap because we return a pointer to it."]}),"\n",(0,t.jsxs)(n.li,{children:["Even after ",(0,t.jsx)(n.code,{children:"createSlice()"})," ends, ",(0,t.jsx)(n.code,{children:"nums"})," stays in memory (heap) until GC clears it."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"data-segment",children:"Data Segment"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Stores global variables and constants."}),"\n",(0,t.jsx)(n.li,{children:"Exists for the entire lifetime of the program"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"var globalCount int = 100 // stored in data segment\r\n\r\nfunc main() {\r\n    fmt.Println(globalCount)\r\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"globalCount"})," is stored in a fixed memory location in the data segment."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"code-segment",children:"Code Segment"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Stores the compiled binary instructions of your Go program."}),"\n",(0,t.jsx)(n.li,{children:"Read-only for safety."}),"\n",(0,t.jsx)(n.li,{children:"Rarely manipulated directly by Go developers."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"stack-vs-heap",children:"Stack vs Heap"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Feature"}),(0,t.jsx)(n.th,{children:"Stack"}),(0,t.jsx)(n.th,{children:"Heap"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Speed"})}),(0,t.jsx)(n.td,{children:"Fast"}),(0,t.jsx)(n.td,{children:"Slower"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Size"})}),(0,t.jsx)(n.td,{children:"Small, grows per goroutine"}),(0,t.jsx)(n.td,{children:"Large"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Lifetime"})}),(0,t.jsx)(n.td,{children:"Until function ends"}),(0,t.jsx)(n.td,{children:"Until GC cleans it"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Management"})}),(0,t.jsx)(n.td,{children:"Automatic (LIFO)"}),(0,t.jsx)(n.td,{children:"Garbage Collector"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Best for"})}),(0,t.jsx)(n.td,{children:"Local, short-lived variables"}),(0,t.jsx)(n.td,{children:"Long-lived, shared data"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"memory-escape",children:"Memory Escape"}),"\n",(0,t.jsx)(n.p,{children:"Go decides where variables go (stack or heap) at compile time.\r\nIf a variable \u201cescapes\u201d a function (returned or referenced externally), it goes to the heap."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"func heapExample() *int {\r\n    x := 42\r\n    return &x // escapes to heap\r\n}\r\n\r\nfunc stackExample() int {\r\n    x := 42\r\n    return x // stays in stack\r\n}\r\n\r\nfunc main() {\r\n    heapPtr := heapExample()\r\n    fmt.Println(*heapPtr)\r\n\r\n    stackVal := stackExample()\r\n    fmt.Println(stackVal)\r\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>i});var s=r(6540);const t={},a=s.createContext(t);function l(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);