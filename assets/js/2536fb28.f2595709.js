"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[57201],{28453(e,n,i){i.d(n,{R:()=>l,x:()=>a});var r=i(96540);const s={},t=r.createContext(s);function l(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(t.Provider,{value:n},e.children)}},99915(e,n,i){i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"dsa/Concepts/Searching","title":"Searching","description":"\x3c!-- ## Problems","source":"@site/docs/dsa/1. Concepts/9. Searching.md","sourceDirName":"dsa/1. Concepts","slug":"/dsa/Concepts/Searching","permalink":"/handbook/docs/dsa/Concepts/Searching","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"title":"Searching","sidebar_position":9},"sidebar":"dsaSidebar","previous":{"title":"Bit Manipulation","permalink":"/handbook/docs/dsa/Concepts/Bit Manipulation"},"next":{"title":"Linked List","permalink":"/handbook/docs/dsa/Concepts/Linked List"}}');var s=i(74848),t=i(28453);const l={title:"Searching",sidebar_position:9},a=void 0,o={},d=[{value:"Conditions of Binary Search",id:"conditions-of-binary-search",level:2},{value:"Why Binary Search is Not Efficient on Linked List",id:"why-binary-search-is-not-efficient-on-linked-list",level:3},{value:"Complexity of Binary Search",id:"complexity-of-binary-search",level:2},{value:"Lower Bound",id:"lower-bound",level:2},{value:"Upper Bound",id:"upper-bound",level:2},{value:"Binary Search on 2D Arrays",id:"binary-search-on-2d-arrays",level:2},{value:"Search in Infinite/Unknown Size Arrays",id:"search-in-infiniteunknown-size-arrays",level:2}];function c(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"conditions-of-binary-search",children:"Conditions of Binary Search"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"The data structure (array/list) must be sorted."}),"\n",(0,s.jsx)(n.li,{children:"The elements must allow random access (so binary search works well with arrays, but not linked lists without modifications)."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"why-binary-search-is-not-efficient-on-linked-list",children:"Why Binary Search is Not Efficient on Linked List"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"In a linked list, accessing the middle element requires traversing nodes from the head \u2192 O(n)."}),"\n",(0,s.jsx)(n.li,{children:"Binary Search depends on direct middle access (O(1) in arrays)."}),"\n",(0,s.jsx)(n.li,{children:"Hence, overall complexity in linked lists becomes O(nlogn), worse than a simple linear search O(n)."}),"\n",(0,s.jsx)(n.li,{children:"Special cases: binary search can still be implemented using fast and slow pointers, Use slow and fast pointers to find middle node. Then recurse/search left or right half. But it\u2019s rarely used in practice."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"complexity-of-binary-search",children:"Complexity of Binary Search"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Time Complexity:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Best case: O(1) (element found at first mid)."}),"\n",(0,s.jsx)(n.li,{children:"Worst/Average: O(logn)."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Space Complexity:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Iterative: O(1)."}),"\n",(0,s.jsx)(n.li,{children:"Recursive: O(logn) (stack calls)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"lower-bound",children:"Lower Bound"}),"\n",(0,s.jsx)(n.p,{children:"The lower bound of a target value is the first position in a sorted array where the element is greater than or equal to the target."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If the target exists \u2192 it gives the first index of that target."}),"\n",(0,s.jsx)(n.li,{children:"If the target doesn\u2019t exist \u2192 it gives the index where the element could be inserted while keeping the array sorted"}),"\n",(0,s.jsxs)(n.li,{children:["Example: In ",(0,s.jsx)(n.code,{children:"[1, 2, 4, 4, 5]"}),", lower bound of 4 = index 2."]}),"\n",(0,s.jsx)(n.li,{children:"Useful in searching with duplicates."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"upper-bound",children:"Upper Bound"}),"\n",(0,s.jsx)(n.p,{children:"The upper bound of a target value is the first position in a sorted array where the element is greater than the target."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If the target exists multiple times \u2192 it gives the index of the element just after the last occurrence."}),"\n",(0,s.jsx)(n.li,{children:"If the target doesn\u2019t exist \u2192 it gives the index where an element greater than target could be inserted."}),"\n",(0,s.jsxs)(n.li,{children:["Example: In ",(0,s.jsx)(n.code,{children:"[1, 2, 4, 4, 5]"}),", upper bound of 4 = index 4."]}),"\n",(0,s.jsx)(n.li,{children:"Used in range queries, frequency count."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"binary-search-on-2d-arrays",children:"Binary Search on 2D Arrays"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If matrix is row-wise & column-wise sorted, binary search can be applied:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Flatten 2D into 1D index."}),"\n",(0,s.jsx)(n.li,{children:"Or do stepwise search (start from top-right or bottom-left)."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Example: searching element in a matrix efficiently in O(log(m\xd7n))."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"search-in-infiniteunknown-size-arrays",children:"Search in Infinite/Unknown Size Arrays"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When array size is not known (like an infinite stream)."}),"\n",(0,s.jsxs)(n.li,{children:["Technique:","\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Start with bound = 1."}),"\n",(0,s.jsx)(n.li,{children:"Double bound (2, 4, 8, \u2026) until arr[bound] >= target."}),"\n",(0,s.jsx)(n.li,{children:"Apply binary search within last known range."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Used in problems like searching in online data streams."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);