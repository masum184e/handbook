"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[65243],{28453(e,n,r){r.d(n,{R:()=>o,x:()=>t});var l=r(96540);const s={},i=l.createContext(s);function o(e){const n=l.useContext(i);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),l.createElement(i.Provider,{value:n},e.children)}},47935(e,n,r){r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>c});const l=JSON.parse('{"id":"rust/Borrowing","title":"Borrowing","description":"Borrowing lets you use a value without taking ownership of it.","source":"@site/docs/rust/7. Borrowing.md","sourceDirName":"rust","slug":"/rust/Borrowing","permalink":"/handbook/docs/rust/Borrowing","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{},"sidebar":"rustApiSidebar","previous":{"title":"Ownership Rules","permalink":"/handbook/docs/rust/Ownership Rules"},"next":{"title":"Lifetimes","permalink":"/handbook/docs/rust/Lifetimes"}}');var s=r(74848),i=r(28453);const o={},t=void 0,a={},c=[{value:"Why Borrowing Exists",id:"why-borrowing-exists",level:2},{value:"Immutable Borrowing (<code>&amp;T</code>)",id:"immutable-borrowing-t",level:2},{value:"Mutable Borrowing (<code>&amp;mut T</code>)",id:"mutable-borrowing-mut-t",level:2},{value:"The Golden Borrowing Rules",id:"the-golden-borrowing-rules",level:2},{value:"Rule 1: Multiple immutable borrows OR one mutable borrow",id:"rule-1-multiple-immutable-borrows-or-one-mutable-borrow",level:3},{value:"Borrow Scopes (Non-Lexical Lifetimes)",id:"borrow-scopes-non-lexical-lifetimes",level:2},{value:"Mutable + Immutable Borrowing (Common Error)",id:"mutable--immutable-borrowing-common-error",level:2},{value:"Borrowing in Functions",id:"borrowing-in-functions",level:2},{value:"Immutable borrow",id:"immutable-borrow",level:3},{value:"Borrowing Prevents Dangling References",id:"borrowing-prevents-dangling-references",level:2},{value:"Borrowing with Slices (Very Common)",id:"borrowing-with-slices-very-common",level:2},{value:"Mental Model (This Helps a LOT)",id:"mental-model-this-helps-a-lot",level:2},{value:"Why Borrowing Is a Big Deal",id:"why-borrowing-is-a-big-deal",level:2}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Borrowing lets you use a value without taking ownership of it.\r\nYou do this with references."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Immutable borrow \u2192 ",(0,s.jsx)(n.code,{children:"&T"})]}),"\n",(0,s.jsxs)(n.li,{children:["Mutable borrow \u2192 ",(0,s.jsx)(n.code,{children:"&mut T"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Rust enforces strict rules so memory stays safe at compile time, with zero runtime cost."}),"\n",(0,s.jsx)(n.h2,{id:"why-borrowing-exists",children:"Why Borrowing Exists"}),"\n",(0,s.jsx)(n.p,{children:"Without borrowing, you\u2019d constantly move ownership into functions and back out:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'fn print(s: String) -> String {\r\n    println!("{}", s);\r\n    s\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"That\u2019s clunky."}),"\n",(0,s.jsx)(n.p,{children:"Borrowing solves this by allowing temporary access without transferring ownership."}),"\n",(0,s.jsxs)(n.h2,{id:"immutable-borrowing-t",children:["Immutable Borrowing (",(0,s.jsx)(n.code,{children:"&T"}),")"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Read-only access"}),"\n",(0,s.jsx)(n.li,{children:"Any number of immutable borrows allowed"}),"\n",(0,s.jsx)(n.li,{children:"Ownership stays with the original variable"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'fn print_length(s: &String) {\r\n    println!("Length: {}", s.len());\r\n}\r\n\r\nfn main() {\r\n    let s = String::from("hello");\r\n\r\n    print_length(&s);\r\n    print_length(&s);\r\n\r\n    println!("{}", s); // still valid\r\n}\n'})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"s"})," owns the ",(0,s.jsx)(n.code,{children:"String"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"&s"})," creates an immutable reference"]}),"\n",(0,s.jsx)(n.li,{children:"The function borrows the value"}),"\n",(0,s.jsx)(n.li,{children:"No ownership is transferred"}),"\n",(0,s.jsx)(n.li,{children:"Multiple immutable borrows are allowed"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Think of immutable borrows as many people reading the same book\u2014no one can change it."}),"\n",(0,s.jsxs)(n.h2,{id:"mutable-borrowing-mut-t",children:["Mutable Borrowing (",(0,s.jsx)(n.code,{children:"&mut T"}),")"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Read and write access"}),"\n",(0,s.jsx)(n.li,{children:"Exactly one mutable borrow at a time"}),"\n",(0,s.jsxs)(n.li,{children:["The original value must be declared ",(0,s.jsx)(n.code,{children:"mut"})]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'fn add_world(s: &mut String) {\r\n    s.push_str(" world");\r\n}\r\n\r\nfn main() {\r\n    let mut s = String::from("hello");\r\n\r\n    add_world(&mut s);\r\n    println!("{}", s); // "hello world"\r\n}\n'})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"s"})," owns the ",(0,s.jsx)(n.code,{children:"String"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"&mut s"})," creates a mutable reference"]}),"\n",(0,s.jsx)(n.li,{children:"The function can modify the data"}),"\n",(0,s.jsxs)(n.li,{children:["Ownership remains in ",(0,s.jsx)(n.code,{children:"main"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Think of mutable borrowing as one person editing the document\u2014no one else can even read it at the same time."}),"\n",(0,s.jsx)(n.h2,{id:"the-golden-borrowing-rules",children:"The Golden Borrowing Rules"}),"\n",(0,s.jsx)(n.p,{children:"Rust enforces these rules at compile time:"}),"\n",(0,s.jsx)(n.h3,{id:"rule-1-multiple-immutable-borrows-or-one-mutable-borrow",children:"Rule 1: Multiple immutable borrows OR one mutable borrow"}),"\n",(0,s.jsx)(n.p,{children:"\u2705 Allowed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let r1 = &s;\r\nlet r2 = &s;\n"})}),"\n",(0,s.jsx)(n.p,{children:"\u2705 Allowed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let r = &mut s;\n"})}),"\n",(0,s.jsx)(n.p,{children:"\u274c Not allowed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let r1 = &s;\r\nlet r2 = &mut s; // ERROR\n"})}),"\n",(0,s.jsx)(n.p,{children:"\u274c Not allowed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let r1 = &mut s;\r\nlet r2 = &mut s; // ERROR\n"})}),"\n",(0,s.jsx)(n.p,{children:"Why this rule exists"}),"\n",(0,s.jsx)(n.p,{children:"It prevents data races:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"One thread reads while another writes \u2192 inconsistent state"}),"\n",(0,s.jsx)(n.li,{children:"Two writers at once \u2192 corrupted data"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Rust stops these problems before your code runs."}),"\n",(0,s.jsx)(n.h2,{id:"borrow-scopes-non-lexical-lifetimes",children:"Borrow Scopes (Non-Lexical Lifetimes)"}),"\n",(0,s.jsx)(n.p,{children:"Rust is smarter than it looks."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let mut s = String::from("hello");\r\n\r\nlet r1 = &s;\r\nprintln!("{}", r1); // last use of r1\r\n\r\nlet r2 = &mut s; // \u2705 allowed\r\nr2.push_str(" world");\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Even though ",(0,s.jsx)(n.code,{children:"r1"})," is still \u201cin scope\u201d textually, Rust sees it\u2019s no longer used and ends the borrow early."]}),"\n",(0,s.jsx)(n.p,{children:"This is called Non-Lexical Lifetimes (NLL)."}),"\n",(0,s.jsx)(n.h2,{id:"mutable--immutable-borrowing-common-error",children:"Mutable + Immutable Borrowing (Common Error)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let mut s = String::from("hello");\r\n\r\nlet r1 = &s;\r\nlet r2 = &s;\r\n\r\nlet r3 = &mut s; // \u274c error\n'})}),"\n",(0,s.jsx)(n.p,{children:"Fix it like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let mut s = String::from("hello");\r\n\r\n{\r\n    let r1 = &s;\r\n    let r2 = &s;\r\n    println!("{} {}", r1, r2);\r\n} // r1 and r2 go out of scope\r\n\r\nlet r3 = &mut s; // \u2705 OK\n'})}),"\n",(0,s.jsx)(n.h2,{id:"borrowing-in-functions",children:"Borrowing in Functions"}),"\n",(0,s.jsx)(n.h3,{id:"immutable-borrow",children:"Immutable borrow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"fn calculate_length(s: &String) -> usize {\r\n    s.len()\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Mutable borrow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"fn append_exclamation(s: &mut String) {\r\n    s.push('!');\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Using both safely"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'fn main() {\r\n    let mut s = String::from("Rust");\r\n\r\n    let len = calculate_length(&s);\r\n    append_exclamation(&mut s);\r\n\r\n    println!("{} ({})", s, len);\r\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"borrowing-prevents-dangling-references",children:"Borrowing Prevents Dangling References"}),"\n",(0,s.jsx)(n.p,{children:"Rust will not let references outlive the data they point to."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'fn get_ref() -> &String {\r\n    let s = String::from("hello");\r\n    &s // \u274c compile-time error\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Why?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"s"})," is dropped at the end of the function"]}),"\n",(0,s.jsx)(n.li,{children:"The reference would point to freed memory"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Rust refuses to compile this."}),"\n",(0,s.jsx)(n.h2,{id:"borrowing-with-slices-very-common",children:"Borrowing with Slices (Very Common)"}),"\n",(0,s.jsx)(n.p,{children:"Slices are references too."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"fn first_word(s: &str) -> &str {\r\n    let bytes = s.as_bytes();\r\n\r\n    for (i, &b) in bytes.iter().enumerate() {\r\n        if b == b' ' {\r\n            return &s[0..i];\r\n        }\r\n    }\r\n\r\n    &s[..]\r\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"&str"})," is an immutable borrow of a string slice"]}),"\n",(0,s.jsx)(n.li,{children:"No allocation"}),"\n",(0,s.jsx)(n.li,{children:"No ownership transfer"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"mental-model-this-helps-a-lot",children:"Mental Model (This Helps a LOT)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Ownership: who frees the memory?"}),"\n",(0,s.jsxs)(n.li,{children:["Immutable borrow (",(0,s.jsx)(n.code,{children:"&"}),"): read-only, many allowed"]}),"\n",(0,s.jsxs)(n.li,{children:["Mutable borrow (",(0,s.jsx)(n.code,{children:"&mut"}),"): read-write, only one allowed"]}),"\n",(0,s.jsx)(n.li,{children:"Compiler = strict librarian"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If Rust allows it, it\u2019s safe. Period."}),"\n",(0,s.jsx)(n.h2,{id:"why-borrowing-is-a-big-deal",children:"Why Borrowing Is a Big Deal"}),"\n",(0,s.jsx)(n.p,{children:"Borrowing gives Rust:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Memory safety"}),"\n",(0,s.jsx)(n.li,{children:"Thread safety"}),"\n",(0,s.jsx)(n.li,{children:"Zero runtime overhead"}),"\n",(0,s.jsx)(n.li,{children:"No data races"}),"\n",(0,s.jsx)(n.li,{children:"No dangling pointers"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"And you get these guarantees without writing extra code."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);