"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[88589],{28453(e,t,n){n.d(t,{R:()=>i,x:()=>o});var s=n(96540);const r={},a=s.createContext(r);function i(e){const t=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:t},e.children)}},52249(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"oop/Class","title":"Class","description":"Class","source":"@site/docs/oop/6. Class.md","sourceDirName":"oop","slug":"/oop/Class","permalink":"/handbook/docs/oop/Class","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{},"sidebar":"oopSidebar","previous":{"title":"OOP with Microservices","permalink":"/handbook/docs/oop/Architecture/OOP with Microservices"},"next":{"title":"Access Modifier","permalink":"/handbook/docs/oop/Access Modifier"}}');var r=n(74848),a=n(28453);const i={},o=void 0,c={},l=[{value:"Class",id:"class",level:2},{value:"Attributes",id:"attributes",level:3},{value:"Instance Variable",id:"instance-variable",level:3},{value:"Object",id:"object",level:2},{value:"<code>new</code> Operator",id:"new-operator",level:3},{value:"Constructor",id:"constructor",level:2},{value:"Default Constructor",id:"default-constructor",level:3},{value:"Parameterized Constructor",id:"parameterized-constructor",level:3},{value:"Constructor Chaining",id:"constructor-chaining",level:3},{value:"Method",id:"method",level:2},{value:"Method Overloading",id:"method-overloading",level:3},{value:"Method Overriding",id:"method-overriding",level:3}];function d(e){const t={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"class",children:"Class"}),"\n",(0,r.jsx)(t.p,{children:"A java class is a group of values with a set of operations to manipulate this values."}),"\n",(0,r.jsx)(t.p,{children:"It is a blueprint for creating objects. A class encapsulates data for the object and methods to manipulate that data. It is use to define a new data type(primitive)."}),"\n",(0,r.jsx)(t.h3,{id:"attributes",children:"Attributes"}),"\n",(0,r.jsx)(t.p,{children:"Variables and methods used in the class are called attributes/fields. Attributes are accessed by creating an object of the class and dot notation."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"A class contains following members:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Instance Variables"}),"\n",(0,r.jsx)(t.li,{children:"Methods"}),"\n",(0,r.jsx)(t.li,{children:"Constructor"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"instance-variable",children:"Instance Variable"}),"\n",(0,r.jsx)(t.p,{children:"Variable defined within a class are called instance variables because each instance of the class(that is,each object of the class) contains its own copy of these variable."}),"\n",(0,r.jsx)(t.h2,{id:"object",children:"Object"}),"\n",(0,r.jsx)(t.p,{children:"It represent an instance of a class. It's a runtime entity that holds the state and behaviour of a class. Object is a class type variable. When you create a class, you are creating a new data type. And you can use this data type by declaring objects of this data type."}),"\n",(0,r.jsx)(t.p,{children:"Each time you create an object of a class, a copy of each instance variables is created except static varible, its create only once."}),"\n",(0,r.jsxs)(t.p,{children:["Objects are create using the ",(0,r.jsx)(t.code,{children:"new"})," keyword. Each object is stored at a unique memory location.\r\n",(0,r.jsx)(t.strong,{children:"Create Object:"})]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"Box myBox; // reference\r\nmyBox=new Box(); // allocate\n"})}),"\n",(0,r.jsxs)(t.h3,{id:"new-operator",children:[(0,r.jsx)(t.code,{children:"new"})," Operator"]}),"\n",(0,r.jsx)(t.p,{children:"It is used to create new objects"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"allocates memory for the object on the heap"}),"\n",(0,r.jsx)(t.li,{children:"initializes the object by calling its constructor"}),"\n",(0,r.jsx)(t.li,{children:"returns a reference to that memory which is used to access the object's methods and attributes."}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"constructor",children:"Constructor"}),"\n",(0,r.jsx)(t.p,{children:"A class contructor if defined is called whenever a program creates an object of that class. It is invoked directly when an object is created and before new operator execute completely."}),"\n",(0,r.jsx)(t.p,{children:"It doesn't have any return type, not even void and hence can't return any values. It is used to initialize objects. It is called when an instance of a class is created, and it usually sets initial values for the objects attributes."}),"\n",(0,r.jsxs)(t.p,{children:["It doesn't inherited as it's not part of class member.\r\n",(0,r.jsx)(t.strong,{children:"Types:"})]}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:"default constructor"}),"\n",(0,r.jsx)(t.li,{children:"parameterized constructor"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"default-constructor",children:"Default Constructor"}),"\n",(0,r.jsx)(t.p,{children:"A default constructor is automatically provided by the java compiler if no constructors are explicitly defined in a class. It initializes object fields with default value(null, 0).It has the same access modifier as the class."}),"\n",(0,r.jsx)(t.h3,{id:"parameterized-constructor",children:"Parameterized Constructor"}),"\n",(0,r.jsx)(t.p,{children:"A parameterized constructor accepts parameters, allowing you to initialize the objects fields with specific values at the time of creation."}),"\n",(0,r.jsx)(t.h3,{id:"constructor-chaining",children:"Constructor Chaining"}),"\n",(0,r.jsx)(t.p,{children:"It refers to the process of calling one constructor from another within the same/different class. It is used to reduce code duplication and ensure proper initialization."}),"\n",(0,r.jsx)(t.p,{children:"Each class calls the constructor of its parent class when it is instantiated, leading to a chain of constructor calls. Constructor doesn't inherited as it's not part of the class member. But in every inheritance constructor of parent class will be called, which result constructor chaining."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'class SuperParent{\r\n    SuperParent(){\r\n        System.out.println("I\'m Super Parent");\r\n    }\r\n    SuperParent(int x){\r\n        System.out.println("I\'m Super Parent with "+x);\r\n    }\r\n}\r\nclass Parent extends SuperParent{\r\n    Parent(){\r\n        System.out.println("I\'m Parent");\r\n    }\r\n    Parent(int x){\r\n        System.out.println("I\'m Parent with "+x);\r\n    }\r\n}\r\nclass Child extends Parent{\r\n    Child(){\r\n        System.out.println("I\'m Child");\r\n    }\r\n    Child(int x){\r\n        System.out.println("I\'m Child with "+x);\r\n    }\r\n}\r\nclass SuperChild extends Child{\r\n    SuperChild(){\r\n        super(4);\r\n        System.out.println("I\'m SuperChild");\r\n    }\r\n    SuperChild(int x){\r\n        System.out.println("I\'m SuperChild with "+x);\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"method",children:"Method"}),"\n",(0,r.jsx)(t.p,{children:"variables used in method signature are called parameter, and variables used during call are called arguments."}),"\n",(0,r.jsx)(t.p,{children:"Instance method can call an instance methods directly. There is no need to use object."}),"\n",(0,r.jsx)(t.h3,{id:"method-overloading",children:"Method Overloading"}),"\n",(0,r.jsx)(t.p,{children:"When more than one method with the same name is defined in the same class,it is known as method overloading as long as their parameter declarations are different."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsxs)(t.strong,{children:["Method overloading is a way to achieve ",(0,r.jsx)(t.code,{children:"static polymorphism"})," in java."]})}),"\n",(0,r.jsx)(t.h3,{id:"method-overriding",children:"Method Overriding"}),"\n",(0,r.jsx)(t.p,{children:"The ability of a subclass to re-implement an instance method inherited from a superclass is called method overriding."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"overriding method must have same argument list and return type."}),"\n",(0,r.jsx)(t.li,{children:"final, static, constructor method can't be overriden."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsxs)(t.strong,{children:["Method overloading is a way to achieve ",(0,r.jsx)(t.code,{children:"dynamic polymorphism"})," in java."]})}),"\n",(0,r.jsx)(t.p,{children:"If a method in a subclass has the same method signature as a method in its superclass, the subclass method overrides the inherited method. If a method in a subclass has the different method signature as a method in its superclass, the subclass method overloads the inherited method."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'class SuperParent{\r\n    static void show(double x){\r\n        System.out.println("Super Parent");\r\n    }\r\n}\r\nclass Parent extends SuperParent{\r\n    static void show(int x){\r\n        System.out.println("Parent");\r\n    }\r\n}\r\nclass Test extends Parent{\r\n    public static void main(String[] args){\r\n        show(4);\r\n        show(4.5);\r\n    }\r\n}\n'})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);