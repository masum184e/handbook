"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[88789],{2588(e,r,n){n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"rust/Macros/Custom Derive Macro","title":"Custom Derive Macro","description":"A custom derive macro is a procedural macro that runs when you write:","source":"@site/docs/rust/Macros/3. Custom Derive Macro.md","sourceDirName":"rust/Macros","slug":"/rust/Macros/Custom Derive Macro","permalink":"/handbook/docs/rust/Macros/Custom Derive Macro","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{},"sidebar":"rustApiSidebar","previous":{"title":"Procedural Macros","permalink":"/handbook/docs/rust/Macros/Procedural Macros"},"next":{"title":"Attribute Macros","permalink":"/handbook/docs/rust/Macros/Attribute Macros"}}');var i=n(74848),t=n(28453);const c={},a=void 0,l={},o=[{value:"Why Use Custom Derives?",id:"why-use-custom-derives",level:2},{value:"How Custom Derive Macros Work",id:"how-custom-derive-macros-work",level:2},{value:"Step-by-Step: Build a Custom Derive Macro",id:"step-by-step-build-a-custom-derive-macro",level:2},{value:"Step 1: Create the Proc-Macro Crate",id:"step-1-create-the-proc-macro-crate",level:3},{value:"Step 2: Define the Macro Code",id:"step-2-define-the-macro-code",level:2},{value:"Step 3: Define the Trait (in a normal crate)",id:"step-3-define-the-trait-in-a-normal-crate",level:3},{value:"Step 4: Use the Derive Macro",id:"step-4-use-the-derive-macro",level:3},{value:"What Gets Generated",id:"what-gets-generated",level:2},{value:"Example 2: Derive Macro That Reads Struct Fields",id:"example-2-derive-macro-that-reads-struct-fields",level:2},{value:"Handling Generics in Derive Macros",id:"handling-generics-in-derive-macros",level:2},{value:"Supporting Attributes in Custom Derives",id:"supporting-attributes-in-custom-derives",level:2},{value:"Error Handling in Derive Macros",id:"error-handling-in-derive-macros",level:2},{value:"When to Use Custom Derives vs Other Macros",id:"when-to-use-custom-derives-vs-other-macros",level:2}];function d(e){const r={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.p,{children:"A custom derive macro is a procedural macro that runs when you write:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"#[derive(MyTrait)]\r\nstruct MyType { ... }\n"})}),"\n",(0,i.jsx)(r.p,{children:"It:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Receives the full definition of the struct/enum."}),"\n",(0,i.jsx)(r.li,{children:"Analyzes its fields, variants, generics, attributes, etc."}),"\n",(0,i.jsx)(r.li,{children:"Generates an implementation of a trait (or other code)."}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"why-use-custom-derives",children:"Why Use Custom Derives?"}),"\n",(0,i.jsx)(r.p,{children:"They are perfect for:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Automatically implementing traits based on structure."}),"\n",(0,i.jsx)(r.li,{children:"Reducing boilerplate."}),"\n",(0,i.jsx)(r.li,{children:"Enforcing compile-time rules."}),"\n",(0,i.jsx)(r.li,{children:"Creating declarative APIs."}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"Examples from the ecosystem:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"#[derive(Serialize, Deserialize)]"})," \u2192 ",(0,i.jsx)(r.code,{children:"serde"})]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"#[derive(Parser)]"})," \u2192 ",(0,i.jsx)(r.code,{children:"clap"})]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"#[derive(Error)]"})," \u2192 ",(0,i.jsx)(r.code,{children:"thiserror"})]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"how-custom-derive-macros-work",children:"How Custom Derive Macros Work"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:["The compiler sees ",(0,i.jsx)(r.code,{children:"#[derive(MyTrait)]"}),"."]}),"\n",(0,i.jsxs)(r.li,{children:["It sends the annotated item as a ",(0,i.jsx)(r.code,{children:"TokenStream"})," to your macro."]}),"\n",(0,i.jsxs)(r.li,{children:["Your macro:","\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Parses the input into a syntax tree (AST)."}),"\n",(0,i.jsx)(r.li,{children:"Extracts information (name, fields, generics)."}),"\n",(0,i.jsx)(r.li,{children:"Generates Rust code."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.li,{children:"The generated code is compiled as if the user wrote it."}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"step-by-step-build-a-custom-derive-macro",children:"Step-by-Step: Build a Custom Derive Macro"}),"\n",(0,i.jsxs)(r.p,{children:["We\u2019ll build ",(0,i.jsx)(r.code,{children:"#[derive(HelloMacro)]"})," that adds a method to a struct or enum."]}),"\n",(0,i.jsx)(r.h3,{id:"step-1-create-the-proc-macro-crate",children:"Step 1: Create the Proc-Macro Crate"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-sh",children:"cargo new hello_macro_derive --lib\n"})}),"\n",(0,i.jsxs)(r.p,{children:["In ",(0,i.jsx)(r.code,{children:"Cargo.toml"}),":"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-toml",children:'[lib]\r\nproc-macro = true\r\n\r\n[dependencies]\r\nsyn = "2"\r\nquote = "1"\r\nproc-macro2 = "1"\n'})}),"\n",(0,i.jsx)(r.h2,{id:"step-2-define-the-macro-code",children:"Step 2: Define the Macro Code"}),"\n",(0,i.jsxs)(r.p,{children:["In ",(0,i.jsx)(r.code,{children:"lib.rs"}),":"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'use proc_macro::TokenStream;\r\nuse quote::quote;\r\nuse syn::{parse_macro_input, DeriveInput};\r\n\r\n#[proc_macro_derive(HelloMacro)]\r\npub fn hello_macro_derive(input: TokenStream) -> TokenStream {\r\n    // Parse input tokens into a syntax tree\r\n    let input = parse_macro_input!(input as DeriveInput);\r\n\r\n    let name = input.ident;\r\n\r\n    // Generate code\r\n    let expanded = quote! {\r\n        impl HelloMacro for #name {\r\n            fn hello() {\r\n                println!("Hello from {}!", stringify!(#name));\r\n            }\r\n        }\r\n    };\r\n\r\n    TokenStream::from(expanded)\r\n}\n'})}),"\n",(0,i.jsx)(r.h3,{id:"step-3-define-the-trait-in-a-normal-crate",children:"Step 3: Define the Trait (in a normal crate)"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"pub trait HelloMacro {\r\n    fn hello();\r\n}\n"})}),"\n",(0,i.jsx)(r.h3,{id:"step-4-use-the-derive-macro",children:"Step 4: Use the Derive Macro"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"use hello_macro_derive::HelloMacro;\r\n\r\n#[derive(HelloMacro)]\r\nstruct Pancakes;\r\n\r\nfn main() {\r\n    Pancakes::hello();\r\n}\n"})}),"\n",(0,i.jsx)(r.h2,{id:"what-gets-generated",children:"What Gets Generated"}),"\n",(0,i.jsx)(r.p,{children:"Conceptually, the compiler expands this into:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'impl HelloMacro for Pancakes {\r\n    fn hello() {\r\n        println!("Hello from Pancakes!");\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(r.h2,{id:"example-2-derive-macro-that-reads-struct-fields",children:"Example 2: Derive Macro That Reads Struct Fields"}),"\n",(0,i.jsxs)(r.p,{children:["Let\u2019s create a more realistic macro:\r\n",(0,i.jsx)(r.code,{children:"#[derive(Describe)]"})," that prints the field names and types."]}),"\n",(0,i.jsx)(r.p,{children:"Macro Implementation"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'use proc_macro::TokenStream;\r\nuse quote::quote;\r\nuse syn::{parse_macro_input, Data, DeriveInput, Fields};\r\n\r\n#[proc_macro_derive(Describe)]\r\npub fn describe_derive(input: TokenStream) -> TokenStream {\r\n    let input = parse_macro_input!(input as DeriveInput);\r\n    let name = input.ident;\r\n\r\n    let fields = match input.data {\r\n        Data::Struct(data) => match data.fields {\r\n            Fields::Named(fields) => fields.named,\r\n            _ => panic!("Describe only supports structs with named fields"),\r\n        },\r\n        _ => panic!("Describe only supports structs"),\r\n    };\r\n\r\n    let field_names = fields.iter().map(|f| {\r\n        let name = &f.ident;\r\n        quote! {\r\n            println!("Field: {}", stringify!(#name));\r\n        }\r\n    });\r\n\r\n    let expanded = quote! {\r\n        impl Describe for #name {\r\n            fn describe() {\r\n                println!("Struct {}", stringify!(#name));\r\n                #(#field_names)*\r\n            }\r\n        }\r\n    };\r\n\r\n    TokenStream::from(expanded)\r\n}\n'})}),"\n",(0,i.jsx)(r.p,{children:"Trait Definition"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"pub trait Describe {\r\n    fn describe();\r\n}\n"})}),"\n",(0,i.jsx)(r.p,{children:"Usage"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"#[derive(Describe)]\r\nstruct User {\r\n    id: u32,\r\n    name: String,\r\n    active: bool,\r\n}\r\n\r\nfn main() {\r\n    User::describe();\r\n}\n"})}),"\n",(0,i.jsx)(r.p,{children:"Expansion (Conceptual)"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'impl Describe for User {\r\n    fn describe() {\r\n        println!("Struct User");\r\n        println!("Field: id");\r\n        println!("Field: name");\r\n        println!("Field: active");\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(r.h2,{id:"handling-generics-in-derive-macros",children:"Handling Generics in Derive Macros"}),"\n",(0,i.jsx)(r.p,{children:"If your struct has generics:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"#[derive(HelloMacro)]\r\nstruct Wrapper<T> {\r\n    value: T,\r\n}\n"})}),"\n",(0,i.jsxs)(r.p,{children:["You must carry generics into the ",(0,i.jsx)(r.code,{children:"impl"}),":"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'let generics = input.generics;\r\nlet (impl_generics, ty_generics, where_clause) = generics.split_for_impl();\r\n\r\nquote! {\r\n    impl #impl_generics HelloMacro for #name #ty_generics #where_clause {\r\n        fn hello() {\r\n            println!("Hello from {}!", stringify!(#name));\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(r.h2,{id:"supporting-attributes-in-custom-derives",children:"Supporting Attributes in Custom Derives"}),"\n",(0,i.jsx)(r.p,{children:"You can let users customize behavior:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"#[derive(Describe)]\r\n#[describe(skip)]\r\nstruct User {\r\n    id: u32,\r\n    password: String,\r\n}\n"})}),"\n",(0,i.jsxs)(r.p,{children:["Then parse attributes with ",(0,i.jsx)(r.code,{children:"syn"})," to change code generation (e.g., skip fields)."]}),"\n",(0,i.jsx)(r.h2,{id:"error-handling-in-derive-macros",children:"Error Handling in Derive Macros"}),"\n",(0,i.jsxs)(r.p,{children:["Instead of ",(0,i.jsx)(r.code,{children:"panic!"}),", use compile errors:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'return syn::Error::new_spanned(\r\n    input,\r\n    "Describe only supports structs with named fields",\r\n)\r\n.to_compile_error()\r\n.into();\n'})}),"\n",(0,i.jsx)(r.p,{children:"This gives users friendly compiler messages."}),"\n",(0,i.jsx)(r.h2,{id:"when-to-use-custom-derives-vs-other-macros",children:"When to Use Custom Derives vs Other Macros"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Use Case"}),(0,i.jsx)(r.th,{children:"Best Tool"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Implement trait based on struct shape"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Custom derive"})})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Wrap or modify functions"}),(0,i.jsx)(r.td,{children:"Attribute macro"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Custom DSL or syntax"}),(0,i.jsx)(r.td,{children:"Function-like macro"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Simple repetition"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"macro_rules!"})})]})]})]})]})}function h(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453(e,r,n){n.d(r,{R:()=>c,x:()=>a});var s=n(96540);const i={},t=s.createContext(i);function c(e){const r=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(t.Provider,{value:r},e.children)}}}]);