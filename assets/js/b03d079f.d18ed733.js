"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[37314],{28453(n,e,t){t.d(e,{R:()=>i,x:()=>l});var r=t(96540);const s={},a=r.createContext(s);function i(n){const e=r.useContext(a);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:i(n.components),r.createElement(a.Provider,{value:e},n.children)}},73467(n,e,t){t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>l,default:()=>o,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"rust/Data Structure/Pattern Matching","title":"Pattern Matching","description":"Pattern matching lets Rust compare a value against a pattern, extract data from it, and decide what to do safely and exhaustively.","source":"@site/docs/rust/11. Data Structure/8. Pattern Matching.md","sourceDirName":"rust/11. Data Structure","slug":"/rust/Data Structure/Pattern Matching","permalink":"/handbook/docs/rust/Data Structure/Pattern Matching","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{}}');var s=t(74848),a=t(28453);const i={},l=void 0,c={},d=[{value:"Matching Enums (Most Important Use Case)",id:"matching-enums-most-important-use-case",level:2},{value:"Pattern Matching with <code>Option&lt;T&gt;</code>",id:"pattern-matching-with-optiont",level:2},{value:"Pattern Matching with <code>Result&lt;T, E&gt;</code>",id:"pattern-matching-with-resultt-e",level:2},{value:"Matching Tuples",id:"matching-tuples",level:2},{value:"Matching Structs",id:"matching-structs",level:2},{value:"Ignoring Values with <code>_</code> and <code>..</code>",id:"ignoring-values-with-_-and-",level:2},{value:"Match Guards (if Conditions)",id:"match-guards-if-conditions",level:2},{value:"<code>if let</code> \u2013 Pattern Matching Lite",id:"if-let--pattern-matching-lite",level:2},{value:"<code>while let</code> \u2013 Pattern Matching in Loops",id:"while-let--pattern-matching-in-loops",level:2},{value:"Matching Slices and Arrays",id:"matching-slices-and-arrays",level:2},{value:"Ownership and Pattern Matching",id:"ownership-and-pattern-matching",level:2},{value:"Summary",id:"summary",level:2}];function h(n){const e={blockquote:"blockquote",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.p,{children:"Pattern matching lets Rust compare a value against a pattern, extract data from it, and decide what to do safely and exhaustively."}),"\n",(0,s.jsx)(e.p,{children:"Think of it as:"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["A supercharged ",(0,s.jsx)(e.code,{children:"switch"})," statement that understands structure, ownership, and types."]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'let number = 3;\r\n\r\nmatch number {\r\n    1 => println!("One"),\r\n    2 => println!("Two"),\r\n    3 => println!("Three"),\r\n    _ => println!("Something else"),\r\n}\n'})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Rust checks each arm top to bottom"}),"\n",(0,s.jsx)(e.li,{children:"The first matching pattern runs"}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"_"})," is a catch-all"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"match"})," must be exhaustive"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Why Pattern Matching Matters"})}),"\n",(0,s.jsx)(e.p,{children:"Rust data structures are often shaped, not flat: Tuples, Structs, Enums (Option, Result), Slices"}),"\n",(0,s.jsx)(e.p,{children:"Pattern matching lets you look inside these shapes safely."}),"\n",(0,s.jsx)(e.h2,{id:"matching-enums-most-important-use-case",children:"Matching Enums (Most Important Use Case)"}),"\n",(0,s.jsx)(e.p,{children:"Example: Enum with Data"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:"enum Message {\r\n    Quit,\r\n    Write(String),\r\n    Move { x: i32, y: i32 },\r\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"Matching Variants"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'fn handle_message(msg: Message) {\r\n    match msg {\r\n        Message::Quit => println!("Quit"),\r\n        Message::Write(text) => println!("Text: {}", text),\r\n        Message::Move { x, y } => println!("Move to ({}, {})", x, y),\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"Why this is powerful:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Rust forces you to handle every variant"}),"\n",(0,s.jsx)(e.li,{children:"Data is safely extracted"}),"\n",(0,s.jsx)(e.li,{children:"No null checks, no invalid states"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"pattern-matching-with-optiont",children:["Pattern Matching with ",(0,s.jsx)(e.code,{children:"Option<T>"})]}),"\n",(0,s.jsx)(e.p,{children:"Definition Reminder"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:"enum Option<T> {\r\n    Some(T),\r\n    None,\r\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"Example"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'let name = Some("Rust");\r\n\r\nmatch name {\r\n    Some(value) => println!("Name: {}", value),\r\n    None => println!("No name provided"),\r\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["Rust won\u2019t let you \u201cforget\u201d the ",(0,s.jsx)(e.code,{children:"None"})," case. That\u2019s deliberate."]}),"\n",(0,s.jsxs)(e.h2,{id:"pattern-matching-with-resultt-e",children:["Pattern Matching with ",(0,s.jsx)(e.code,{children:"Result<T, E>"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'fn divide(a: i32, b: i32) -> Result<i32, String> {\r\n    if b == 0 {\r\n        Err(String::from("Division by zero"))\r\n    } else {\r\n        Ok(a / b)\r\n    }\r\n}\r\n\r\nmatch divide(10, 2) {\r\n    Ok(value) => println!("Result: {}", value),\r\n    Err(err) => println!("Error: {}", err),\r\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"Pattern matching turns error handling into explicit logic, not hope."}),"\n",(0,s.jsx)(e.h2,{id:"matching-tuples",children:"Matching Tuples"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'let point = (0, 5);\r\n\r\nmatch point {\r\n    (0, y) => println!("On Y axis at {}", y),\r\n    (x, 0) => println!("On X axis at {}", x),\r\n    (x, y) => println!("Point at ({}, {})", x, y),\r\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"Patterns describe structure, not just values."}),"\n",(0,s.jsx)(e.h2,{id:"matching-structs",children:"Matching Structs"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'struct User {\r\n    name: String,\r\n    age: u32,\r\n}\r\n\r\nlet user = User {\r\n    name: String::from("Alice"),\r\n    age: 20,\r\n};\n'})}),"\n",(0,s.jsx)(e.p,{children:"Destructuring in match"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'match user {\r\n    User { name, age: 18 } => println!("Just became an adult: {}", name),\r\n    User { name, age } => println!("{} is {} years old", name, age),\r\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"Field names become variables automatically."}),"\n",(0,s.jsxs)(e.h2,{id:"ignoring-values-with-_-and-",children:["Ignoring Values with ",(0,s.jsx)(e.code,{children:"_"})," and ",(0,s.jsx)(e.code,{children:".."})]}),"\n",(0,s.jsx)(e.p,{children:"Ignore Single Values"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:"let (_, y) = (10, 20);\n"})}),"\n",(0,s.jsx)(e.p,{children:"Ignore Remaining Fields"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'match user {\r\n    User { name, .. } => println!("User: {}", name),\r\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"This keeps patterns readable and future-proof."}),"\n",(0,s.jsx)(e.h2,{id:"match-guards-if-conditions",children:"Match Guards (if Conditions)"}),"\n",(0,s.jsx)(e.p,{children:"Patterns can have extra conditions."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'let num = Some(4);\r\n\r\nmatch num {\r\n    Some(x) if x % 2 == 0 => println!("Even number"),\r\n    Some(_) => println!("Odd number"),\r\n    None => println!("No number"),\r\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"Guards refine patterns without nesting logic."}),"\n",(0,s.jsxs)(e.h2,{id:"if-let--pattern-matching-lite",children:[(0,s.jsx)(e.code,{children:"if let"})," \u2013 Pattern Matching Lite"]}),"\n",(0,s.jsxs)(e.p,{children:["Use ",(0,s.jsx)(e.code,{children:"if let"})," when you care about one pattern only."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'let msg = Message::Write(String::from("Hello"));\r\n\r\nif let Message::Write(text) = msg {\r\n    println!("Message: {}", text);\r\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"Less verbose, less exhaustive\u2014use wisely."}),"\n",(0,s.jsxs)(e.h2,{id:"while-let--pattern-matching-in-loops",children:[(0,s.jsx)(e.code,{children:"while let"})," \u2013 Pattern Matching in Loops"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'let mut stack = vec![1, 2, 3];\r\n\r\nwhile let Some(value) = stack.pop() {\r\n    println!("{}", value);\r\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"The loop ends naturally when the pattern no longer matches."}),"\n",(0,s.jsx)(e.h2,{id:"matching-slices-and-arrays",children:"Matching Slices and Arrays"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'let numbers = [1, 2, 3];\r\n\r\nmatch numbers {\r\n    [1, _, 3] => println!("Matched pattern"),\r\n    _ => println!("No match"),\r\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"Variable-Length Slice Pattern"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'match &numbers[..] {\r\n    [first, middle @ .., last] =>\r\n        println!("First: {}, Last: {}", first, last),\r\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"This is structural reasoning, not indexing."}),"\n",(0,s.jsx)(e.h2,{id:"ownership-and-pattern-matching",children:"Ownership and Pattern Matching"}),"\n",(0,s.jsx)(e.p,{children:"Patterns can move, borrow, or copy values."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'let msg = Message::Write(String::from("Hello"));\r\n\r\nmatch msg {\r\n    Message::Write(text) => println!("{}", text), // moved\r\n    _ => (),\r\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"To avoid moving:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'match &msg {\r\n    Message::Write(text) => println!("{}", text),\r\n    _ => (),\r\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Pattern matching inspects structure, not just values"}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"match"})," must be exhaustive"]}),"\n",(0,s.jsx)(e.li,{children:"Works deeply with enums, structs, tuples, slices"}),"\n",(0,s.jsx)(e.li,{children:"Enforces correctness at compile time"}),"\n",(0,s.jsx)(e.li,{children:"Replaces null checks and fragile branching"}),"\n"]})]})}function o(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(h,{...n})}):h(n)}}}]);