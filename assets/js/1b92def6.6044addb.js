"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[86910],{28453(e,n,i){i.d(n,{R:()=>a,x:()=>t});var r=i(96540);const l={},s=r.createContext(l);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),r.createElement(s.Provider,{value:n},e.children)}},56314(e,n,i){i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"design-patterns/SOLID Principles/DIP","title":"DIP","description":"Perfect \u2014 now we\u2019ll connect two principles that often work together in real architectures:","source":"@site/docs/design-patterns/2. SOLID Principles/5. DIP.md","sourceDirName":"design-patterns/2. SOLID Principles","slug":"/design-patterns/SOLID Principles/DIP","permalink":"/handbook/docs/design-patterns/SOLID Principles/DIP","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{},"sidebar":"designPatternsSidebar","previous":{"title":"ISP","permalink":"/handbook/docs/design-patterns/SOLID Principles/ISP"},"next":{"title":"Solid Principles","permalink":"/handbook/docs/design-patterns/Solid Principles"}}');var l=i(74848),s=i(28453);const a={},t=void 0,d={},c=[{value:"What Are High-Level and Low-Level Modules?",id:"what-are-high-level-and-low-level-modules",level:2},{value:"DIP Violation Example",id:"dip-violation-example",level:3},{value:"Applying DIP",id:"applying-dip",level:2},{value:"What Actually Inverted?",id:"what-actually-inverted",level:2},{value:"Real-World Example: Payment Gateway",id:"real-world-example-payment-gateway",level:2},{value:"Real-World Tradeoffs of DIP",id:"real-world-tradeoffs-of-dip",level:2},{value:"More Abstractions",id:"more-abstractions",level:3},{value:"Harder Navigation",id:"harder-navigation",level:3},{value:"Overengineering Risk",id:"overengineering-risk",level:3},{value:"Interface Segregation Principle (ISP)",id:"interface-segregation-principle-isp",level:3},{value:"DIP + ISP Together",id:"dip--isp-together",level:2},{value:"Real-World Combined Example",id:"real-world-combined-example",level:2},{value:"Deep Insight",id:"deep-insight",level:2},{value:"When Not to Overapply",id:"when-not-to-overapply",level:2},{value:"Practical Heuristics",id:"practical-heuristics",level:2},{value:"Final Summary",id:"final-summary",level:2}];function o(e){const n={blockquote:"blockquote",br:"br",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.p,{children:"Perfect \u2014 now we\u2019ll connect two principles that often work together in real architectures:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Dependency Inversion Principle (DIP)"}),"\n",(0,l.jsx)(n.li,{children:"Interface Segregation Principle (ISP)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"These two are deeply related. DIP tells you how modules should depend on each other. ISP tells you what those dependencies should look like."}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"High-level modules should not depend on low-level modules.\r\nBoth should depend on abstractions.\r\nAbstractions should not depend on details.\r\nDetails should depend on abstractions."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"That sounds abstract. Let\u2019s simplify:"}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Business logic should not depend directly on implementation details."}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"what-are-high-level-and-low-level-modules",children:"What Are High-Level and Low-Level Modules?"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"High-level module \u2192 core business rules (what the system does)"}),"\n",(0,l.jsx)(n.li,{children:"Low-level module \u2192 implementation details (database, API, email, file system)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Bad design couples them directly."}),"\n",(0,l.jsx)(n.h3,{id:"dip-violation-example",children:"DIP Violation Example"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:'class MySQLDatabase {\r\n    public void save(String data) {\r\n        System.out.println("Saving to MySQL");\r\n    }\r\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"High-level module:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:"class UserService {\r\n    private MySQLDatabase database = new MySQLDatabase();\r\n\r\n    public void registerUser(String name) {\r\n        database.save(name);\r\n    }\r\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"Problems:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Business logic tightly coupled to MySQL."}),"\n",(0,l.jsx)(n.li,{children:"If we switch to PostgreSQL \u2192 modify UserService."}),"\n",(0,l.jsx)(n.li,{children:"Hard to test (real database needed)."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"High-level depends on low-level."}),"\n",(0,l.jsx)(n.h2,{id:"applying-dip",children:"Applying DIP"}),"\n",(0,l.jsx)(n.p,{children:"Step 1: Introduce abstraction."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:"interface Database {\r\n    void save(String data);\r\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"Step 2: Implement it."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:'class MySQLDatabase implements Database {\r\n    public void save(String data) {\r\n        System.out.println("Saving to MySQL");\r\n    }\r\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"Step 3: Inject dependency."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:"class UserService {\r\n    private Database database;\r\n\r\n    public UserService(Database database) {\r\n        this.database = database;\r\n    }\r\n\r\n    public void registerUser(String name) {\r\n        database.save(name);\r\n    }\r\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"Now:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["UserService depends on ",(0,l.jsx)(n.code,{children:"Database"})," abstraction."]}),"\n",(0,l.jsx)(n.li,{children:"MySQL depends on the abstraction."}),"\n",(0,l.jsx)(n.li,{children:"You can swap implementations easily."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"That\u2019s dependency inversion."}),"\n",(0,l.jsx)(n.h2,{id:"what-actually-inverted",children:"What Actually Inverted?"}),"\n",(0,l.jsx)(n.p,{children:"Originally:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"UserService \u2192 MySQLDatabase\n"})}),"\n",(0,l.jsx)(n.p,{children:"Now:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"UserService \u2192 Database (interface)\r\nMySQLDatabase \u2192 Database (interface)\n"})}),"\n",(0,l.jsx)(n.p,{children:"Concrete class now depends on abstraction."}),"\n",(0,l.jsx)(n.p,{children:"The direction of dependency changed."}),"\n",(0,l.jsx)(n.h2,{id:"real-world-example-payment-gateway",children:"Real-World Example: Payment Gateway"}),"\n",(0,l.jsx)(n.p,{children:"High-level module:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:"class OrderService {\r\n    private PaymentGateway gateway;\r\n\r\n    public OrderService(PaymentGateway gateway) {\r\n        this.gateway = gateway;\r\n    }\r\n\r\n    public void placeOrder() {\r\n        gateway.processPayment();\r\n    }\r\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"Low-level implementations:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:"class StripeGateway implements PaymentGateway { ... }\r\nclass PayPalGateway implements PaymentGateway { ... }\n"})}),"\n",(0,l.jsx)(n.p,{children:"You can now:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Add new providers without touching OrderService."}),"\n",(0,l.jsx)(n.li,{children:"Mock PaymentGateway in tests."}),"\n",(0,l.jsx)(n.li,{children:"Deploy region-specific gateways."}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"real-world-tradeoffs-of-dip",children:"Real-World Tradeoffs of DIP"}),"\n",(0,l.jsx)(n.h3,{id:"more-abstractions",children:"More Abstractions"}),"\n",(0,l.jsx)(n.p,{children:"DIP introduces:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Interfaces"}),"\n",(0,l.jsx)(n.li,{children:"Constructor injection"}),"\n",(0,l.jsx)(n.li,{children:"Possibly dependency injection frameworks"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Small systems:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Feels heavy."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Large systems:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Essential for flexibility."}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"harder-navigation",children:"Harder Navigation"}),"\n",(0,l.jsx)(n.p,{children:"More indirection:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Harder to trace actual runtime behavior."}),"\n",(0,l.jsx)(n.li,{children:"Debugging requires understanding injection flow."}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"overengineering-risk",children:"Overengineering Risk"}),"\n",(0,l.jsx)(n.p,{children:"If you create interfaces for everything:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"IUserService\r\nIUserRepository\r\nILogger\r\nIClock\r\nIFormatter\r\n...\n"})}),"\n",(0,l.jsx)(n.p,{children:"You may over-abstract prematurely."}),"\n",(0,l.jsx)(n.p,{children:"Use DIP where variation is likely."}),"\n",(0,l.jsx)(n.h3,{id:"interface-segregation-principle-isp",children:"Interface Segregation Principle (ISP)"}),"\n",(0,l.jsx)(n.p,{children:"Now let\u2019s connect ISP."}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Clients should not be forced to depend on methods they do not use."}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["DIP tells you to depend on abstractions.",(0,l.jsx)(n.br,{}),"\n","ISP tells you to keep those abstractions small and focused."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"ISP Violation"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:"interface Worker {\r\n    void work();\r\n    void eat();\r\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"Now:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:"class Robot implements Worker {\r\n    public void work() { ... }\r\n    public void eat() { throw new UnsupportedOperationException(); }\r\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"Robot doesn\u2019t eat."}),"\n",(0,l.jsx)(n.p,{children:"Interface is too broad."}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Applying ISP"})}),"\n",(0,l.jsx)(n.p,{children:"Split interface:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:"interface Workable {\r\n    void work();\r\n}\r\n\r\ninterface Eatable {\r\n    void eat();\r\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"Now:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:"class Human implements Workable, Eatable { ... }\r\nclass Robot implements Workable { ... }\n"})}),"\n",(0,l.jsx)(n.p,{children:"Clean and honest."}),"\n",(0,l.jsx)(n.h2,{id:"dip--isp-together",children:"DIP + ISP Together"}),"\n",(0,l.jsx)(n.p,{children:"They complement each other:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"DIP: Depend on abstractions."}),"\n",(0,l.jsx)(n.li,{children:"ISP: Make abstractions minimal and client-specific."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Without ISP: You create huge \u201cgod interfaces.\u201d"}),"\n",(0,l.jsx)(n.p,{children:"Without DIP: You couple high-level modules to details."}),"\n",(0,l.jsx)(n.p,{children:"Together: You get flexible, maintainable architecture."}),"\n",(0,l.jsx)(n.h2,{id:"real-world-combined-example",children:"Real-World Combined Example"}),"\n",(0,l.jsx)(n.p,{children:"Imagine a reporting system."}),"\n",(0,l.jsx)(n.p,{children:"Bad abstraction:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:"interface DataService {\r\n    void save();\r\n    void delete();\r\n    void generateReport();\r\n    void sendEmail();\r\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"Now high-level module depends on all of it."}),"\n",(0,l.jsx)(n.p,{children:"Better:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:"interface ReportGenerator {\r\n    void generateReport();\r\n}\r\n\r\ninterface EmailSender {\r\n    void sendEmail();\r\n}\r\n\r\ninterface Repository {\r\n    void save();\r\n    void delete();\r\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["High-level reporting service depends only on ",(0,l.jsx)(n.code,{children:"ReportGenerator"}),"."]}),"\n",(0,l.jsx)(n.p,{children:"That\u2019s ISP helping DIP."}),"\n",(0,l.jsx)(n.h2,{id:"deep-insight",children:"Deep Insight"}),"\n",(0,l.jsxs)(n.p,{children:["DIP reduces coupling vertically (between layers).",(0,l.jsx)(n.br,{}),"\n","ISP reduces coupling horizontally (between features)."]}),"\n",(0,l.jsxs)(n.p,{children:["DIP controls dependency direction.",(0,l.jsx)(n.br,{}),"\n","ISP controls dependency size."]}),"\n",(0,l.jsx)(n.h2,{id:"when-not-to-overapply",children:"When Not to Overapply"}),"\n",(0,l.jsx)(n.p,{children:"Avoid heavy DIP + ISP in:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Small scripts"}),"\n",(0,l.jsx)(n.li,{children:"Internal tooling"}),"\n",(0,l.jsx)(n.li,{children:"Short-lived experiments"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Architecture should match system lifespan."}),"\n",(0,l.jsx)(n.p,{children:"Overusing them:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Adds ceremony"}),"\n",(0,l.jsx)(n.li,{children:"Slows development"}),"\n",(0,l.jsx)(n.li,{children:"Confuses juniors"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Underusing them in large systems:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Leads to rigid, fragile architecture"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"practical-heuristics",children:"Practical Heuristics"}),"\n",(0,l.jsx)(n.p,{children:"Use DIP when:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"You expect multiple implementations."}),"\n",(0,l.jsx)(n.li,{children:"You need unit testing."}),"\n",(0,l.jsx)(n.li,{children:"The module is central and stable."}),"\n",(0,l.jsx)(n.li,{children:"You integrate external systems."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Use ISP when:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Classes implement unused methods."}),"\n",(0,l.jsx)(n.li,{children:"You see UnsupportedOperationException."}),"\n",(0,l.jsx)(n.li,{children:"Interfaces grow beyond ~7\u201310 methods."}),"\n",(0,l.jsx)(n.li,{children:"Different clients use different subsets."}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"final-summary",children:"Final Summary"}),"\n",(0,l.jsx)(n.p,{children:"Dependency Inversion Principle:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"High-level modules depend on abstractions."}),"\n",(0,l.jsx)(n.li,{children:"Implementation details plug in."}),"\n",(0,l.jsx)(n.li,{children:"Enables flexibility and testability."}),"\n",(0,l.jsx)(n.li,{children:"Costs: indirection, complexity."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Interface Segregation Principle:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Keep interfaces focused."}),"\n",(0,l.jsx)(n.li,{children:"Avoid forcing unused dependencies."}),"\n",(0,l.jsx)(n.li,{children:"Enables cleaner substitution."}),"\n",(0,l.jsx)(n.li,{children:"Costs: more types and abstractions."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Together: They are the backbone of modern layered architecture."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(o,{...e})}):o(e)}}}]);