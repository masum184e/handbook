"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[5704],{8453(e,n,t){t.d(n,{R:()=>s,x:()=>a});var o=t(6540);const r={},i=o.createContext(r);function s(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(i.Provider,{value:n},e.children)}},9675(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"design-patterns/Design Patterns/Structural/Composite","title":"Composite","description":"It allow you to treat individual objects and compositions of objects uniformly. It is useful when you have to work with tree-like hierarchical structures, where individual objects (leaf nodes) and compositions of objects (composite nodes) are part of the same hierarchy.","source":"@site/docs/design-patterns/3. Design Patterns/2. Structural/3. Composite.md","sourceDirName":"design-patterns/3. Design Patterns/2. Structural","slug":"/design-patterns/Design Patterns/Structural/Composite","permalink":"/handbook/docs/design-patterns/Design Patterns/Structural/Composite","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{},"sidebar":"designPatternsSidebar","previous":{"title":"Decorator","permalink":"/handbook/docs/design-patterns/Design Patterns/Structural/Decorator"},"next":{"title":"Behavioral Design Pattern","permalink":"/handbook/docs/design-patterns/Design Patterns/Behavioral/"}}');var r=t(4848),i=t(8453);const s={},a=void 0,l={},d=[{value:"Structure",id:"structure",level:4},{value:"Example",id:"example",level:4}];function c(e){const n={code:"code",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"It allow you to treat individual objects and compositions of objects uniformly. It is useful when you have to work with tree-like hierarchical structures, where individual objects (leaf nodes) and compositions of objects (composite nodes) are part of the same hierarchy."}),"\n",(0,r.jsx)(n.h4,{id:"structure",children:"Structure"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Component"}),": This is the interface or abstract class that declares the operations common to both leaf and composite nodes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Leaf"}),": Represents individual objects that cannot have children. It implements the Component interface."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Composite"}),": Represents objects that can contain other Component objects (both leaf and composite). It implements the Component interface and contains methods for adding, removing, and managing child components"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'import java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n// Component interface\r\ninterface FileSystemComponent {\r\n    void showDetails();\r\n}\r\n\r\n// Leaf class: File\r\nclass File implements FileSystemComponent {\r\n    private String name;\r\n\r\n    public File(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    @Override\r\n    public void showDetails() {\r\n        System.out.println("File: " + name);\r\n    }\r\n}\r\n\r\nclass Folder implements FileSystemComponent {\r\n    private String name;\r\n    private List<FileSystemComponent> components = new ArrayList<>();\r\n\r\n    public Folder(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    // Adding a new component (File or Folder)\r\n    public void addComponent(FileSystemComponent component) {\r\n        components.add(component);\r\n    }\r\n\r\n    // Removing a component\r\n    public void removeComponent(FileSystemComponent component) {\r\n        components.remove(component);\r\n    }\r\n\r\n    // Show details of the folder and its contents\r\n    @Override\r\n    public void showDetails() {\r\n        System.out.println("Folder: " + name);\r\n        for (FileSystemComponent component : components) {\r\n            component.showDetails();\r\n        }\r\n    }\r\n}\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        // Creating individual files (leaf nodes)\r\n        FileSystemComponent file1 = new File("File1.txt");\r\n        FileSystemComponent file2 = new File("File2.txt");\r\n        FileSystemComponent file3 = new File("File3.jpg");\r\n\r\n        // Creating folders (composite nodes)\r\n        Folder folder1 = new Folder("Documents");\r\n        Folder folder2 = new Folder("Images");\r\n\r\n        // Adding files to folders\r\n        folder1.addComponent(file1);  // Adding file1 to Documents\r\n        folder1.addComponent(file2);  // Adding file2 to Documents\r\n        folder2.addComponent(file3);  // Adding file3 to Images\r\n\r\n        // Creating the root folder and adding sub-folders\r\n        Folder rootFolder = new Folder("Root");\r\n        rootFolder.addComponent(folder1);  // Adding Documents folder to Root\r\n        rootFolder.addComponent(folder2);  // Adding Images folder to Root\r\n\r\n        // Displaying the file system structure\r\n        rootFolder.showDetails();\r\n    }\r\n}\n'})})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);