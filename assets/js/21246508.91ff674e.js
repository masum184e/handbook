"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[34553],{28453(e,n,r){r.d(n,{R:()=>a,x:()=>c});var s=r(96540);const l={},i=s.createContext(l);function a(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),s.createElement(i.Provider,{value:n},e.children)}},44422(e,n,r){r.r(n),r.d(n,{assets:()=>t,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"rust/Macros/Declarative Macros","title":"Declarative Macros","description":"Declarative macros (also called macro_rules macros) let you define pattern-based code generation. You describe what input patterns look like and what code they expand into.","source":"@site/docs/rust/Macros/1. Declarative Macros.md","sourceDirName":"rust/Macros","slug":"/rust/Macros/Declarative Macros","permalink":"/handbook/docs/rust/Macros/Declarative Macros","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{}}');var l=r(74848),i=r(28453);const a={},c=void 0,t={},d=[{value:"Example 1: A Simple Macro",id:"example-1-a-simple-macro",level:3},{value:"Macro Variables and Fragment Specifiers",id:"macro-variables-and-fragment-specifiers",level:2},{value:"Example 2: Macro with One Argument",id:"example-2-macro-with-one-argument",level:3},{value:"Example 3: Multiple Patterns (Overloading)",id:"example-3-multiple-patterns-overloading",level:3},{value:"Repetition Syntax",id:"repetition-syntax",level:2},{value:"Example 4: Variadic Macro (Like <code>vec!</code>)",id:"example-4-variadic-macro-like-vec",level:2},{value:"Example 5: Generating Code (Struct + Impl)",id:"example-5-generating-code-struct--impl",level:3},{value:"Hygiene (Why Macros Are Safe)",id:"hygiene-why-macros-are-safe",level:2},{value:"When to Use <code>macro_rules!</code>",id:"when-to-use-macro_rules",level:2}];function o(e){const n={annotation:"annotation",code:"code",h2:"h2",h3:"h3",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.p,{children:"Declarative macros (also called macro_rules macros) let you define pattern-based code generation. You describe what input patterns look like and what code they expand into."}),"\n",(0,l.jsx)(n.p,{children:"They are:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Matched at compile time"}),"\n",(0,l.jsx)(n.li,{children:"Purely syntactic (no runtime cost)"}),"\n",(0,l.jsx)(n.li,{children:"Great for eliminating repetitive code"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Think of them as smart search-and-replace rules, but with structure and safety."}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Basic Structure"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"macro_rules! macro_name {\r\n    (pattern) => {\r\n        expansion\r\n    };\r\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"You can define multiple rules inside one macro."}),"\n",(0,l.jsx)(n.h3,{id:"example-1-a-simple-macro",children:"Example 1: A Simple Macro"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'macro_rules! say_hello {\r\n    () => {\r\n        println!("Hello, world!");\r\n    };\r\n}\r\n\r\nfn main() {\r\n    say_hello!();\r\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"How it works:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"()"})," matches no arguments."]}),"\n",(0,l.jsxs)(n.li,{children:["When the compiler sees ",(0,l.jsx)(n.code,{children:"say_hello!()"}),", it replaces it with:"]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'println!("Hello, world!");\n'})}),"\n",(0,l.jsx)(n.h2,{id:"macro-variables-and-fragment-specifiers",children:"Macro Variables and Fragment Specifiers"}),"\n",(0,l.jsx)(n.p,{children:"You can capture parts of the input using macro variables:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'macro_rules! print_value {\r\n    ($x:expr) => {\r\n        println!("The value is: {}", $x);\r\n    };\r\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"Here:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"$x"})," is a variable."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"expr"})," is a fragment specifier (tells Rust what kind of syntax to match)."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Common fragment specifiers:"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Specifier"}),(0,l.jsx)(n.th,{children:"Matches"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"expr"})}),(0,l.jsx)(n.td,{children:"Expression"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"ident"})}),(0,l.jsx)(n.td,{children:"Identifier"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"ty"})}),(0,l.jsx)(n.td,{children:"Type"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"pat"})}),(0,l.jsx)(n.td,{children:"Pattern"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"stmt"})}),(0,l.jsx)(n.td,{children:"Statement"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"block"})}),(0,l.jsxs)(n.td,{children:["Block ",(0,l.jsx)(n.code,{children:"{ ... }"})]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"item"})}),(0,l.jsx)(n.td,{children:"Item (fn, struct, etc.)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"literal"})}),(0,l.jsx)(n.td,{children:"Literal value"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"path"})}),(0,l.jsxs)(n.td,{children:["Path like ",(0,l.jsx)(n.code,{children:"std::fmt::Debug"})]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"tt"})}),(0,l.jsx)(n.td,{children:"Token tree (most flexible)"})]})]})]}),"\n",(0,l.jsx)(n.h3,{id:"example-2-macro-with-one-argument",children:"Example 2: Macro with One Argument"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'macro_rules! square {\r\n    ($x:expr) => {\r\n        $x * $x\r\n    };\r\n}\r\n\r\nfn main() {\r\n    let a = square!(4);\r\n    let b = square!(3 + 2);\r\n    println!("{}, {}", a, b);\r\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"Expansion:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"square!(4)"})," \u2192 ",(0,l.jsx)(n.code,{children:"4 * 4"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"square!(3 + 2)"})," \u2192 ",(0,l.jsx)(n.code,{children:"(3 + 2) * (3 + 2)"})," (conceptually)"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"example-3-multiple-patterns-overloading",children:"Example 3: Multiple Patterns (Overloading)"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'macro_rules! log {\r\n    ($msg:expr) => {\r\n        println!("LOG: {}", $msg);\r\n    };\r\n    ($fmt:expr, $($arg:tt)*) => {\r\n        println!(concat!("LOG: ", $fmt), $($arg)*);\r\n    };\r\n}\r\n\r\nfn main() {\r\n    log!("Hello");\r\n    log!("x = {}, y = {}", 10, 20);\r\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"How it works:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"First rule matches one expression."}),"\n",(0,l.jsxs)(n.li,{children:["Second rule matches a format string plus any number of extra tokens (",(0,l.jsxs)(n.span,{className:"katex",children:[(0,l.jsx)(n.span,{className:"katex-mathml",children:(0,l.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,l.jsxs)(n.semantics,{children:[(0,l.jsxs)(n.mrow,{children:[(0,l.jsx)(n.mo,{stretchy:"false",children:"("}),(0,l.jsx)(n.mi,{mathvariant:"normal",children:"\u2018"})]}),(0,l.jsx)(n.annotation,{encoding:"application/x-tex",children:"(`"})]})})}),(0,l.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,l.jsxs)(n.span,{className:"base",children:[(0,l.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,l.jsx)(n.span,{className:"mopen",children:"("}),(0,l.jsx)(n.span,{className:"mord",children:"\u2018"})]})})]}),"arg",":tt",")*`)."]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"repetition-syntax",children:"Repetition Syntax"}),"\n",(0,l.jsx)(n.p,{children:"Repetition lets you match multiple inputs."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"$(pattern),*   // zero or more, separated by commas\r\n$(pattern),+   // one or more\r\n$(pattern)?    // zero or one\n"})}),"\n",(0,l.jsxs)(n.h2,{id:"example-4-variadic-macro-like-vec",children:["Example 4: Variadic Macro (Like ",(0,l.jsx)(n.code,{children:"vec!"}),")"]}),"\n",(0,l.jsxs)(n.p,{children:["Let\u2019s reimplement a simplified ",(0,l.jsx)(n.code,{children:"vec!"})," macro:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"macro_rules! my_vec {\r\n    () => {\r\n        Vec::new()\r\n    };\r\n    ($($x:expr),+ $(,)?) => {\r\n        {\r\n            let mut v = Vec::new();\r\n            $(\r\n                v.push($x);\r\n            )+\r\n            v\r\n        }\r\n    };\r\n}\r\n\r\nfn main() {\r\n    let a = my_vec![];\r\n    let b = my_vec![1, 2, 3];\r\n    let c = my_vec![10, 20, 30,];\r\n}\n"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"()"})," handles empty input."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"$($x:expr),+"})," matches one or more expressions separated by commas."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"$(,)?"})," allows an optional trailing comma."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"$()+"})," repeats the code for each matched ",(0,l.jsx)(n.code,{children:"$x"}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"example-5-generating-code-struct--impl",children:"Example 5: Generating Code (Struct + Impl)"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"macro_rules! make_struct {\r\n    ($name:ident) => {\r\n        struct $name;\r\n\r\n        impl $name {\r\n            fn new() -> Self {\r\n                $name\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nmake_struct!(Foo);\r\n\r\nfn main() {\r\n    let f = Foo::new();\r\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"Expansion:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"struct Foo;\r\n\r\nimpl Foo {\r\n    fn new() -> Self {\r\n        Foo\r\n    }\r\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"This shows how macros can generate items, not just expressions."}),"\n",(0,l.jsx)(n.h2,{id:"hygiene-why-macros-are-safe",children:"Hygiene (Why Macros Are Safe)"}),"\n",(0,l.jsx)(n.p,{children:"Rust macros are hygienic, meaning:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Variables defined inside a macro won\u2019t accidentally clash with variables outside it."}),"\n",(0,l.jsx)(n.li,{children:"Names resolve to the correct scope."}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'macro_rules! make_var {\r\n    () => {\r\n        let x = 10;\r\n        println!("{}", x);\r\n    };\r\n}\r\n\r\nfn main() {\r\n    let x = 5;\r\n    make_var!(); // prints 10, not 5\r\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["The macro\u2019s ",(0,l.jsx)(n.code,{children:"x"})," is distinct from the outer ",(0,l.jsx)(n.code,{children:"x"}),"."]}),"\n",(0,l.jsxs)(n.h2,{id:"when-to-use-macro_rules",children:["When to Use ",(0,l.jsx)(n.code,{children:"macro_rules!"})]}),"\n",(0,l.jsx)(n.p,{children:"Use declarative macros when:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"You want to eliminate repetitive boilerplate."}),"\n",(0,l.jsx)(n.li,{children:"You need syntax that functions can\u2019t express (e.g., variadic arguments)."}),"\n",(0,l.jsx)(n.li,{children:"You want zero runtime cost abstractions."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Avoid them when:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"The logic becomes too complex or unreadable."}),"\n",(0,l.jsx)(n.li,{children:"A function, trait, or generic type would work just as well."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(o,{...e})}):o(e)}}}]);