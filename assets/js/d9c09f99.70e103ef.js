"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[5511],{28453(e,n,s){s.d(n,{R:()=>r,x:()=>o});var l=s(96540);const c={},i=l.createContext(c);function r(e){const n=l.useContext(i);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:r(e.components),l.createElement(i.Provider,{value:n},e.children)}},32272(e,n,s){s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>a});const l=JSON.parse('{"id":"reactjs/Hooks/useCallback","title":"useCallback","description":"The useCallback hook is a React Hook used for performance optimization. It helps you memoize a function, so the same function reference is reused between renders unless its dependencies change.","source":"@site/docs/reactjs/11. Hooks/4. useCallback.md","sourceDirName":"reactjs/11. Hooks","slug":"/reactjs/Hooks/useCallback","permalink":"/handbook/docs/reactjs/Hooks/useCallback","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"reactjsApiSidebar","previous":{"title":"useMemo","permalink":"/handbook/docs/reactjs/Hooks/useMemo"},"next":{"title":"Custom Hooks","permalink":"/handbook/docs/reactjs/Hooks/Custom Hooks"}}');var c=s(74848),i=s(28453);const r={},o=void 0,d={},a=[{value:"What is <code>useCallback</code>",id:"what-is-usecallback",level:2},{value:"Why Do We Need <code>useCallback</code>",id:"why-do-we-need-usecallback",level:2},{value:"When Should You Use <code>useCallback</code>",id:"when-should-you-use-usecallback",level:2},{value:"Syntax of useCallback",id:"syntax-of-usecallback",level:2},{value:"How <code>useCallback</code> Works (Concept)",id:"how-usecallback-works-concept",level:2},{value:"Simple Example \u2013 Function Recreation Problem",id:"simple-example--function-recreation-problem",level:2},{value:"Example with <code>React.memo</code>",id:"example-with-reactmemo",level:2},{value:"Child Component",id:"child-component",level:3},{value:"Without <code>useCallback</code>",id:"without-usecallback",level:3},{value:"With useCallback",id:"with-usecallback",level:3},{value:"<code>useCallback</code> with Dependencies",id:"usecallback-with-dependencies",level:2},{value:"<code>useCallback</code> with <code>useEffect</code>",id:"usecallback-with-useeffect",level:2},{value:"useCallback with Parameters",id:"usecallback-with-parameters",level:2},{value:"<code>useCallback</code> vs <code>useMemo</code>",id:"usecallback-vs-usememo",level:2},{value:"Common Mistakes",id:"common-mistakes",level:2},{value:"Real-World Use Cases",id:"real-world-use-cases",level:2}];function t(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.p,{children:["The ",(0,c.jsx)(n.code,{children:"useCallback"})," hook is a React Hook used for performance optimization. It helps you memoize a function, so the same function reference is reused between renders unless its dependencies change."]}),"\n",(0,c.jsxs)(n.h2,{id:"what-is-usecallback",children:["What is ",(0,c.jsx)(n.code,{children:"useCallback"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"useCallback"})," returns a cached version of a function that only changes if its dependencies change."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const memoizedFn = useCallback(() => {\r\n  // function logic\r\n}, [dependencies]);\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"why-do-we-need-usecallback",children:["Why Do We Need ",(0,c.jsx)(n.code,{children:"useCallback"})]}),"\n",(0,c.jsx)(n.p,{children:"In JavaScript:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Functions are objects"}),"\n",(0,c.jsx)(n.li,{children:"A new function is created on every render"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"In React:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Passing a new function as a prop causes child components to re-render"}),"\n",(0,c.jsx)(n.li,{children:"This can cause unnecessary renders and performance issues"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"useCallback"})," solves this by keeping the same function reference."]}),"\n",(0,c.jsxs)(n.h2,{id:"when-should-you-use-usecallback",children:["When Should You Use ",(0,c.jsx)(n.code,{children:"useCallback"})]}),"\n",(0,c.jsxs)(n.p,{children:["Use ",(0,c.jsx)(n.code,{children:"useCallback"})," when:"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["Passing functions to memoized child components (",(0,c.jsx)(n.code,{children:"React.memo"}),")"]}),"\n",(0,c.jsxs)(n.li,{children:["Functions are dependencies of ",(0,c.jsx)(n.code,{children:"useEffect"})," or ",(0,c.jsx)(n.code,{children:"useMemo"})]}),"\n",(0,c.jsx)(n.li,{children:"Preventing unnecessary re-renders"}),"\n",(0,c.jsx)(n.li,{children:"Functions are expensive to recreate"}),"\n",(0,c.jsx)(n.li,{children:"Large or complex component trees"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"Do not use it everywhere. It has overhead."}),"\n",(0,c.jsx)(n.h2,{id:"syntax-of-usecallback",children:"Syntax of useCallback"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const memoizedFunction = useCallback(() => {\r\n  // logic\r\n}, [dependency1, dependency2]);\n"})}),"\n",(0,c.jsx)(n.p,{children:"Parameters"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Callback function \u2013 the function to memoize"}),"\n",(0,c.jsx)(n.li,{children:"Dependency array \u2013 controls when function is recreated"}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"how-usecallback-works-concept",children:["How ",(0,c.jsx)(n.code,{children:"useCallback"})," Works (Concept)"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"React stores the function reference"}),"\n",(0,c.jsxs)(n.li,{children:["On re-render:","\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"If dependencies are the same \u2192 reuse function"}),"\n",(0,c.jsx)(n.li,{children:"If dependencies change \u2192 create a new function"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"simple-example--function-recreation-problem",children:"Simple Example \u2013 Function Recreation Problem"}),"\n",(0,c.jsxs)(n.p,{children:["Without ",(0,c.jsx)(n.code,{children:"useCallback"})]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'function Parent() {\r\n  const [count, setCount] = React.useState(0);\r\n\r\n  const handleClick = () => {\r\n    console.log("Clicked");\r\n  };\r\n\r\n  return <Child onClick={handleClick} />;\r\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:"Problem"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"handleClick"})," is recreated on every render"]}),"\n",(0,c.jsx)(n.li,{children:"Child receives a new prop"}),"\n",(0,c.jsx)(n.li,{children:"Child re-renders unnecessarily"}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"example-with-reactmemo",children:["Example with ",(0,c.jsx)(n.code,{children:"React.memo"})]}),"\n",(0,c.jsx)(n.h3,{id:"child-component",children:"Child Component"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'const Child = React.memo(({ onClick }) => {\r\n  console.log("Child rendered");\r\n  return <button onClick={onClick}>Click</button>;\r\n});\n'})}),"\n",(0,c.jsxs)(n.h3,{id:"without-usecallback",children:["Without ",(0,c.jsx)(n.code,{children:"useCallback"})]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'function Parent() {\r\n  const [count, setCount] = React.useState(0);\r\n\r\n  const handleClick = () => {\r\n    console.log("Clicked");\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <h2>{count}</h2>\r\n      <button onClick={() => setCount(count + 1)}>+</button>\r\n      <Child onClick={handleClick} />\r\n    </>\r\n  );\r\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"Result"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["Clicking ",(0,c.jsx)(n.code,{children:"+"})," causes parent to re-render"]}),"\n",(0,c.jsxs)(n.li,{children:["New ",(0,c.jsx)(n.code,{children:"handleClick"})," is created"]}),"\n",(0,c.jsx)(n.li,{children:"Child re-renders every time"}),"\n"]}),"\n",(0,c.jsx)(n.h3,{id:"with-usecallback",children:"With useCallback"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"import { useCallback, useState } from 'react';\r\n\r\nfunction Parent() {\r\nconst [count, setCount] = useState(0);\r\n\r\nconst handleClick = useCallback(() => {\r\nconsole.log('Clicked');\r\n}, []);\r\n\r\nreturn (\r\n<>\r\n<h2>{count}</h2>\r\n<button onClick={() => setCount(count + 1)}>+</button>\r\n<Child onClick={handleClick} />\r\n</>\r\n);\r\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"Explanation"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"handleClick"})," reference stays the same"]}),"\n",(0,c.jsx)(n.li,{children:"Child does not re-render"}),"\n",(0,c.jsx)(n.li,{children:"Better performance"}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"usecallback-with-dependencies",children:[(0,c.jsx)(n.code,{children:"useCallback"})," with Dependencies"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const handleAdd = useCallback(() => {\r\n  setCount(count + 1);\r\n}, [count]);\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"Explanation"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["Function depends on ",(0,c.jsx)(n.code,{children:"count"})]}),"\n",(0,c.jsxs)(n.li,{children:["New function is created only when ",(0,c.jsx)(n.code,{children:"count"})," changes"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"If dependency is missing, it may cause stale values."}),"\n",(0,c.jsxs)(n.h2,{id:"usecallback-with-useeffect",children:[(0,c.jsx)(n.code,{children:"useCallback"})," with ",(0,c.jsx)(n.code,{children:"useEffect"})]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"Problem"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"useEffect(() => {\r\n  doSomething();\r\n}, [doSomething]);\n"})}),"\n",(0,c.jsxs)(n.p,{children:["If ",(0,c.jsx)(n.code,{children:"doSomething"})," is recreated every render, effect runs repeatedly."]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"Solution"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"const doSomething = useCallback(() => {\r\n  console.log('Doing something');\r\n}, []);\r\n\r\nuseEffect(() => {\r\n  doSomething();\r\n}, [doSomething]);\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"Explanation"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Function is stable"}),"\n",(0,c.jsx)(n.li,{children:"Effect runs only once"}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"usecallback-with-parameters",children:"useCallback with Parameters"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const handleDelete = useCallback((id) => {\r\n  setItems(items.filter(item => item.id !== id));\r\n}, [items]);\n"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Parameters are passed normally"}),"\n",(0,c.jsx)(n.li,{children:"Dependency array still required"}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"usecallback-vs-usememo",children:[(0,c.jsx)(n.code,{children:"useCallback"})," vs ",(0,c.jsx)(n.code,{children:"useMemo"})]}),"\n",(0,c.jsxs)(n.table,{children:[(0,c.jsx)(n.thead,{children:(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.th,{children:"useCallback"}),(0,c.jsx)(n.th,{children:"useMemo"})]})}),(0,c.jsxs)(n.tbody,{children:[(0,c.jsxs)(n.tr,{children:[(0,c.jsxs)(n.td,{children:["Memoizes ",(0,c.jsx)(n.strong,{children:"function"})]}),(0,c.jsxs)(n.td,{children:["Memoizes ",(0,c.jsx)(n.strong,{children:"value"})]})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:"Returns function"}),(0,c.jsx)(n.td,{children:"Returns result"})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:"Used for handlers"}),(0,c.jsx)(n.td,{children:"Used for calculations"})]})]})]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"useCallback(fn, deps) === useMemo(() => fn, deps);\n"})}),"\n",(0,c.jsx)(n.h2,{id:"common-mistakes",children:"Common Mistakes"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Using useCallback without React.memo"}),"\n",(0,c.jsx)(n.li,{children:"Missing dependencies"}),"\n",(0,c.jsx)(n.li,{children:"Over-optimizing early"}),"\n",(0,c.jsx)(n.li,{children:"Using it for simple components"}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"real-world-use-cases",children:"Real-World Use Cases"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Button click handlers"}),"\n",(0,c.jsx)(n.li,{children:"List item actions"}),"\n",(0,c.jsx)(n.li,{children:"Form submit handlers"}),"\n",(0,c.jsx)(n.li,{children:"Callback props in large apps"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(t,{...e})}):t(e)}}}]);