"use strict";(globalThis.webpackChunkhandbook=globalThis.webpackChunkhandbook||[]).push([[14688],{28453(e,r,n){n.d(r,{R:()=>a,x:()=>l});var t=n(96540);const s={},c=t.createContext(s);function a(e){const r=t.useContext(c);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(c.Provider,{value:r},e.children)}},56529(e,r,n){n.r(r),n.d(r,{assets:()=>i,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"rust/Macros/Procedural Macros","title":"Procedural Macros","description":"Procedural macros are Rust functions that:","source":"@site/docs/rust/Macros/2. Procedural Macros.md","sourceDirName":"rust/Macros","slug":"/rust/Macros/Procedural Macros","permalink":"/handbook/docs/rust/Macros/Procedural Macros","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"rustApiSidebar","previous":{"title":"Declarative Macros","permalink":"/handbook/docs/rust/Macros/Declarative Macros"},"next":{"title":"Custom Derive Macro","permalink":"/handbook/docs/rust/Macros/Custom Derive Macro"}}');var s=n(74848),c=n(28453);const a={},l=void 0,i={},o=[{value:"Types of Procedural Macros",id:"types-of-procedural-macros",level:2},{value:"Key Differences vs <code>macro_rules!</code>",id:"key-differences-vs-macro_rules",level:2},{value:"How Procedural Macros Work (Conceptually)",id:"how-procedural-macros-work-conceptually",level:2},{value:"Setting Up a Procedural Macro Crate",id:"setting-up-a-procedural-macro-crate",level:2},{value:"Example 1: A Custom <code>derive</code> Macro",id:"example-1-a-custom-derive-macro",level:2},{value:"Step 1: Define the trait (in a normal crate)",id:"step-1-define-the-trait-in-a-normal-crate",level:3},{value:"Step 2: Implement the procedural macro (in the proc-macro crate)",id:"step-2-implement-the-procedural-macro-in-the-proc-macro-crate",level:3},{value:"Step 3: Use it in another crate",id:"step-3-use-it-in-another-crate",level:3},{value:"Example 2: Attribute Macro",id:"example-2-attribute-macro",level:2},{value:"Example 3: Function-like Procedural Macro",id:"example-3-function-like-procedural-macro",level:2},{value:"Why Use Procedural Macros",id:"why-use-procedural-macros",level:2},{value:"Safety and Best Practices",id:"safety-and-best-practices",level:2}];function d(e){const r={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,c.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.p,{children:"Procedural macros are Rust functions that:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Run at compile time"}),"\n",(0,s.jsx)(r.li,{children:"Take Rust code as input"}),"\n",(0,s.jsx)(r.li,{children:"Return new Rust code as output"}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["Instead of pattern matching like ",(0,s.jsx)(r.code,{children:"macro_rules!"}),", they operate on Rust\u2019s syntax tree (AST), allowing you to analyze and transform code programmatically."]}),"\n",(0,s.jsx)(r.p,{children:"They are written in Rust and compiled as a special kind of crate."}),"\n",(0,s.jsx)(r.h2,{id:"types-of-procedural-macros",children:"Types of Procedural Macros"}),"\n",(0,s.jsx)(r.p,{children:"There are three kinds:"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Type"}),(0,s.jsx)(r.th,{children:"Syntax"}),(0,s.jsx)(r.th,{children:"Purpose"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:"Function-like"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"my_macro!(...)"})}),(0,s.jsxs)(r.td,{children:["Like ",(0,s.jsx)(r.code,{children:"println!"}),", but procedural"]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:"Derive"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"#[derive(MyTrait)]"})}),(0,s.jsx)(r.td,{children:"Automatically implement traits"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:"Attribute-like"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"#[my_attr]"})}),(0,s.jsx)(r.td,{children:"Modify items like functions, structs, modules"})]})]})]}),"\n",(0,s.jsxs)(r.h2,{id:"key-differences-vs-macro_rules",children:["Key Differences vs ",(0,s.jsx)(r.code,{children:"macro_rules!"})]}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsxs)(r.th,{children:["Declarative (",(0,s.jsx)(r.code,{children:"macro_rules!"}),")"]}),(0,s.jsx)(r.th,{children:"Procedural"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Pattern-based"}),(0,s.jsx)(r.td,{children:"AST-based"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Simpler"}),(0,s.jsx)(r.td,{children:"Much more flexible"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Written inside normal crates"}),(0,s.jsxs)(r.td,{children:["Must be in a ",(0,s.jsx)(r.code,{children:"proc-macro"})," crate"]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"No external crates needed"}),(0,s.jsxs)(r.td,{children:["Usually use ",(0,s.jsx)(r.code,{children:"syn"}),", ",(0,s.jsx)(r.code,{children:"quote"}),", ",(0,s.jsx)(r.code,{children:"proc-macro2"})]})]})]})]}),"\n",(0,s.jsx)(r.h2,{id:"how-procedural-macros-work-conceptually",children:"How Procedural Macros Work (Conceptually)"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"Rust compiler parses your code."}),"\n",(0,s.jsxs)(r.li,{children:["When it sees a procedural macro, it:","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["Converts the input tokens into a ",(0,s.jsx)(r.code,{children:"TokenStream"}),"."]}),"\n",(0,s.jsx)(r.li,{children:"Calls your macro function."}),"\n",(0,s.jsx)(r.li,{children:"Replaces the macro invocation with the returned tokens."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.li,{children:"Compilation continues with the expanded code."}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"setting-up-a-procedural-macro-crate",children:"Setting Up a Procedural Macro Crate"}),"\n",(0,s.jsx)(r.p,{children:"Procedural macros must be in their own crate:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-sh",children:"cargo new my_macros --lib\n"})}),"\n",(0,s.jsxs)(r.p,{children:["Edit ",(0,s.jsx)(r.code,{children:"Cargo.toml"}),":"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-toml",children:'[lib]\r\nproc-macro = true\r\n\r\n[dependencies]\r\nsyn = "2"\r\nquote = "1"\r\nproc-macro2 = "1"\n'})}),"\n",(0,s.jsxs)(r.h2,{id:"example-1-a-custom-derive-macro",children:["Example 1: A Custom ",(0,s.jsx)(r.code,{children:"derive"})," Macro"]}),"\n",(0,s.jsxs)(r.p,{children:["Let\u2019s create a ",(0,s.jsx)(r.code,{children:"#[derive(HelloMacro)]"})," that adds a method."]}),"\n",(0,s.jsx)(r.h3,{id:"step-1-define-the-trait-in-a-normal-crate",children:"Step 1: Define the trait (in a normal crate)"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:"pub trait HelloMacro {\r\n    fn hello();\r\n}\n"})}),"\n",(0,s.jsx)(r.h3,{id:"step-2-implement-the-procedural-macro-in-the-proc-macro-crate",children:"Step 2: Implement the procedural macro (in the proc-macro crate)"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use proc_macro::TokenStream;\r\nuse quote::quote;\r\nuse syn::{parse_macro_input, DeriveInput};\r\n\r\n#[proc_macro_derive(HelloMacro)]\r\npub fn hello_macro_derive(input: TokenStream) -> TokenStream {\r\n    // Parse input into a syntax tree\r\n    let ast = parse_macro_input!(input as DeriveInput);\r\n    let name = ast.ident;\r\n\r\n    // Generate code\r\n    let expanded = quote! {\r\n        impl HelloMacro for #name {\r\n            fn hello() {\r\n                println!("Hello from {}!", stringify!(#name));\r\n            }\r\n        }\r\n    };\r\n\r\n    TokenStream::from(expanded)\r\n}\n'})}),"\n",(0,s.jsx)(r.h3,{id:"step-3-use-it-in-another-crate",children:"Step 3: Use it in another crate"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:"use my_macros::HelloMacro;\r\n\r\n#[derive(HelloMacro)]\r\nstruct Foo;\r\n\r\nfn main() {\r\n    Foo::hello();\r\n}\n"})}),"\n",(0,s.jsx)(r.p,{children:"What gets generated:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'impl HelloMacro for Foo {\r\n    fn hello() {\r\n        println!("Hello from Foo!");\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(r.h2,{id:"example-2-attribute-macro",children:"Example 2: Attribute Macro"}),"\n",(0,s.jsx)(r.p,{children:"Let\u2019s write an attribute macro that logs function entry and exit."}),"\n",(0,s.jsx)(r.p,{children:"Macro crate:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use proc_macro::TokenStream;\r\nuse quote::quote;\r\nuse syn::{parse_macro_input, ItemFn};\r\n\r\n#[proc_macro_attribute]\r\npub fn log_fn(_attr: TokenStream, item: TokenStream) -> TokenStream {\r\n    let input = parse_macro_input!(item as ItemFn);\r\n\r\n    let name = &input.sig.ident;\r\n    let block = &input.block;\r\n    let vis = &input.vis;\r\n    let sig = &input.sig;\r\n\r\n    let expanded = quote! {\r\n        #vis #sig {\r\n            println!("Entering {}", stringify!(#name));\r\n            let result = (|| #block)();\r\n            println!("Exiting {}", stringify!(#name));\r\n            result\r\n        }\r\n    };\r\n\r\n    TokenStream::from(expanded)\r\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:"Usage:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:"use my_macros::log_fn;\r\n\r\n#[log_fn]\r\nfn add(a: i32, b: i32) -> i32 {\r\n    a + b\r\n}\r\n\r\nfn main() {\r\n    let x = add(2, 3);\r\n}\n"})}),"\n",(0,s.jsx)(r.p,{children:"Expanded code:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'fn add(a: i32, b: i32) -> i32 {\r\n    println!("Entering add");\r\n    let result = (|| { a + b })();\r\n    println!("Exiting add");\r\n    result\r\n}\n'})}),"\n",(0,s.jsx)(r.h2,{id:"example-3-function-like-procedural-macro",children:"Example 3: Function-like Procedural Macro"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:"use proc_macro::TokenStream;\r\nuse quote::quote;\r\nuse syn::parse_macro_input;\r\n\r\n#[proc_macro]\r\npub fn make_answer(_input: TokenStream) -> TokenStream {\r\n    quote! {\r\n        fn answer() -> i32 {\r\n            42\r\n        }\r\n    }.into()\r\n}\n"})}),"\n",(0,s.jsx)(r.p,{children:"Usage:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'make_answer!();\r\n\r\nfn main() {\r\n    println!("{}", answer());\r\n}\n'})}),"\n",(0,s.jsx)(r.h2,{id:"why-use-procedural-macros",children:"Why Use Procedural Macros"}),"\n",(0,s.jsx)(r.p,{children:"Use them when:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"You need to analyze Rust syntax, not just match patterns."}),"\n",(0,s.jsx)(r.li,{children:"You want to generate code based on struct fields, attributes, generics, lifetimes, etc."}),"\n",(0,s.jsx)(r.li,{children:"You want to enforce compile-time invariants or build DSLs."}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Common real-world uses:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"serde"}),"\u2019s ",(0,s.jsx)(r.code,{children:"#[derive(Serialize, Deserialize)]"})]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"tokio"}),"\u2019s ",(0,s.jsx)(r.code,{children:"#[tokio::main]"})]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"thiserror"}),"\u2019s ",(0,s.jsx)(r.code,{children:"#[derive(Error)]"})]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"clap"}),"\u2019s ",(0,s.jsx)(r.code,{children:"#[derive(Parser)]"})]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"safety-and-best-practices",children:"Safety and Best Practices"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Procedural macros are powerful but complex \u2014 test them thoroughly."}),"\n",(0,s.jsxs)(r.li,{children:["Always provide good compile-time error messages using ",(0,s.jsx)(r.code,{children:"syn::Error"}),"."]}),"\n",(0,s.jsx)(r.li,{children:"Keep macro logic small and predictable."}),"\n",(0,s.jsxs)(r.li,{children:["Prefer ",(0,s.jsx)(r.code,{children:"macro_rules!"})," if it can solve the problem \u2014 it\u2019s simpler and faster to maintain."]}),"\n"]})]})}function u(e={}){const{wrapper:r}={...(0,c.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);